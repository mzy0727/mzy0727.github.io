<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="mzy的成长历程">
    <meta name="author" content="Mzy">
    
    <title>
        
            Web服务器面试总结 |
        
        Mzy&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/author.svg">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/font/css/brands.min.css">
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"dybil.top","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"base_info":{"primary_color":"#00CC33","title":"Mzy's Blog","author":"Mzy","avatar":"/images/author.svg","logo":"/images/author.svg","favicon":"/images/author.svg"},"menu":{"Archives":"/archives","Tags":"/tags","Categories":"/categories","Links":"/links","About":"/about","Photos":"/photos"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":true},"social_contact":{"enable":true,"links":{"github":"https://dybil.top","weixin":"https://dybil.top","qq":"https://dybil.top","weibo":"https://dybil.top","zhihu":"https://dybil.top","twitter":"https://dybil.top","facebook":"https://dybil.top","email":"https://dybil.top"}},"scroll":{"progress_bar":true,"percent":true,"hide_header":true},"home":{"category":true,"tag":true,"announcement":null},"post":{"author_badge":{"enable":true,"level_badge":false,"custom_badge":["炼气","筑基","结丹","元婴","化神"]},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":true,"share":true,"reward":{"enable":true,"img_link":null,"text":null}},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":false,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":true,"use":"waline","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":"https://waline-test-liart.vercel.app","reaction":true,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":true,"provider":"jsdelivr"},"pjax":{"enable":true},"footer":{"since":2022,"word_count":true,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":true,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","version":"4.0.5"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/author.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Mzy&#39;s Blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    <li class="menu-item">
                        <a class=""
                           href="/"
                        >首页</a>
                    </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >归档</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >标签</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >分类</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >友链</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >关于</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/photos"
                            >相册</a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            <li class="drawer-menu-item flex-center">
                <a class=""
                   href="/"
                >首页</a>
            </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags"
                    >标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links"
                    >友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about"
                    >关于</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/photos"
                    >相册</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            
                <div class="post-content-top border-box"
                     style="height: 13.8rem"
                >
                    <div class="cover-post-title">
                        Web服务器面试总结
                    </div>
                    <img class="post-cover" src="/images/post_banner.jpg"
                         onerror="this.style.display='none'"
                    >
                </div>
            

            <div class="post-content-bottom border-box has-cover">
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/author.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Mzy</span>
                                
                                    <span class="author-badge">元婴</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-check"></i>&nbsp;
                <span class="pc">2024-03-28 17:09:57</span>
                <span class="mobile">2024-03-28 17:09</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="pc" data-updated="Thu Mar 28 2024 17:14:34 GMT+0800">2024-03-28 17:14:34</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <i class="icon fas fa-tags"></i>&nbsp;
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/c/">c++</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/WebServer/">WebServer</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>11.4k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>39 分钟</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <h1 id="项目名称：WebServer"><a href="#项目名称：WebServer" class="headerlink" title="项目名称：WebServer"></a>项目名称：WebServer</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>使用 <strong>线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现)</strong> 的并发模型</li>
<li>使用<strong>状态机</strong>解析HTTP请求报文，支持解析<strong>GET和POST</strong>请求</li>
<li>利用<strong>RAII机制</strong>实现了<strong>数据库连接池</strong>，减少数据库连接建立与关闭的开销，同时实现了用户注册登录功能。</li>
<li>利用<strong>单例模式</strong>与阻塞队列实现异步的日志系统，记录服务器运行状态；</li>
<li>基于<strong>小根堆</strong>实现的定时器，关闭超时的非活动连接；</li>
<li>经<code>Webbench</code>压力测试可以实现<strong>上万的并发连接</strong>数据交换</li>
</ul>
<h2 id="介绍项目"><a href="#介绍项目" class="headerlink" title="介绍项目"></a>介绍项目</h2><p>此项目是基于 Linux 的轻量级多线程 Web 服务器，通过应用层实现了一个简单的 HTTP 服务器。采用了一系列高效的并发模型，包括<strong>线程池、非阻塞 socket、以及 epoll</strong>，同时实现了 ET 和 LT 两种模式，以及 <strong>Reactor</strong> 和<strong>模拟 Proactor</strong> 两种事件处理方式，从而能够同时监听多个请求并高效处理。在请求的处理过程中，使用了<strong>状态机</strong>来解析 HTTP 请求报文，支持 GET 和 POST 请求，确保了服务器能够准确解析并响应客户端请求。为了降低数据库连接建立与关闭的开销，利用 <strong>RAII 机制</strong>实现了<strong>数据库连接池</strong>，同时通过<strong>单例模式</strong>与阻塞队列实现了<strong>异步</strong>的日志系统，能够记录服务器的运行状态。此外，还实现了基于<strong>小根堆的定时器</strong>，用于关闭超时的非活动连接，提高服务器的健壮性和稳定性。通过经过 <strong>Webbench 压力测试</strong>，服务器可以轻松处理上万的并发连接，并且能够高效地进行数据交换，保证了服务器在高负载情况下的稳定性和性能。</p>
<p>该<code>WebServer</code>的总体框架是<strong>半同步半反应堆模型</strong>，主线程通过<code>I/O多路复用</code>监听多个文件描述符上的事件，主要负责连接的建立、断开、数据的读写，然后加入线程池的任务队列中，而工作线程（线程池中的子线程）负责处理逻辑（HTTP请求报文的解析等等），实现任务的高并发处理。在应用层面实现心跳机制，通过<strong>定时器</strong>处理掉不活跃的连接以减少高并发场景下不必要的系统资源的占用（文件描述符的占用、维护TCP连接所需要的资源等）。对于<strong>HTTP请求报文</strong>，采用分散读的方式进行读取，使用有限状态机和正则表达式进行解析；并通过集中写和内存映射的方式对<strong>响应报文</strong>进行传输。应用层还实现了<strong>数据库</strong>功能，采用<code>RAII</code>机制实现连接池，可以实现基本的注册和登录功能。最后还加入了<strong>日志模块</strong>实现对服务器的日常运行情况的记录。</p>
<h3 id="项目的技术难点是什么？"><a href="#项目的技术难点是什么？" class="headerlink" title="项目的技术难点是什么？"></a>项目的技术难点是什么？</h3><p>1、如何提高服务器的并发能力</p>
<p>2、由于涉及到I&#x2F;O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程</p>
<p>3、多线程并发的情况下，保证线程的同步</p>
<h3 id="你是如何克服这个技术难点的？"><a href="#你是如何克服这个技术难点的？" class="headerlink" title="你是如何克服这个技术难点的？"></a>你是如何克服这个技术难点的？</h3><ol>
<li><strong>提高服务器的并发能力</strong>：为了提高服务器的并发能力，我们采用了多种并发模型和技术，包括线程池、非阻塞 socket、以及 epoll。线程池可以有效地管理和重用线程，减少了线程创建和销毁的开销；非阻塞 socket 和 epoll 则使得服务器能够同时处理多个连接，而不会因为阻塞而导致性能下降。此外，采用了 Reactor 和模拟 Proactor 两种事件处理方式，进一步提高了服务器的并发性能。</li>
<li><strong>日志系统的同步阻塞问题</strong>：为了解决同步模式下日志写入可能导致的阻塞问题，我们采用了异步的日志系统。通过单例模式与阻塞队列相结合，将日志写入操作放入队列中，由专门的日志线程异步处理，从而避免了日志写入操作对整个处理流程的阻塞，提高了服务器的并发能力和稳定性。</li>
<li><strong>多线程并发下的线程同步</strong>：在多线程并发的情况下，为了保证线程的同步和数据的一致性，我们采用了多种同步机制，包括互斥锁、条件变量等。例如，在线程池中，通过互斥锁和条件变量来保证任务队列的安全访问和任务的同步执行，从而避免了多线程并发时的竞态条件和数据不一致的问题。</li>
</ol>
<h3 id="你做这个项目的收获是什么？"><a href="#你做这个项目的收获是什么？" class="headerlink" title="你做这个项目的收获是什么？"></a>你做这个项目的收获是什么？</h3><ol>
<li><strong>深入理解网络编程原理</strong>：通过实现一个多线程 Web 服务器，我深入理解了网络编程的基本原理，包括 TCP&#x2F;IP 协议栈、Socket 编程、HTTP 协议等，对网络通信的工作流程和原理有了更清晰的认识。</li>
<li><strong>掌握并发编程技术</strong>：项目中涉及到了多线程、线程池、非阻塞 IO、事件驱动等并发编程技术，通过实践我掌握了这些技术的原理和应用，提高了自己的并发编程能力。</li>
<li><strong>熟悉常用设计模式</strong>：在项目中，我们使用了一些常见的设计模式，如单例模式、RAII 等，通过实践我更加熟悉了这些设计模式的使用场景和实现方法。</li>
<li><strong>解决问题的能力</strong>：在项目开发过程中，遇到了各种各样的技术难点和挑战，通过不断思考和尝试，我学会了如何分析问题、定位问题，并找到解决问题的有效方法。</li>
</ol>
<h3 id="为什么使用这个技术／组件？"><a href="#为什么使用这个技术／组件？" class="headerlink" title="为什么使用这个技术／组件？"></a>为什么使用这个技术／组件？</h3><ol>
<li><strong>性能和效率</strong>：例如，在项目中使用线程池和非阻塞 IO 可以提高服务器的并发处理能力，同时降低了线程创建和销毁的开销，提高了系统的性能和效率。</li>
<li><strong>可扩展性</strong>：选择的技术或组件应具有良好的可扩展性，能够满足系统未来的发展需求。例如，采用了 epoll 和事件驱动的并发模型，能够轻松地处理大量的并发连接，满足系统未来的扩展需求。</li>
<li><strong>稳定性和可靠性</strong>：选择的技术或组件应具有良好的稳定性和可靠性，能够保证系统长时间稳定运行。例如，通过合理设计和实现的线程同步机制和错误处理机制，能够有效地防止系统出现死锁和崩溃等问题，提高了系统的稳定性和可靠性。</li>
</ol>
<h3 id="如何解决项目中的BUG？"><a href="#如何解决项目中的BUG？" class="headerlink" title="如何解决项目中的BUG？"></a>如何解决项目中的BUG？</h3><ol>
<li><strong>复现 Bug</strong>：首先需要确定 BUG 是否可以被复现，以及复现的条件是什么。这一步是非常关键的，因为只有能够复现 BUG，才能够找到解决方案。</li>
<li><strong>定位 Bug</strong>：一旦确定了 BUG 能够被复现，接下来就需要定位 BUG 的原因。这可能涉及到代码的审查、调试工具的使用、日志分析等方法，找出导致 BUG 的根本原因。</li>
<li><strong>修复 Bug</strong>：一旦确定了 BUG 的原因，接下来就是编写修复代码。在编写修复代码的过程中，需要仔细考虑各种边界情况和可能的影响，确保修复代码的正确性和稳定性。</li>
<li><strong>测试修复</strong>：修复代码编写完成后，需要进行测试，确保修复代码能够解决 BUG，并且不会引入新的 BUG。这可能涉及到单元测试、集成测试、系统测试等多种测试手段。</li>
</ol>
<h3 id="项目中用到了什么协议"><a href="#项目中用到了什么协议" class="headerlink" title="项目中用到了什么协议"></a>项目中用到了什么协议</h3><p> HTTP、TCP、ＤＮＳ</p>
<h3 id="后面需要增加的功能"><a href="#后面需要增加的功能" class="headerlink" title="后面需要增加的功能"></a>后面需要增加的功能</h3><h2 id="数据库连接池相关"><a href="#数据库连接池相关" class="headerlink" title="数据库连接池相关"></a>数据库连接池相关</h2><h3 id="什么是数据库连接池？"><a href="#什么是数据库连接池？" class="headerlink" title="什么是数据库连接池？"></a>什么是数据库连接池？</h3><p>预先创建一定数量的数据库连接，并对其进行集中管理。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。</p>
<h3 id="为什么要用数据库连接池？"><a href="#为什么要用数据库连接池？" class="headerlink" title="为什么要用数据库连接池？"></a>为什么要用数据库连接池？</h3><p>首先，数据库连接池是一种池化技术，池化技术的核心思想就是实现资源的复用，避免资源重复创建销毁的开销。而在数据库的应用场景里面，应用程序每次向数据库发起增删改查操作的时候，都需要建立连接。在数据库访问量较大的情况下，频繁的创建连接会带来较大的性能开销。</p>
<p>而连接池的核心思想，就是应用程序在启动的时候提前初始化一部分连接保存到连接池里面，当应用程序需要使用的时候，直接从连接池获取一个已经建立好的连接。</p>
<p>连接池的设计，避免了每次连接的建立和释放。</p>
<h3 id="使用数据库连接池好处？"><a href="#使用数据库连接池好处？" class="headerlink" title="使用数据库连接池好处？"></a><strong>使用数据库连接池好处</strong>？</h3><ul>
<li>资源重用：避免了频繁的创建、释放连接引起的性能开销，在减少系统消耗的基础上，也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程&#x2F;线程的数量）</li>
<li>更快的系统响应速度：数据库连接池在初始化过程中，往往已创建了若干数据库连接于池中备用，此时连接的初始化工作均已完成，对于业务请求处理而言，直接利用现有可用连接，避免了从数据库连接初始化和释放过程的开销，从而缩减了系统整体响应时间</li>
<li>统一的连接管理，避免连接数据库连接泄漏：在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。</li>
</ul>
<p>正常情况下使用<code>mysql</code>连接的流程：TCP三次握手、MySQL Server连接认证、MySQL Server关闭连接回收资源和TCP四次挥手</p>
<p>数据库连接池只有第一次访问要上面这些操作，之后都复用之前的连接</p>
<h2 id="定时器相关"><a href="#定时器相关" class="headerlink" title="定时器相关"></a>定时器相关</h2><h3 id="为什么要用定时器？"><a href="#为什么要用定时器？" class="headerlink" title="为什么要用定时器？"></a><strong>为什么要用定时器？</strong></h3><p>服务器程序通常管理着众多的定时事件，因此有效地组织这些定时事件，使其能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。为此，我们需要将每个定时事件分别封装成定时器，并使用容器类的数据结构，比如链表、排序链表、时间轮和堆，将所有定时器串联起来，以实现对定时事件的统一管理。</p>
<p>简答：为了定期删除非活跃的事件，防止连接资源的浪费。</p>
<p>非活跃：指浏览器与服务器建立连接后，长时间不交换数据，一直占用服务器的文件描述符，导致连接资源的浪费。</p>
<h3 id="为什么使用双向链表而不是单链表？"><a href="#为什么使用双向链表而不是单链表？" class="headerlink" title="为什么使用双向链表而不是单链表？"></a>为什么使用双向链表而不是单链表？</h3><p><strong>删除效率高</strong>：双向链表可以在常数时间内执行删除操作，而单链表需要查找前一个节点才能执行删除操作，其时间复杂度为 O(n)。在定时器链表中，频繁地插入和删除任务是常见的操作，因此双向链表能够更高效地支持这些操作。</p>
<p><strong>支持反向遍历</strong>：双向链表可以支持反向遍历，这在某些情况下可能是有用的，例如需要按照任务的截止时间从后向前检查任务是否超时。</p>
<h3 id="什么是定时器？"><a href="#什么是定时器？" class="headerlink" title="什么是定时器？"></a>什么是定时器？</h3><p>指利用结构体或其他形式，<strong>将多种定时事件进行封装起来</strong>。具体包括连接资源、超时时间和回调函数，这里的回调函数指向定时事件。</p>
<p>定时器：利用结构体将定时事件进行封装起来。</p>
<h3 id="连接资源包括什么？"><a href="#连接资源包括什么？" class="headerlink" title="连接资源包括什么？"></a>连接资源包括什么？</h3><p>连接资源包括客户端套接字地址、文件描述符和定时器</p>
<h3 id="什么是定时事件？"><a href="#什么是定时事件？" class="headerlink" title="什么是定时事件？"></a>什么是定时事件？</h3><p>指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表中删除事件，并关闭文件描述符，释放连接资源。</p>
<p>如：删除epoll树上的注册事件，并关闭对应的socket，连接次数减一。</p>
<p>定时事件：即定期检测非活跃连接。</p>
<h3 id="什么是定时任务？"><a href="#什么是定时任务？" class="headerlink" title="什么是定时任务？"></a>什么是定时任务？</h3><p>将超时的定时器从链表中删除。</p>
<h3 id="什么是定时任务处理函数？"><a href="#什么是定时任务处理函数？" class="headerlink" title="什么是定时任务处理函数？"></a>什么是定时任务处理函数？</h3><p>定时任务处理函数，该函数封装在容器类中，具体的，函数遍历升序链表容器，根据超时时间，删除对应的到期的定时器，并调用回调函数（即定时事件）。</p>
<p>（1）链表容器是升序排列，当前时间小于定时器的超时时间，后面的定时器也没有到期</p>
<p>（2）当前定时器到期，则调用回调函数，执行定时事件</p>
<p>（3）将处理后的定时器从链表容器中删除，并重置头结点</p>
<p><strong>定时任务处理函数在主循环中调用</strong></p>
<p>信号处理函数仅仅发送信号通知程序主循环，将信号对应的处理逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。</p>
<p>信号通知的逻辑：创建管道，其中管道写端写入信号值，管道读端通过I&#x2F;O复用系统监测读事件</p>
<h3 id="说一下定时器的工作原理"><a href="#说一下定时器的工作原理" class="headerlink" title="说一下定时器的工作原理"></a><strong>说一下定时器的工作原理</strong></h3><p>服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序事件链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务处理函数。</p>
<h3 id="为什么管道写端要非阻塞？"><a href="#为什么管道写端要非阻塞？" class="headerlink" title="为什么管道写端要非阻塞？"></a>为什么管道写端要非阻塞？</h3><p>send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。</p>
<h3 id="怎么通知主循环？"><a href="#怎么通知主循环？" class="headerlink" title="怎么通知主循环？"></a>怎么通知主循环？</h3><p>利用alarm函数周期性地触发SIGALARM信号，信号处理函数利用管道通知主循环。</p>
<h3 id="升序双向链表缺点？"><a href="#升序双向链表缺点？" class="headerlink" title="升序双向链表缺点？"></a>升序双向链表缺点？</h3><p>缺点：每次以固定的时间间隔触发<code>SIGALRM</code>信号，调用<strong>定时任务处理函数</strong>处理超时连接会造成一定的触发浪费。举个例子，若当前的<code>TIMESLOT=5</code>，即每隔5ms触发一次<code>SIGALRM</code>，跳出循环执行<strong>定时任务处理函数</strong>，这时如果当前即将超时的任务距离现在还有<code>20ms</code>，那么在这个期间，<code>SIGALRM</code>信号被触发了4次，<strong>定时任务处理函数</strong>也被执行了4次，可是在这4次中，前三次触发都是无意义的。</p>
<h3 id="优化：最小堆，时间轮"><a href="#优化：最小堆，时间轮" class="headerlink" title="优化：最小堆，时间轮"></a><strong>优化：最小堆，时间轮</strong></h3><p><strong>在双向链表的基础上优化</strong>：在添加新定时器时，除了检测新定时器<strong>是否小于头节点定时器</strong>，还应该检测<strong>是否大于尾节点定时器</strong>的时间，都不符合再使用常规插入。</p>
<h3 id="最小堆工作原理"><a href="#最小堆工作原理" class="headerlink" title="最小堆工作原理"></a>最小堆工作原理</h3><p>将所有定时器中超时时间最小的一个定时器的超时值作为alarm函数的定时值。这样，一旦定时任务处理函数tick()被调用，超时时间最小的定时器必然到期，我们就可以在tick 函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个（堆），并将这段最小时间设置为下一次alarm函数的定时值。如此反复，就实现了较为精确的定时。</p>
<h3 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h3><p>基于排序链表的定时器使用唯一的一条链表来管理所有的定时器，所以插入操作的效率随着定时器的数目增多而降低。而时间轮使用了哈希表处理冲突的思想，将定时器散列到不同的链表上。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。很显然，对于时间轮而言，要<strong>提高精度</strong>，就要使<code>槽间隔</code>的值足够小; 要<strong>提高执行效率</strong>，则要求<code>时间轮的槽数</code>值足够大，使定时器尽可能的分布在不同的槽。</p>
<table>
<thead>
<tr>
<th></th>
<th>添加</th>
<th>删除</th>
<th>Tick()</th>
<th>FIFO</th>
</tr>
</thead>
<tbody><tr>
<td>排序链表</td>
<td>O(N)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>yes</td>
</tr>
<tr>
<td>最小堆</td>
<td>O(log N)</td>
<td>O(log N)</td>
<td>O(1)</td>
<td>no</td>
</tr>
<tr>
<td>四叉堆</td>
<td>O(log N)</td>
<td>O(log N)</td>
<td>O(1)</td>
<td>no</td>
</tr>
<tr>
<td>红黑树</td>
<td>O(log N)</td>
<td>O(log N)</td>
<td>O(log N)</td>
<td>no</td>
</tr>
<tr>
<td>时间轮</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>yes</td>
</tr>
<tr>
<td>多级时间轮</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>yes</td>
</tr>
</tbody></table>
<h2 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h2><h3 id="说说你日志的运行机制"><a href="#说说你日志的运行机制" class="headerlink" title="说说你日志的运行机制"></a>说说你日志的运行机制</h3><p>使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类、超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式。</p>
<p>其中<strong>异步写入</strong>方式，将生产者-消费者模型封装成阻塞队列，创建一个写线程，工作线程要写的内容push进队列，写线程从队列中取出内容，写日志文件。</p>
<h3 id="为什么要异步？和同步有什么区别？"><a href="#为什么要异步？和同步有什么区别？" class="headerlink" title="为什么要异步？和同步有什么区别？"></a>为什么要异步？和同步有什么区别？</h3><p><strong>同步方式</strong>：写入日志时会产生比较多的系统调用，若是某条日志信息过大，会阻塞日志系统，造成系统瓶颈。</p>
<p><strong>异步方式</strong>：采用生产者-消费者模式，具有较高的并发能力。将所写的日志内容先存入<strong>阻塞队列</strong>，写线程从阻塞队列中取出内容，写入日志。</p>
<h3 id="优化：异步日志系统的改进：生产者消费者模式-双缓冲机制？"><a href="#优化：异步日志系统的改进：生产者消费者模式-双缓冲机制？" class="headerlink" title="优化：异步日志系统的改进：生产者消费者模式 &#x3D;&gt; 双缓冲机制？"></a>优化：异步日志系统的改进：生产者消费者模式 &#x3D;&gt; 双缓冲机制？</h3><p><strong>生产者消费者模式存在的问题：</strong></p>
<p>消费者从消息队列每读取一条日志信息就写入文件系统，但是写文件操作是很耗时的。频繁的从消息队列中获取数据，而且每次都要上锁，一定会对生产者的写日志效率产生影响，因为生产者也要对消息队列上锁才能把日志信息插入队列的头部，如果此时消息队列正好被消费者锁住了，那么生产者就必须等待了，这样就会很大影响到日志系统整体的吞吐率。</p>
<p><strong>双缓冲机制</strong>：两个消息队列来分别存储：正在写入的日志信息，正在读取的日志信息</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240326200452610.png"  alt="image-20240326200452610"></p>
<p><strong>缓冲区交换</strong></p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240326201704822.png"  alt="image-20240326201704822"></p>
<p><strong>具体流程：</strong></p>
<ol>
<li>后台线程被唤醒，此时 buffer B 缓冲区是空的，因为在上一次进入睡眠之前，buffer B 中数据已经被写入到文件系统中了;</li>
<li>把 buffer A 与 buffer B 进行交换;</li>
<li>把 buffer B 中的数据写入到文件系统;</li>
<li>开始休眠;</li>
</ol>
<p><strong>交换缓冲区，就是把两个指针变量的值交换一下而已，利用<code>C++</code>语言中的<code>swap</code>操作，效率很高（这个过程加锁）</strong></p>
<p><strong>优化：</strong>异步日志系统中，使用了一个全局锁，尽管临界区很小，但是如果线程数目较多，锁争用也可能影响性能。</p>
<h3 id="双缓冲的好处"><a href="#双缓冲的好处" class="headerlink" title="双缓冲的好处"></a>双缓冲的好处</h3><p>在大部分时间中，前台线程和后台线程不会操作同一个缓冲区，这就意味着前台线程的操作，不需要等待后台线程缓慢的写文件操作（不需要锁定临界区）</p>
<p>通过双缓冲技术，很好地解决了生产者与消费者之间的异步操作和速度不匹配问题，提高了日志系统的整体吞吐量。</p>
<p><strong>一种解决方法</strong>是像 Java 的 <code>ConCurrentHashMap</code>那样使用多个桶子(bucket)，前端线程写日志的时候根据线程<code>id</code>哈希到不同的 bucket 中，以减少竞争。这种解决方案本质上就是提供更多的缓冲区，并且把不同的缓冲区分配给不同的线程(根据线程 id 的哈希值)。那些哈希到相同缓冲区的线程，同样是存在争用的情况的，只不过争用的概率被降低了很多。</p>
<h3 id="什么时候交换缓冲区？写入缓冲区满了之后怎么处理？"><a href="#什么时候交换缓冲区？写入缓冲区满了之后怎么处理？" class="headerlink" title="什么时候交换缓冲区？写入缓冲区满了之后怎么处理？"></a>什么时候交换缓冲区？写入缓冲区满了之后怎么处理？</h3><ul>
<li><strong>定时交换</strong>：设置一个定时器，定期检查写入缓冲区的填充状态。当写入缓冲区达到一定的填充阈值时，触发定时器。</li>
<li><strong>条件交换</strong>：当写入缓冲区达到一定的填充阈值时，触发交换操作。</li>
</ul>
<h3 id="现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？"><a href="#现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？" class="headerlink" title="现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？"></a><strong>现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上</strong>？</h3><ul>
<li><p>为了便于故障排查，或服务器状态分析，看是否需要维护；可以使用消息队列进行消息的分发，例如<code>mqtt</code>、<code>rabitmq</code>等等</p>
</li>
<li><p>可以使用 <code>rsync</code>、<code>scp</code> 或者其他文件传输工具来实现文件的复制和传输。</p>
</li>
</ul>
<h3 id="关于项目中用到的设计模式"><a href="#关于项目中用到的设计模式" class="headerlink" title="关于项目中用到的设计模式"></a>关于项目中用到的设计模式</h3><p>单例模式：单例对象的类只能允许一个实例存在，并提供一个访问它的全局访问点，该实例被所有程序模块共享。主要解决一个全局使用的类频繁的创建和销毁的问题，提供了一种创建对象的最佳方式。</p>
<h2 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h2><h3 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h3><p>每个请求对应一个线程的方法的不足之处是：为每个请求创建一个新线程的开销很大；为每个请求创建新线程的服务器在<strong>创建和销毁</strong>线程上花费的时间和<strong>消耗的系统资源</strong>要比花在处理实际的用户请求的时间和资源要更多。</p>
<p>1）<strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>2）<strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>3）<strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="怎么创建线程池（线程池运行逻辑）"><a href="#怎么创建线程池（线程池运行逻辑）" class="headerlink" title="怎么创建线程池（线程池运行逻辑）"></a>怎么创建线程池（线程池运行逻辑）</h3><p>该项目使用线程池（半同步半反应堆模式）并发处理用户请求，<strong>主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等）</strong>。</p>
<p>具体的：主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。</p>
<p>线程池是<strong>空间换时间</strong>,浪费服务器的硬件资源，<strong>换取运行效率</strong>。</p>
<h3 id="线程的同步机制有哪些？"><a href="#线程的同步机制有哪些？" class="headerlink" title="线程的同步机制有哪些？"></a>线程的同步机制有哪些？</h3><p><strong>(1) 同步I&#x2F;O</strong></p>
<p>同步I&#x2F;O指内核向应用程序通知的是<strong>就绪事件</strong>，比如只通知有客户端连接，要求用户代码自行执行I&#x2F;O操作。</p>
<p>a) <strong>阻塞I&#x2F;O</strong>：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/2946151-20230901215846630-491319692.png"  alt="image"></p>
<p>b)<strong>非阻塞I&#x2F;O</strong>：非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1。每隔一段事件去检测IO事件是否就绪。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/2946151-20230901215850668-490102884.png"  alt="image"></p>
<p>c） <strong>信号驱动I&#x2F;O</strong>：首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数（注册回调函数），此时请求即刻返回（不阻塞当前进程），当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知应用线程调用recvfrom来读取数据（运行回调函数）。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/2299517-20211020231008551-518187592.png"  alt="img"></p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/022d91ee6ae94770b590b80e1479f465.png"  alt="img"></p>
<p>d) <strong>I&#x2F;O复用</strong>：IO复用模型的思路就是系统提供了一种函数可以<strong>同时监控多个文件描述符fd的操作</strong>。I&#x2F;O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I&#x2F;O所不同的的，<strong>它们函数可以同时阻塞多个I&#x2F;O操作。而且可以同时对多个读操作，多个写操作的I&#x2F;O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I&#x2F;O操作函数</strong>。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/2299517-20211020231000561-950880511.png"  alt="img"></p>
<ol start="2">
<li><strong>异步I&#x2F;O</strong></li>
</ol>
<p>应用只需要向内核发送一个read 请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用。<strong>异步I&#x2F;O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I&#x2F;O操作。信号驱动IO只是由内核通知我们何时可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成</strong>。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/2299517-20211020231015356-1738554078.png"  alt="img"></p>
<p><strong>在IO模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种IO事件（是就绪事件还是完成事件），以及该由谁来完成IO读写（是应用程序还是内核）。显然，同步对应的是就绪事件，由应用程序完成IO读写，异步对应的是完成事件，由内核来完成IO读写。</strong></p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/2299517-20211020231021458-668722594.png"  alt="img"></p>
<h3 id="线程池中的工作线程是一直等待吗？"><a href="#线程池中的工作线程是一直等待吗？" class="headerlink" title="线程池中的工作线程是一直等待吗？"></a>线程池中的工作线程是一直等待吗？</h3><p>在run函数中，为了能够处理高并发的问题，将线程池中的工作线程都设置为阻塞等待在请求队列是否不为空的条件上，因此项目中线程池中的工作线程是处于 <strong>一直阻塞等待</strong> 的模式下的。</p>
<h3 id="你的线程池工作线程处理完一个任务后的状态是什么？"><a href="#你的线程池工作线程处理完一个任务后的状态是什么？" class="headerlink" title="你的线程池工作线程处理完一个任务后的状态是什么？"></a>你的线程池工作线程处理完一个任务后的状态是什么？</h3><p>（1） 当处理完任务后如果请求队列为空时，则这个线程重新回到阻塞等待的状态</p>
<p>（2） 当处理完任务后如果请求队列不为空时，那么这个线程将处于与其他线程竞争资源的状态，谁获得锁谁就获得了处理事件的资格。</p>
<h3 id="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"><a href="#如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？" class="headerlink" title="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"></a>如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</h3><p>本项目是通过 <strong>对子线程循环调用来解决高并发</strong> 的问题的。</p>
<p>首先在创建线程的同时就调用了pthread_detach将线程进行分离，不用单独对工作线程进行回收，资源自动回收。</p>
<p>我们通过子线程的run调用函数进行while循环，让每一个线程池中的线程永远都不会停止，访问请求被封装到请求队列(list)中，如果没有任务线程就 <strong>一直阻塞等待</strong>，有任务线程就 <strong>抢占式进行处理</strong>，直到请求队列为空，表示任务全部处理完成。</p>
<h3 id="如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢"><a href="#如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢" class="headerlink" title="如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?"></a>如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</h3><p>会，因为线程池内 <strong>线程的数量时有限</strong> 的，如果客户请求占用线程时间过久的话会影响到处理请求的 <strong>效率</strong>，当请求处理过慢时会造成后续接受的请求只能在请求队列中等待被处理，从而影响接下来的客户请求。</p>
<p>应对策略：可以为线程处理请求对象 <strong>设置处理超时时间</strong>, 超过时间先发送信号告知线程处理超时，然后设定一个时间间隔再次检测，若此时这个请求还占用线程则直接将其断开连接。</p>
<h3 id="detach和join有什么区别？"><a href="#detach和join有什么区别？" class="headerlink" title="detach和join有什么区别？"></a>detach和join有什么区别？</h3><p>（1）当调用join()，主线程等待子线程执行完之后，主线程才可以继续执行，此时主线程会释放掉执行完后的子线程资源。主线程等待子线程执行完，可能会造成性能损失。</p>
<p>（2）当调用detach()，主线程与子线程分离，他们成为了两个独立的线程遵循cpu的时间片调度分配策略。子线程执行完成后会自己释放掉资源。分离后的线程，主线程将对它没有控制权。当你确定程序没有使用共享变量或引用之类的话，可以使用detch函数，分离线程。</p>
<h3 id="介绍一下几种典型的锁？"><a href="#介绍一下几种典型的锁？" class="headerlink" title="介绍一下几种典型的锁？"></a>介绍一下几种典型的锁？</h3><ul>
<li><strong>读写锁</strong></li>
</ul>
<p>多个读者可以同时进行读；写者必须互斥（只允许一个写者写，也不能读者写者同时进行）;写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</p>
<ul>
<li><strong>互斥锁</strong></li>
</ul>
<p>一次只能一个线程拥有互斥锁，其他线程只有等待；互斥锁是在抢锁失败的情况下主动放弃CPU进入<strong>睡眠状态</strong>直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。</p>
<ul>
<li><strong>条件变量</strong></li>
</ul>
<p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</p>
<h3 id="如何销毁线程"><a href="#如何销毁线程" class="headerlink" title="如何销毁线程"></a>如何销毁线程</h3><ul>
<li>通过判断标志位，主动退出</li>
<li>通过Thread类中成员方法interrupt()，主动退出</li>
<li>通过Thread类中成员方法stop()，强行退出</li>
</ul>
<h3 id="线程池中有多少个线程，线程池数量如何设定"><a href="#线程池中有多少个线程，线程池数量如何设定" class="headerlink" title="线程池中有多少个线程，线程池数量如何设定"></a>线程池中有多少个线程，线程池数量如何设定</h3><p><strong>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 Ncpu+1</strong>能够实现最优的CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证CPU 时钟周期不被浪费</p>
<p><strong>如果是IO密集型任务，参考值可以设置为 2 Ncpu。</strong>因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费</p>
<h3 id="socket-通信的基本流程（客户端和服务端的通信协议）"><a href="#socket-通信的基本流程（客户端和服务端的通信协议）" class="headerlink" title="socket 通信的基本流程（客户端和服务端的通信协议）"></a>socket 通信的基本流程（客户端和服务端的通信协议）</h3><p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/1322310-20200405094041232-2065687090.png"  alt="img"></p>
<p>简单描述一下Socket的通信流程：</p>
<p>（1）服务端这边首先创建一个Socket（Socket()），然后绑定IP地址和端口号（Bind()），之后注册监听（Listen()），这样服务端就可以监听指定的Socket地址了；<br>（2）客户端这边也创建一个Socket（Socket()）并打开，然后根据服务器IP地址和端口号向服务器Socket发送连接请求（Connect()）；<br>（3） 服务器Socket监听到客户端Socket发来的连接请求之后，被动打开，并调用Accept()函数接收请求，这样客户端和服务器之间的连接就建立好了；<br>（4）成功建立连接之后，客户端和服务器就可以进行数据交互（Receive()、Send()）；<br>（5）在数据交互完之后，各自关闭连接（Close()），交互结束</p>
<h3 id="send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应"><a href="#send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应" class="headerlink" title="send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应"></a>send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应</h3><p>不管是windows还是linux，阻塞还是非阻塞，<strong>send都会分帧发送，分帧到缓冲区能够接收的大小</strong></p>
<h3 id="多线程中线程越多越好吗？不是"><a href="#多线程中线程越多越好吗？不是" class="headerlink" title="多线程中线程越多越好吗？	不是"></a>多线程中线程越多越好吗？	不是</h3><p>（1）假设现有8个CPU、8个线程，每个线程占用一个CPU，同一时间段内，若8个线程都运行往前跑，相比较5&#x2F;6&#x2F;7个线程，8个线程的效率高。<br>（2）但若此时有9个线程，只有8个CPU，9个线程同时运行，则此时牵扯到线程切换，而线程切换是需要消耗时间的。<br>（3）所以随着线程数越多，效率越来越高，但到一个峰值，再增加线程数量时，就会出现问题。线程太多要来回的切换，最终可能线程切换所用时间比执行时间业务所用时间还大。<br>（4） 随着线程数越多,由于线程执行的时序的问题，程序可能会崩溃或产生二义性。</p>
<h2 id="并发模型相关"><a href="#并发模型相关" class="headerlink" title="并发模型相关"></a>并发模型相关</h2><h3 id="简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？主从reactor模型"><a href="#简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？主从reactor模型" class="headerlink" title="简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？主从reactor模型"></a>简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？主从reactor模型</h3><p><strong>事件：I&#x2F;O事件、信号及定时事件</strong></p>
<p>（1）<strong>reactor模式</strong>中，主线程(I&#x2F;O处理单元)<strong>只负责监听文件描述符上是否有事件发生</strong>，有的话立即通知工作线程(逻辑单元 )，将socket可读写事件放入请求队列，交给工作线程处理，即读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由同步I&#x2F;O实现（epoll_wait）。</p>
<p>（2）<strong>proactor模式</strong>中，主线程和内核负责处理读写数据、接受新连接等I&#x2F;O操作，工作线程仅负责<strong>业务逻辑</strong>，如处理客户请求。通常由异步I&#x2F;O实现(aio_read&#x2F;aio_write)。<br>同步I&#x2F;O模型的工作流程如下（epoll_wait为例）：</p>
<blockquote>
<p>主线程往epoll内核事件表注册socket上的读就绪事件。</p>
<p>主线程调用epoll_wait等待socket上有数据可读当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</p>
<p>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</p>
<p>主线程调用epoll_wait等待socket可写。</p>
<p>当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</p>
</blockquote>
<p>（3） <strong>主从Reactor模式</strong>：核心思想是，主反应堆线程只负责分发Acceptor连接建立，已连接套接字上的I&#x2F;O事件交给sub-reactor负责分发。其中 sub-reactor的数量，可以根据CPU的核数来灵活设置。</p>
<p>主反应堆线程一直在感知连接建立的事件，如果有连接成功建立，主反应堆线程通过accept方法获取已连接套接字，接下来会按照一定的算法选取一个从反应堆线程，并把已连接套接字加入到选择好的从反应堆线程中。主反应堆线程唯一的工作，就是调用accept获取已连接套接字，以及将已连接套接字加入到从反应堆线程中。</p>
<h3 id="用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？"><a href="#用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？" class="headerlink" title="用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？"></a>用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</h3><p>epoll的优点：epoll 是一种更加高效的 IO 复用技术</p>
<p>1、没有最大并发连接的限制，能打开的文件描述符（fd）的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2、效率提升，不是轮询的方式，不会随着fd数目的增加效率下降。只有活跃可用的fd才会调用callback函数；<br>即epoll最大的优点就在于它只管“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。</p>
<p>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p>
<h3 id="epoll-的两种工作模式"><a href="#epoll-的两种工作模式" class="headerlink" title="epoll 的两种工作模式"></a>epoll 的两种工作模式</h3><p><strong>LT 模式（水平触发）</strong>：LT（Level - Triggered）是缺省的工作方式，并且同时支持 Block 和 Nonblock Socket。 在这种做法中，内核检测到一个文件描述符就绪了，然后应用程序可以对这个就绪的 fd 进行 IO 操作。应用程序<strong>可以不立即处理该事件，如果不作任何操作，内核还是会继续通知</strong>。</p>
<p><strong>ET 模式（边缘触发）</strong>： ET（Edge - Triggered）是高速工作方式，只支持 Nonblock socket。 在这种模式下，epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件。<strong>必须要一次性将数据读取完</strong>，使用非阻塞I&#x2F;O，读取到出现EAGAIN。但是，如果一直不对这个 fd 进行 IO 操作（从而导致它再次变成未就绪 ），<strong>内核不会发送更多的通知（only once）</strong>。</p>
<p> ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件描述符的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h3 id="select-poll-epoll区别"><a href="#select-poll-epoll区别" class="headerlink" title="select&#x2F;poll&#x2F;epoll区别"></a><strong>select&#x2F;poll&#x2F;epoll区别</strong></h3><p>1）调用函数</p>
<p>select和poll都是一个函数，epoll是一组函数</p>
<p>2）文件描述符数量</p>
<p>select通过<strong>线性表</strong>描述文件描述符集合，文件描述符有上限（与系统内存关系很大），32位机默认是1024个，64位机默认是2048。</p>
<p>poll是<strong>链表</strong>描述，突破了文件描述符上限，最大可以打开文件的数目</p>
<p>epoll通过<strong>红黑树</strong>描述，最大可以打开文件的数目</p>
<p>3）将文件描述符从用户传给内核</p>
<p>select和poll通过将<strong>所有文件描述符拷贝到内核态</strong>，每次调用都需要拷贝</p>
<p><strong>epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用 <code>mmap()</code> 文件映射内存加速与内核空间的消息传递：即 epoll 使用 mmap()  减少复制开销。</strong></p>
<p><strong>重复监听的处理方式</strong></p>
<p>select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。 poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。 epoll：无需重新构建红黑树，直接沿用已存在的即可。</p>
<p>epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上</p>
<p>4）内核判断就绪的文件描述符</p>
<p>select、poll采用 <strong>轮询</strong> 的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。</p>
<p>select和poll通过<strong>线性遍历文件描述符集合</strong>，判断哪个文件描述符上有事件发生</p>
<p>epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。（<strong>观察是否有就绪事件</strong>）</p>
<p>epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list</p>
<p>5）应用程序索引就绪文件描述符</p>
<p>select&#x2F;poll 只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</p>
<p>epoll 返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可</p>
<p>6）工作模式</p>
<p>select和poll都只能工作在相对低效的LT模式下</p>
<p>epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 </p>
<p>7）应用场景</p>
<p>当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll  </p>
<p>当监测的fd数目较小，且全部fd都比较活跃，建议使用select或者poll</p>
<p>当监测的fd数目非常大，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/8l80fsuy5y.png"  alt="img"></p>
<h3 id="LT和ET的使用场景"><a href="#LT和ET的使用场景" class="headerlink" title="LT和ET的使用场景"></a>LT和ET的使用场景</h3><p>LT适用于并发量小的情况，ET适用于并发量大的情况。</p>
<p>ET在通知用户之后，就会将fd从就绪链表中删除，而LT不会，它会一直保留，这就会导致随着fd增多，就绪链表越大，每次都要从头开始遍历找到对应的fd，所以并发量越大效率越低。ET因为会删除所以效率比较高。</p>
<p>（LT模式下只读一次，ET模式下是无限循环读）</p>
<h3 id="怎么解决LT的缺点？"><a href="#怎么解决LT的缺点？" class="headerlink" title="怎么解决LT的缺点？"></a>怎么解决LT的缺点？</h3><p>LT模式下，可写状态的 fd 会一直触发事件，该怎么处理这个问题</p>
<p>数据量很少时直接 send 数据，数据量很多时每次要写数据时，将 fd 绑定 EPOLLOUT 事件，写完后将 fd 同 EPOLLOUT 从 epoll 中移除。</p>
<h3 id="为什么ET模式一定要设置非阻塞？"><a href="#为什么ET模式一定要设置非阻塞？" class="headerlink" title="为什么ET模式一定要设置非阻塞？"></a>为什么ET模式一定要设置非阻塞？</h3><p>因为ET模式下是无限循环读，直到出现错误为 EAGAIN（现在没有数据可读请稍后再试） 或者 EWOULDBLOCK，这两个错误表示socket 为空，然后就停止循环。如果是阻塞，循环读在 socket 为空的时候就会阻塞到那里，主线程的 read（）函数一旦阻塞住，当再有其他监听事件过来就没办法读了，给其他事情造成了影响，所以必须要设置为非阻塞。</p>
<h3 id="epoll-如何判断数据已经读取完成"><a href="#epoll-如何判断数据已经读取完成" class="headerlink" title="epoll 如何判断数据已经读取完成"></a>epoll 如何判断数据已经读取完成</h3><p>epoll ET(Edge Trigger)模式，才需要关注数据是否读取完毕了。使用select或者epoll的LT模式，不用关注，select&#x2F;epoll检测到有数据可读去读就OK了。<br>两种做法：<br>1、针对TCP，调用recv方法，根据recv的返回值。如果<strong>返回值小于我们设定的 recv buff 的大小</strong>，那么就认为接收完毕。<br>2、TCP、UDP都适用，将 socket 设为 NOBLOCK 状态（使用fcntl函数），然后 selec t该 socket可读的时候，使用 read&#x2F;recv 函数读取数据。当返回值为 -1，并且 <strong>errno 是 EAGAIN 或EWOULDBLOCK</strong> 的时候，表示数据读取完毕。</p>
<h3 id="epoll为什么要用红黑树"><a href="#epoll为什么要用红黑树" class="headerlink" title="epoll为什么要用红黑树"></a>epoll为什么要用红黑树</h3><p>epoll 内核中维护了一个内核事件表，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调，当你要添加新的文件描述符的时候也是调用 epoll_ctl 函数使用EPOLL_CTL_ADD 宏来插入，epoll_wait 也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。当要在内核中长久的维护一个数据结构来存放文件描述符，并且时常会有插入，查找和删除的操作发生，这对内核的效率会产生不小的影响，因此需要一种插入，查找和删除效率都不错的数据结构来存放这些文件描述符，那么红黑树当然是不二的人选。</p>

                </div>

                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                Web服务器面试总结
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                2024/03/28/Web服务器面试总结/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    作者
                </div>
                <div class="content">Mzy</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    发布于
                </div>
                <div class="content">2024-03-28 17:09</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    许可
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans">
                        <i class="fa-brands fa-creative-commons"></i>
                        <i class="fa-brands fa-creative-commons-by"></i>
                        <i class="fa-brands fa-creative-commons-nc"></i>
                        <i class="fa-brands fa-creative-commons-sa"></i>
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/c/">c++</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/WebServer/">WebServer</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="分享到 QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="分享到微信"
            data-tooltip-img-tip="微信扫一扫"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="分享到微博"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/03/29/RPC%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"
                                   title="RPC面试总结"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">RPC面试总结</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/02/28/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6MPRPC/"
                                   title="从零实现分布式网络通信框架MPRPC"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">从零实现分布式网络通信框架MPRPC</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">评论插件加载失败</span>
    <button class="reload keep-button">点击重新加载</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">正在加载评论插件</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="waline-comment-container">
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.css"/>
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline-meta.css"/>
        <div id="waline-comment"></div>
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.js"
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        ></script>
        <script data-pjax
                async
        >
          window.KeepCommentPlugin.walineOptions = JSON.parse('{}'.replace(/&#34;/g, '"'))

          window.KeepCommentPlugin.initWaline = () => {
            if (window?.Waline) {
              window.KeepCommentPlugin.walineOptions.el = '#waline-comment'
              window.KeepCommentPlugin.walineOptions.comment = '.post-comments-count'
              window.KeepCommentPlugin.walineOptions.serverURL = 'https://waline-test-liart.vercel.app'
              window.KeepCommentPlugin.walineOptions.lang = 'zh-CN' || 'zh-CN'
              window.KeepCommentPlugin.walineOptions.reaction = 'true' === 'true'
              window.Waline.init(window.KeepCommentPlugin.walineOptions)
              window.KeepCommentPlugin.hideLoading()
            } else {
              setTimeout(() => {
                window.KeepCommentPlugin.initWaline()
              }, 1000)
            }
          }

          if ('true' === 'true') {
            setTimeout(() => {
              window.KeepCommentPlugin.initWaline()
            }, 1200)
          } else {
            window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initWaline)
          }
        </script>
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%EF%BC%9AWebServer"><span class="nav-number">1.</span> <span class="nav-text">项目名称：WebServer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">1.1.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.2.</span> <span class="nav-text">介绍项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">项目的技术难点是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%BF%99%E4%B8%AA%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E7%9A%84%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">你是如何克服这个技术难点的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E5%81%9A%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%94%B6%E8%8E%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">你做这个项目的收获是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%8A%80%E6%9C%AF%EF%BC%8F%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">为什么使用这个技术／组件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84BUG%EF%BC%9F"><span class="nav-number">1.2.5.</span> <span class="nav-text">如何解决项目中的BUG？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.2.6.</span> <span class="nav-text">项目中用到了什么协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E9%9D%A2%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.7.</span> <span class="nav-text">后面需要增加的功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9B%B8%E5%85%B3"><span class="nav-number">1.3.</span> <span class="nav-text">数据库连接池相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是数据库连接池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">为什么要用数据库连接池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">使用数据库连接池好处？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.</span> <span class="nav-text">定时器相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">为什么要用定时器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="nav-number">1.4.2.</span> <span class="nav-text">为什么使用双向链表而不是单链表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">什么是定时器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90%E5%8C%85%E6%8B%AC%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.4.</span> <span class="nav-text">连接资源包括什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9A%E6%97%B6%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="nav-number">1.4.5.</span> <span class="nav-text">什么是定时事件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="nav-number">1.4.6.</span> <span class="nav-text">什么是定时任务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.4.7.</span> <span class="nav-text">什么是定时任务处理函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.8.</span> <span class="nav-text">说一下定时器的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AE%A1%E9%81%93%E5%86%99%E7%AB%AF%E8%A6%81%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="nav-number">1.4.9.</span> <span class="nav-text">为什么管道写端要非阻塞？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E9%80%9A%E7%9F%A5%E4%B8%BB%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="nav-number">1.4.10.</span> <span class="nav-text">怎么通知主循环？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%87%E5%BA%8F%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.4.11.</span> <span class="nav-text">升序双向链表缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%A0%86%EF%BC%8C%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="nav-number">1.4.12.</span> <span class="nav-text">优化：最小堆，时间轮</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%A0%86%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.13.</span> <span class="nav-text">最小堆工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="nav-number">1.4.14.</span> <span class="nav-text">时间轮</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3"><span class="nav-number">1.5.</span> <span class="nav-text">日志相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E6%97%A5%E5%BF%97%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.1.</span> <span class="nav-text">说说你日志的运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%82%E6%AD%A5%EF%BC%9F%E5%92%8C%E5%90%8C%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.5.2.</span> <span class="nav-text">为什么要异步？和同步有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%8F%8C%E7%BC%93%E5%86%B2%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">1.5.3.</span> <span class="nav-text">优化：异步日志系统的改进：生产者消费者模式 &#x3D;&gt; 双缓冲机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.5.4.</span> <span class="nav-text">双缓冲的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BA%A4%E6%8D%A2%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F%E5%86%99%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%A1%E4%BA%86%E4%B9%8B%E5%90%8E%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.5.5.</span> <span class="nav-text">什么时候交换缓冲区？写入缓冲区满了之后怎么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E5%9C%A8%E4%BD%A0%E8%A6%81%E7%9B%91%E6%8E%A7%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E8%BE%93%E5%87%BA%E7%9B%91%E6%8E%A7%E6%97%A5%E5%BF%97%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%A5%E6%97%A5%E5%BF%97%E5%88%86%E5%8F%91%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%EF%BC%9F"><span class="nav-number">1.5.6.</span> <span class="nav-text">现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.7.</span> <span class="nav-text">关于项目中用到的设计模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3"><span class="nav-number">1.6.</span> <span class="nav-text">线程池相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.6.1.</span> <span class="nav-text">为什么要使用线程池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91%EF%BC%89"><span class="nav-number">1.6.2.</span> <span class="nav-text">怎么创建线程池（线程池运行逻辑）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.6.3.</span> <span class="nav-text">线程的同步机制有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F"><span class="nav-number">1.6.4.</span> <span class="nav-text">线程池中的工作线程是一直等待吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.6.5.</span> <span class="nav-text">你的线程池工作线程处理完一个任务后的状态是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B61000%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E5%A4%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E8%83%BD%E5%8F%8A%E6%97%B6%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%91%A2%EF%BC%9F"><span class="nav-number">1.6.6.</span> <span class="nav-text">如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E9%9C%80%E8%A6%81%E5%8D%A0%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%BE%88%E4%B9%85%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E5%91%A2%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E7%AD%96%E7%95%A5%E5%91%A2"><span class="nav-number">1.6.7.</span> <span class="nav-text">如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#detach%E5%92%8Cjoin%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.6.8.</span> <span class="nav-text">detach和join有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="nav-number">1.6.9.</span> <span class="nav-text">介绍一下几种典型的锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%94%80%E6%AF%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.10.</span> <span class="nav-text">如何销毁线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B0%E9%87%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A"><span class="nav-number">1.6.11.</span> <span class="nav-text">线程池中有多少个线程，线程池数量如何设定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-number">1.6.12.</span> <span class="nav-text">socket 通信的基本流程（客户端和服务端的通信协议）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#send%E5%87%BD%E6%95%B0%E5%9C%A8%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%8C%E6%88%96%E8%80%85%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%89%A9%E4%BD%99%E5%A4%A7%E5%B0%8F%E6%97%B6%EF%BC%8Csocket%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8F%8D%E5%BA%94"><span class="nav-number">1.6.13.</span> <span class="nav-text">send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%BA%BF%E7%A8%8B%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F%E4%B8%8D%E6%98%AF"><span class="nav-number">1.6.14.</span> <span class="nav-text">多线程中线程越多越好吗？	不是</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">1.7.</span> <span class="nav-text">并发模型相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%EF%BC%9F%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8Freactor%E3%80%81proactor%EF%BC%9F%E4%B8%BB%E4%BB%8Ereactor%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.7.1.</span> <span class="nav-text">简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？主从reactor模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%86epoll%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8epoll%EF%BC%8C%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F%E5%90%97%EF%BC%9F%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.7.2.</span> <span class="nav-text">用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.7.3.</span> <span class="nav-text">epoll 的两种工作模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-poll-epoll%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.4.</span> <span class="nav-text">select&#x2F;poll&#x2F;epoll区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LT%E5%92%8CET%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.7.5.</span> <span class="nav-text">LT和ET的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3LT%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.7.6.</span> <span class="nav-text">怎么解决LT的缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ET%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="nav-number">1.7.7.</span> <span class="nav-text">为什么ET模式一定要设置非阻塞？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%B7%B2%E7%BB%8F%E8%AF%BB%E5%8F%96%E5%AE%8C%E6%88%90"><span class="nav-number">1.7.8.</span> <span class="nav-text">epoll 如何判断数据已经读取完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">1.7.9.</span> <span class="nav-text">epoll为什么要用红黑树</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2022</span>&nbsp;-&nbsp;2024
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Mzy</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
                
                <div class="deploy-info info-item default">
                    
                        本站由 <span class="tooltip" data-tooltip-content="GitHub Pages"><img src="/images/deploy-provider/github.png"></span> 提供部署服务
                    
                </div>
            
        

        <div class="count-item info-item default">
            
                <span class="count-box border-box word">
                    <span class="item-type border-box">总字数</span>
                    <span class="item-value border-box word">115.1k</span>
                </span>
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%EF%BC%9AWebServer"><span class="nav-number">1.</span> <span class="nav-text">项目名称：WebServer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">1.1.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.2.</span> <span class="nav-text">介绍项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">项目的技术难点是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%BF%99%E4%B8%AA%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E7%9A%84%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">你是如何克服这个技术难点的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E5%81%9A%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%94%B6%E8%8E%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">你做这个项目的收获是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%8A%80%E6%9C%AF%EF%BC%8F%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">为什么使用这个技术／组件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84BUG%EF%BC%9F"><span class="nav-number">1.2.5.</span> <span class="nav-text">如何解决项目中的BUG？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.2.6.</span> <span class="nav-text">项目中用到了什么协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E9%9D%A2%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.7.</span> <span class="nav-text">后面需要增加的功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9B%B8%E5%85%B3"><span class="nav-number">1.3.</span> <span class="nav-text">数据库连接池相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是数据库连接池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">为什么要用数据库连接池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">使用数据库连接池好处？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="nav-number">1.4.</span> <span class="nav-text">定时器相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">为什么要用定时器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="nav-number">1.4.2.</span> <span class="nav-text">为什么使用双向链表而不是单链表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">什么是定时器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90%E5%8C%85%E6%8B%AC%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.4.</span> <span class="nav-text">连接资源包括什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9A%E6%97%B6%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="nav-number">1.4.5.</span> <span class="nav-text">什么是定时事件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="nav-number">1.4.6.</span> <span class="nav-text">什么是定时任务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.4.7.</span> <span class="nav-text">什么是定时任务处理函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.8.</span> <span class="nav-text">说一下定时器的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AE%A1%E9%81%93%E5%86%99%E7%AB%AF%E8%A6%81%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="nav-number">1.4.9.</span> <span class="nav-text">为什么管道写端要非阻塞？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E9%80%9A%E7%9F%A5%E4%B8%BB%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="nav-number">1.4.10.</span> <span class="nav-text">怎么通知主循环？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%87%E5%BA%8F%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.4.11.</span> <span class="nav-text">升序双向链表缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%A0%86%EF%BC%8C%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="nav-number">1.4.12.</span> <span class="nav-text">优化：最小堆，时间轮</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%A0%86%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.13.</span> <span class="nav-text">最小堆工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="nav-number">1.4.14.</span> <span class="nav-text">时间轮</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3"><span class="nav-number">1.5.</span> <span class="nav-text">日志相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E6%97%A5%E5%BF%97%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.1.</span> <span class="nav-text">说说你日志的运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%82%E6%AD%A5%EF%BC%9F%E5%92%8C%E5%90%8C%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.5.2.</span> <span class="nav-text">为什么要异步？和同步有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9A%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%8F%8C%E7%BC%93%E5%86%B2%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">1.5.3.</span> <span class="nav-text">优化：异步日志系统的改进：生产者消费者模式 &#x3D;&gt; 双缓冲机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.5.4.</span> <span class="nav-text">双缓冲的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BA%A4%E6%8D%A2%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F%E5%86%99%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BB%A1%E4%BA%86%E4%B9%8B%E5%90%8E%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.5.5.</span> <span class="nav-text">什么时候交换缓冲区？写入缓冲区满了之后怎么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E5%9C%A8%E4%BD%A0%E8%A6%81%E7%9B%91%E6%8E%A7%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E8%BE%93%E5%87%BA%E7%9B%91%E6%8E%A7%E6%97%A5%E5%BF%97%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%A5%E6%97%A5%E5%BF%97%E5%88%86%E5%8F%91%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%EF%BC%9F"><span class="nav-number">1.5.6.</span> <span class="nav-text">现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.7.</span> <span class="nav-text">关于项目中用到的设计模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3"><span class="nav-number">1.6.</span> <span class="nav-text">线程池相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">1.6.1.</span> <span class="nav-text">为什么要使用线程池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91%EF%BC%89"><span class="nav-number">1.6.2.</span> <span class="nav-text">怎么创建线程池（线程池运行逻辑）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.6.3.</span> <span class="nav-text">线程的同步机制有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F"><span class="nav-number">1.6.4.</span> <span class="nav-text">线程池中的工作线程是一直等待吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.6.5.</span> <span class="nav-text">你的线程池工作线程处理完一个任务后的状态是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B61000%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E5%A4%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E8%83%BD%E5%8F%8A%E6%97%B6%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%91%A2%EF%BC%9F"><span class="nav-number">1.6.6.</span> <span class="nav-text">如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E9%9C%80%E8%A6%81%E5%8D%A0%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%BE%88%E4%B9%85%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E5%91%A2%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E7%AD%96%E7%95%A5%E5%91%A2"><span class="nav-number">1.6.7.</span> <span class="nav-text">如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#detach%E5%92%8Cjoin%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.6.8.</span> <span class="nav-text">detach和join有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="nav-number">1.6.9.</span> <span class="nav-text">介绍一下几种典型的锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%94%80%E6%AF%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.10.</span> <span class="nav-text">如何销毁线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B0%E9%87%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A"><span class="nav-number">1.6.11.</span> <span class="nav-text">线程池中有多少个线程，线程池数量如何设定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-number">1.6.12.</span> <span class="nav-text">socket 通信的基本流程（客户端和服务端的通信协议）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#send%E5%87%BD%E6%95%B0%E5%9C%A8%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%8C%E6%88%96%E8%80%85%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%89%A9%E4%BD%99%E5%A4%A7%E5%B0%8F%E6%97%B6%EF%BC%8Csocket%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8F%8D%E5%BA%94"><span class="nav-number">1.6.13.</span> <span class="nav-text">send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%BA%BF%E7%A8%8B%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F%E4%B8%8D%E6%98%AF"><span class="nav-number">1.6.14.</span> <span class="nav-text">多线程中线程越多越好吗？	不是</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">1.7.</span> <span class="nav-text">并发模型相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%EF%BC%9F%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8Freactor%E3%80%81proactor%EF%BC%9F%E4%B8%BB%E4%BB%8Ereactor%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.7.1.</span> <span class="nav-text">简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？主从reactor模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%86epoll%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8epoll%EF%BC%8C%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F%E5%90%97%EF%BC%9F%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.7.2.</span> <span class="nav-text">用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.7.3.</span> <span class="nav-text">epoll 的两种工作模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-poll-epoll%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.4.</span> <span class="nav-text">select&#x2F;poll&#x2F;epoll区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LT%E5%92%8CET%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.7.5.</span> <span class="nav-text">LT和ET的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3LT%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.7.6.</span> <span class="nav-text">怎么解决LT的缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ET%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="nav-number">1.7.7.</span> <span class="nav-text">为什么ET模式一定要设置非阻塞？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%B7%B2%E7%BB%8F%E8%AF%BB%E5%8F%96%E5%AE%8C%E6%88%90"><span class="nav-number">1.7.8.</span> <span class="nav-text">epoll 如何判断数据已经读取完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">1.7.9.</span> <span class="nav-text">epoll为什么要用红黑树</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->
<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/toggle-theme.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/code-block.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/libs/anime.min.js"></script>

<!-- local-search -->

    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/local-search.js"></script>


<!-- lazyload -->


<div class="pjax">
    
        <!-- post-helper -->
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/post/post-helper.js"></script>

        <!-- toc -->
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/post/toc.js"></script>
        

        <!-- copyright-info -->
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/post/copyright-info.js"></script>
        

        <!-- share -->
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/post/share.js"></script>
        
    

    <!-- category-page -->
    

    <!-- links-page -->
    

    <!-- photos-page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@4.0.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




</body>
</html>
