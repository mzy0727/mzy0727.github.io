[{"title":"C++11新特性（II)","url":"/2023/11/10/C-11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88II%EF%BC%89/","content":"C++11新特性（II）lambda表达式auto func = [capture] (params) opt -&gt; ret &#123; func_body; &#125;;\n\n其中func是可以当作lambda表达式的名字，作为一个函数使用，capture是捕获列表，params是参数表，opt是函数选项(mutable之类)， ret是返回值类型，func_body是函数体。\nauto func1 = [](int a) -&gt; int &#123; return a + 1; &#125;;auto func2 = [](int a) &#123; return a + 2; &#125;;cout &lt;&lt; func1(1) &lt;&lt; &quot; &quot; &lt;&lt; func2(2) &lt;&lt; endl;\n\nlambda表达式允许捕获一定范围内的变量：\n\n[]不捕获任何变量\n[&amp;]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用\n[=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用\n[=, &amp;a]值捕获外部作用域所有变量，按引用捕获a变量\n[a]只值捕获a变量，不捕获其它变量\n[this]捕获当前类中的this指针\n\n智能指针shared_ptrshared_ptr使用了引用计数，每一个shared_ptr的拷贝都指向相同的内存，每次拷贝都会触发引用计数+1，每次生命周期结束析构的时候引用计数-1，在最后一个shared_ptr析构的时候，内存才会释放。\n关于shared_ptr有几点需要注意：\n• 不要用一个裸指针初始化多个shared_ptr，会出现double_free导致程序崩溃\n• 通过shared_from_this()返回this指针，不要把this指针作为shared_ptr返回出来，因为this指针本质就是裸指针，通过this返回可能会导致重复析构，不能把this指针交给智能指针管理。\nclass A &#123;    shared_ptr&lt;A&gt; GetSelf() &#123;        return shared_from_this();        // return shared_ptr&lt;A&gt;(this); 错误，会导致double free    &#125;  &#125;;\n\n\n尽量使用make_shared，少用new。\n不要delete get()返回来的裸指针。\n不是new出来的空间要自定义删除器。\n要避免循环引用，循环引用导致内存永远不会被释放，造成内存泄漏。\n\nweak_ptrweak_ptr是用来监视shared_ptr的生命周期，它不管理shared_ptr内部的指针，它的拷贝的析构都不会影响引用计数，纯粹是作为一个旁观者监视shared_ptr中管理的资源是否存在，可以用来返回this指针和解决循环引用问题。\n\n作用1：返回this指针，上面介绍的shared_from_this()其实就是通过weak_ptr返回的this指针。\n作用2：解决循环引用问题。\n\nunique_ptrstd::unique_ptr是一个独占型的智能指针，它不允许其它智能指针共享其内部指针，也不允许unique_ptr的拷贝和赋值。使用方法和shared_ptr类似，区别是不可以拷贝\nstd::arraystd::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。\nstd::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可：\nstd::array&lt;int, 4&gt; arr= &#123;1,2,3,4&#125;;int len = 4;std::array&lt;int, len&gt; arr = &#123;1,2,3,4&#125;; // 非法, 数组大小参数必须是常量表达式","categories":["笔记"],"tags":["c++"]},{"title":"C++11新特性（I）","url":"/2023/10/31/C-11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88I%EF%BC%89/","content":"C++11新特性1. auto 自动推导类型auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型\nint a = 10;auto b = a;//自动推断类型，b为 int类型auto c = 1.9;//自动推断类型，c为double类型auto d = 1.2e12L;//自动推断类型，d 是 long double\n\n2. using 定义别名之前在 C++中可以通过 typedef 重定义一个类型，语法格式如下：\ntypedef 旧的类型名 新的类型名;// 使用举例typedef unsigned int uint_t;\n\n关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。\nusing 新的类型 = 旧的类型;// 使用举例using uint_t = int;\n\n定义函数指针\n// 使用typedef定义函数指针typedef int(*func_ptr)(int, double);// 使用using定义函数指针using func_ptr1 = int(*)(int, double);\n\n在C++11中，新增了一个特性就是可以通过使用using来为一个模板定义别名，但是typedef不行\ntemplate &lt;typename T&gt;using mymap = map&lt;int, T&gt;;\n\nusing语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。\n3. &amp;&amp; 右值引用\n左值是指存储在内存中、有明确存储地址（可取地址）的数据；\n右值是指可以提供数据值的数据（不可取地址）；\n\n右值分两种：\n\n纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等\n将亡值：与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值、 std::move 的返回值等。\n\n\n右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高C++应用程序的性能。\n\n移动构造中使用了右值引用，会将临时对象中的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。\n\n\n\n左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。\n编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。\nauto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。\n通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。\n\n4. nullptr 标识空指针在C++中NULL和0是等价的，C++11 标准并没有对 NULL 的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字nullptr。nullptr 专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化。\nint*    ptr1 = nullptr;char*   ptr2 = nullptr;double* ptr3 = nullptr;\n\nNULL底层源码\n#ifndef NULL    #ifdef __cplusplus        #define NULL 0    #else        #define NULL ((void *)0)    #endif#endif\n\nC++ 中，void * 类型无法隐式转换为其他类型的指针，此时使用 0 代替 (void *)0)，用于解决空指针的问题。\nnullptr 无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮\n5. decltype 类型推导decltype类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 \nint getSize();int main(void)&#123;    int tempA = 2;        /*1.dclTempA为int*/    decltype(tempA) dclTempA;    /*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize，*/    decltype(getSize()) dclTempB;    return 0;&#125;\n\n decltype和auto都可以用来推断类型，但是二者有几处明显的差异： \n\nauto忽略顶层const，decltype保留顶层const；\n\n对引用操作，auto推断出原有类型，decltype推断出引用； \n\n对解引用操作，auto推断出原有类型，decltype推断出引用； \n\nauto 推断时会实际执行，ecltype不会执行，只做分析。 总之在使用中过程中和const、引用和指针结合时需要特别小心。\n\n\n6. 委托构造C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的\nclass Base &#123;public:    int value1;    int value2;    Base() &#123;        value1 = 1;    &#125;    Base(int value) : Base() &#123;  // 委托 Base() 构造函数        value2 = 2;    &#125;&#125;;\n\n","categories":["笔记"],"tags":["c++"]},{"title":"C++使用MYSQL API 操作数据库","url":"/2023/11/14/C-%E4%BD%BF%E7%94%A8MYSQL-API-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"C++使用MYSQL API 操作数据库在程序中连接数据库服务器，主要包含以下步骤：\n\n初始化连接环境\n连接mysql的服务器需要提供：\n服务器IP\n服务器监听的端口（默认3306）\n服务器的用户名（默认root）和对应的密码\n服务器要操作的具体数据库名\n\n\n对数据库中的数据进行增删改查\n事物处理\n成功：提交事务\n失败：数据回滚\n\n\n数据库的读数据操作-&gt;查询-&gt;得到结果集\n遍历结果集-&gt;获得自己需要的数据\n释放资源\n\nAPI介绍初始化连接环境// 返回值: 该函数将分配、初始化、并返回新对象// 通过返回的这个对象去连接MySQL的服务器MYSQL *mysql_init(MYSQL *mysql) ;\n\n连接mysql服务器/*返回值:     成功: 返回MYSQL*连接句柄, 对于成功的连接，返回值与第1个参数的值相同。返回值指向的内存和第一个参数指针指向的内存一样    失败，返回NULL。    句柄: 是windows中的一个概念, 句柄可以理解为一个实例(或者对象)*/ MYSQL *mysql_real_connect(    MYSQL *mysql,           // mysql_init() 函数的返回值    const char *host,       // mysql服务器的主机地址, 写IP地址即可                            // localhost, null -&gt; 代表本地连接    const char *user,       // 连接mysql服务器的用户名, 默认: root     const char *passwd,     // 连接mysql服务器用户对应的密码, root用户的密码    const char *db,         // 要使用的数据库的名字    unsigned int port,      // 连接的mysql服务器监听的端口                            // 如果==0, 使用mysql的默认端口3306, !=0, 使用指定的这个端口    const char *unix_socket,// 本地套接字, 不使用指定为 NULL    unsigned long client_flag); // 通常指定为0\n\n执行sql语句// 执行一个sql语句, 添删查改的sql语句都可以int mysql_query(MYSQL *mysql, const char *query);参数:    - mysql: mysql_real_connect() 的返回值    - query: 一个可以执行的sql语句, 结尾的位置不需要加 ;返回值:     - 如果查询成功，返回0。如果是查询, 结果集在mysql 对象中    - 如果出现错误，返回非0值。 \n\n获得结果集// 将结果集从 mysql(参数) 对象中取出// MYSQL_RES 对应一块内存, 里边保存着这个查询之后得到的结果集// 如何将行和列的数据从结果集中取出, 需要使用其他函数// 返回值: 具有多个结果的MYSQL_RES结果集合。如果出现错误，返回NULL。 MYSQL_RES *mysql_store_result(MYSQL *mysql);\n\n得到结果集的列数// 从结果集中列的个数// 参数: 调用 mysql_store_result() 得到的返回值// 返回值: 结果集中的列数unsigned int mysql_num_fields(MYSQL_RES *result)\n\n获取表头 -&gt; 字段名// 参数: 调用 mysql_store_result() 得到的返回值// 返回值: MYSQL_FIELD* 指向一个结构体// 通过查询官方文档, 返回是一个结构体的数组// 通过这个函数得到结果集中所有列的名字MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result);\n\n返回值 MYSQL_FIELD 对应的是一个结构体，在 mysql.h 中定义如下:\n// mysql.h// 结果集中的每一个列对应一个 MYSQL_FIELDtypedef struct st_mysql_field &#123;  char *name;                 /* 列名-&gt; 字段的名字 */  char *org_name;             /* Original column name, if an alias */  char *table;                /* Table of column if column was a field */  char *org_table;            /* Org table name, if table was an alias */  char *db;                   /* Database for table */  char *catalog;              /* Catalog for table */  char *def;                  /* Default value (set by mysql_list_fields) */  unsigned long length;       /* Width of column (create length) */  unsigned long max_length;   /* Max width for selected set */  unsigned int name_length;  unsigned int org_name_length;                                                                                          unsigned int table_length;  unsigned int org_table_length;  unsigned int db_length;  unsigned int catalog_length;  unsigned int def_length;  unsigned int flags;         /* Div flags */  unsigned int decimals;      /* Number of decimals in field */  unsigned int charsetnr;     /* Character set */  enum enum_field_types type; /* Type of field. See mysql_com.h for types */  void *extension;&#125; MYSQL_FIELD;\n\n使用示例\n// 得到存储头信息的数组的地址MYSQL_FIELD* fields = mysql_fetch_fields(res);// 得到列数int num = mysql_num_fields(res);// 遍历得到每一列的列名for(int i=0; i&lt;num; ++i)&#123;    printf(&quot;当前列的名字: %s\\n&quot;, fields[i].name);&#125;\n\n得到结果集中字段的长度/* 返回结果集内当前行的列的长度:    1. 如果打算复制字段值，使用该函数能避免调用strlen()。    2. 如果结果集包含二进制数据，必须使用该函数来确定数据的大小，原因在于，对于包含Null字符的任何字段，strlen()将返回错误的结果。*/unsigned long *mysql_fetch_lengths(MYSQL_RES *result);参数:     - result: 通过查询得到的结果集返回值:    - 无符号长整数的数组表示各列的大小。如果出现错误，返回NULL。\n\n遍历结果集typedef char** MYSQL_ROW;// 遍历结果集的下一行 // 如果想遍历整个结果集, 需要对该函数进行循环调用// 返回值是二级指针, char** 指向一个什么类型的内存呢?//    -- 指向一个指针数组, 类型是数组,里边的每个元素都是指针, char* 类型//    -- char* []; 数组中的字符串对应的一列数据// 需要对 MYSQL_ROW 遍历就可以得到每一列的值// 如果要遍历整个结果集, 需要循环调用这个函数MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);参数:     - result: 通过查询得到的结果集返回值:     - 成功: 得到了当前记录中每个字段的值    - 失败: NULL, 说明数据已经读完了\n\n资源回收// 释放结果集void mysql_free_result(MYSQL_RES *result);// 关闭mysql实例void mysql_close(MYSQL *mysql);\n\n事物操作// mysql中默认会进行事务的提交// 因为自动提交事务, 会对我们的操作造成影响// 如果我们操作的步骤比较多, 集合的开始和结束需要用户自己去设置, //需要改为手动方式提交事务my_bool mysql_autocommit(MYSQL *mysql, my_bool mode) /*参数:    如果模式为“1”，启用autocommit模式；如果模式为“0”，禁止autocommit模式。返回值   如果成功，返回0，如果出现错误，返回非0值。 事务提交 */my_bool mysql_commit(MYSQL *mysql);//返回值: 成功: 0, 失败: 非0    // 数据回滚my_bool mysql_rollback(MYSQL *mysql) //返回值: 成功: 0, 失败: 非0\n\n打印错误日志// 返回错误的描述const char *mysql_error(MYSQL *mysql);// 返回错误的编号unsigned int mysql_errno(MYSQL *mysql);\n\n","categories":["笔记"],"tags":["c++","mysql"]},{"title":"C++核心编程I","url":"/2023/09/18/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8BI/","content":"今天的内容包括内存分区模型、内联函数和拷贝构造函数。\n\n\nC++核心编程1. 内存分区模型\n代码区：存放函数的二进制代码，由操作系统进行管理\n全局区：存放全局变量和静态变量以及常量\n栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n堆区：由程序员分配和释放，若程序员不释放，程序结束由操作系统释放\n\n2. 内联函数在C++中，使用关键字 inline 可以将函数定义为内联函数。内联函数的特点是它们的定义必须在每个调用它们的源文件中可见，通常这意味着函数的定义通常会写在头文件（.h）中。\n目的：在编译时将函数的代码嵌入到调用它们的地方，而不是像普通函数一样在链接时进行函数调用。因此，如果函数定义不在可见范围内，编译器无法将其内联到调用点。\n在头文件中声明内联函数的原型（函数声明），并在同一头文件中定义函数的具体实现。\n#构造函数可以直接赋初值，构造函数特性complex (double r = 0, double i = 0) : re(r),im(i)&#123;&#125;\n\n1. 不带指针的构造函数多半不需要写析构函数\t     \t如果class里面带指针，就必须有拷贝构造和拷贝复制\n2. 写在class里面的方法是内联函数（建议编译器内联，最后还是看编译器）\n3. 数据一定要放在private里面，构造函数可以放在private里面，详情见后\n以下的常成员函数在常量对象调用时起作用，若没加 const常量对象调用时会报错 ,所以该加const的地方一定要加\ndouble real() const &#123; return re; &#125;  #常成员函数\n\n\n参数传递尽量用引用，返回也是\n\n同一个class的不同object之间互为友元（firend)\n\n临时对象  typename ()\n\n如果class里面带指针，就必须有拷贝构造和拷贝复制\n\n\n\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t浅拷贝：只拷贝指针\nb &#x3D; a,如果使用编译器默认的函数，是浅拷贝，有可能导致内存泄漏\n3. 拷贝构造函数\n                                                深拷贝:复制内存\n\n拷贝赋值函数：把左边拷贝的右边分三步：1. 先把右边清空，2. 重新分配右边跟左边一样大的内存，3. 拷贝\n\n\n\n变量可以声明多次，但只能定义一次\nextern int a;\t\t#声明extern int a = 0;   #定义\n\n静态函数属于类，而不属于对象\n模板类在编译时要把.h文件和.cpp文件都要添加\n","categories":["笔记"],"tags":["c++"]},{"title":"C++迭代器和指针的区别","url":"/2023/11/17/C-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"C++迭代器和指针的区别\n范围：指针属于迭代器的一种（指针可以用来遍历容器[数组]），迭代器使用后就释放了，不能再继续使用，指针能；指针能指向函数，迭代器不行，只能指向容器\n功能：迭代器有着比指针更细的划分并对应能力不同的功能（重载不同的运算符）\n行为：迭代器比指针更统一和良好的用法（更轻易使用begin()和end()，不用担心越界）。\n\n为什么需要迭代器\n抽象层次： 迭代器提供了对容器元素的高层次抽象，允许使用一致的方式遍历不同类型的容器，而不用关心底层实现。\n安全性： 使用迭代器可以减少指针错误的可能性，因为迭代器受到容器的保护，不容易越界访问或访问非法内存。\n容器封装： 迭代器为容器提供了一种封装，允许容器实现者更灵活地改变底层数据结构，而不会对使用容器的代码产生影响。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"C语言中\"#\"和\"##\"的用法","url":"/2023/11/21/C%E8%AF%AD%E8%A8%80%E4%B8%AD-%E5%92%8C-%E7%9A%84%E7%94%A8%E6%B3%95/","content":"C语言中”#”和”##”的用法#把宏参数变为一个字符串\n##把两个宏参数贴合在一起\n#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;#define STR(s)     #s#define CONS(a,b)  int(a##e##b)int main()&#123;   printf(STR(abc));           // 输出字符串&quot;abc&quot;   printf(&quot;\\n&quot;);   printf(&quot;%d\\n&quot;, CONS(2,3));  // 2e3 输出:2000   return 0;&#125;\n\nabc2000\n\n当宏参数是另一个宏的时候，需要注意的是凡宏定义里有用#或##的地方宏参数是不会再展开。 只有当前宏生效, 参数里的宏不会生效 ！！！\n\n\n\n举例\n#define A          (2)#define STR(s)     #s#define CONS(a,b)  int(a##e##b)printf(&quot;int max: %s\\n&quot;,  STR(INT_MAX));    // INT_MAX ＃include&lt;climits&gt;printf(&quot;%s\\n&quot;, CONS(A, A));                // compile error --- int(AeA)\n\n两句printf会被展开为：\nprintf(&quot;int max: %s\\n&quot;,&quot;INT_MAX&quot;);printf(&quot;%s\\n&quot;, int(AeA));\n\n分析\n由于A和INT_MAX均是宏，且作为宏CONS和STR的参数，并且宏CONS和STR中均含有#或者##符号，所以A和INT_MAX均不能被解引用。导致不符合预期的情况出现。\n\n\n解决这个问题的方法很简单。 加多一层中间转换宏。 加这层宏的用意是把所有宏的参数在这层里全部展开,\n那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数。\n\n#define A           (2)#define _STR(s)     #s#define STR(s)      _STR(s)          // 转换宏#define _CONS(a,b)  int(a##e##b)#define CONS(a,b)   _CONS(a,b)       // 转换宏\n\n#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;#define A           2#define _STR(s)     #s#define STR(s)      _STR(s)          // 转换宏#define _CONS(a,b)  int(a##e##b)#define CONS(a,b)   _CONS(a,b)       // 转换宏int main()&#123;   printf(STR(INT_MAX));           // 输出字符串&quot;abc&quot;   printf(&quot;\\n&quot;);   printf(&quot;%d\\n&quot;, CONS(A,A));  // 2e3 输出:2000   return 0;&#125;\n\n0x7fffffff200","categories":["每日一题"],"tags":["c++"]},{"title":"How to be a leader","url":"/2023/11/09/How-to-be-a-leader/","content":"1.  大事情变小事情，要分的细2.  不要分配任务，要分配作业3.  要详细不要模糊","categories":["语录"],"tags":["语录"]},{"title":"Linux下git使用","url":"/2023/10/09/Linux%E4%B8%8Bgit%E4%BD%BF%E7%94%A8/","content":"简单介绍git的基本命令\n\nLinux下Git使用1. git的安装sudo apt install git\n\n安装完，使用git --version查看git版本\n2. 配置gitgit config --global user.name &quot;Your Name“\t##配置用户 git config --global user.email email@example.com\t##配置邮箱git config --global --list\t\t\t##查看配置信息## --global 全局配置，所有仓库生效，不加就只对当前用户有效## --system 系统配置，对所有用户生效\n\n3. 新建版本库git init\n\n4. 工作区域与文件状态\n\n5. 添加和提交文件git init\t\t##创建仓库git status\t\t##查看仓库的状态git add\t\t\t##添加到暂存库git commit \t\t##提交git rm --cached &lt;file&gt;...\t\t##将文件从暂存区中去除git log\t\t\t##查看提交记录git ls-files\t##查看暂存区的文件git commit -a -m &quot; &quot; #实现添加和提交两个步骤\n\n3. 回退版本git reset --softgit reset --hardgit reset --mixed\t\n\n\ngit reset HEAD^\t\t##默认为mixed,回退一个版本\n\nHEAD 表示当前版本HEAD^ 上一个版本HEAD^^ 上上一个版本HEAD^^^ 上上上一个版本HEAD~0 表示当前版本HEAD~1 上一个版本HEAD^2 上上一个版本HEAD^3 上上上一个版本执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存\n\n误操作之后\ngit reflog\t\t##回溯日志git reset --hard 版本号\t##回退\n\n6. 查看差异\ngit diff\t\t\t\t#默认比较工作区和暂存区之间的差异git diff HEAD\t\t\t#比较工作区和版本库之间的差异git diff --cached\t\t#比较暂存区和版本库之间的区别git diff 版本号\t版本号\t#比较两个版本之间的差异git diff HEAD~ HEAD\t\t#如回退版本\n\n\n7. 删除文件方法1：先删除本地文件，再提交\nrm -rf 3.txt\t##删除本地中的文件git add .\t\t##删除暂存区中的文件git commit -m &#x27;deleted 3.txt&#x27;\t##删除工作区文件\n\n方法2\ngit rm 2.txt\t##删除本地和暂存区中文件git commit -m &#x27;deleted 2.txt&#x27;\t##删除工作区文件\n\n\n8. 忽略文件\necho &quot;*.log&quot; &gt; .gitignore\t\t##表示忽略所有日志文件\n\n\n9. 远程仓库github注册github账号，创建仓库\n10. ssh配置和克隆仓库创建ssh密钥\ncd ~cd .ssh\t\t#如果显示文件不存在，就之间执行以下命令ssh-keygen -t rsa -b 4096 -C &quot;xxx@email.com&quot;\t#直接enter,如果是第二次执行，记得更改文件名，不然会覆盖之前的id_rsa文件，且不可逆\n\n\n执行之前的命令会生成以下两个文件，有.pub的是公钥文件，没有的是私钥文件，复制公钥文件到github的Settings里的ssh配置\n如果是第一次配置就配置完了，如果是第二次，更改了文件名的，就需要新建一个config文件，内容为\n\n意思是：当我们在访问github.com这个网站的时候。使用的是test这个文件里的密钥\ngit clone git@github.com:xxx.git\t\t##克隆新建的远程仓库\n\n\ngit push\t##将本地文件推送到远程仓库\n\n11. 关联本地仓库和远程仓库\n本地无仓库\n\necho &quot;# fist-repo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin git@github.com:xxx.gitgit push -u origin main\n\n\n本地已经有仓库\n\ngit remote add origin git@github.com:xxx.git\t\t##添加一个远程仓库git branch -M main\t\t\t\t\t\t\t\t\t##指定分支的名称为maingit push -u origin main\t\t\t\t\t\t\t\t##把本地的main分支与远程的orgin main分支关联\n\n\n\ngit remote -v\t\t##查看本地仓库对应的远程仓库别名\n\n\n\n12. 分支git branch\t\t\t#查看分支git branch\tdev\t\t#新建分支devgit checkout dev\t#切换到分支dev(有风险，有时会用来恢复文件)git switch main\t\t#切换到分支maingit merge dev\t\t#将要被合并的分支(dev)合并到当前分支(main)git log --graph --oneline --decorate --all\t##查看分支情况git branch -d dev\t#删除分支(已经合并)git branch -D dev\t#删除分支(未合并，强行删除)\n\n\n13. 回退和rebase\n\n\n14. 分支管理和工作流模型\ngit flow模型\n\n\n\n\n\ngithub flow模型\n\n\n\n","categories":["教程"],"tags":["git","linux"]},{"title":"Linux中kill、kill -15、kill -9的区别","url":"/2023/11/19/Linux%E4%B8%ADkill%E3%80%81kill-15%E3%80%81kill-9%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"Linux中kill 、kill -15、kill -9 的区别kill（不加 -* 默认kill -15）命令\n系统会发送一个SIGTERM信号给对应的程序。当程序接收到该signal信号后，将会发生以下事情：\n\n程序立刻停止\n当程序释放相应资源后再停止\n程序可能仍然继续运行\n\n大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应），也就是说，**SIGTERM有可能是会被阻塞的**。\nkill -9命令\n系统给对应程序发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。\n\n在使用kill -9 前，应该先使用 kill -15，给目标进程一个清理善后工作的机会。如果没有，可能会留下一些不完整的文件或状态，从而影响服务的再次启动。\n\nkill -9这个信号可以捕获吗kill -9命令用于发送SIGKILL信号给指定的进程，强制终止该进程。SIGKILL是一个无法捕获或阻止的信号，它会立即终止目标进程，不给进程做清理或善后工作的机会。\n","categories":["每日一题"],"tags":["c++"]},{"title":"Linux中最大socket数量","url":"/2023/11/20/Linux%E4%B8%AD%E6%9C%80%E5%A4%A7socket%E6%95%B0%E9%87%8F/","content":"Linux中最大socket数量linux系统默认ulimit为1024个访问，用户最多可开启的程序数目。一般一个端口的最高连接为2的16次方65535。\n查看全局文件句柄数限制(系统支持的最大值)\ncat /proc/sys/fs/file-max\n\n查看每个进程文件句柄数限制\nulimit -n\n\n如何修改最大连接数量870-Linux下解决高并发socket最大连接数限制_socket 连接数_林林林ZEYU的博客-CSDN博客\n","categories":["每日一题"],"tags":["c++"]},{"title":"Linux高性能服务器编程I","url":"/2023/09/25/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8BI/","content":"今天的内容包括一些linux网络编程基本api和实现了TCP协议的服务端以及客户端。\n\n\n\nLinux高性能服务器编程笔记主机字节序和网络字节序大端字节序（网络字节序，数据传输，JAVA虚拟机）：高位字节存储在内存的低地址处\n小端字节序（主机字节序，现代PC机）：低位字节存储在内存的低地址处\n\n地址族类型通常与协议族类型相对应\n\n\n#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;int main(int argc ,char *argv[])&#123;    char buf[4] = &#123;192,168,1,2&#125;;    int num = *(int *)buf;    int sum = htonl(num);    unsigned char *p = &amp;sum;    printf(&quot;%d %d %d %d\\n&quot;,*p,*(p+1),*(p+2),*(p+3));    return 0;&#125;\n\n#include &lt;iostream&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char *argv[]) &#123;   \t//unsigned char buf[4] = &#123;192, 168, 1, 2&#125;;    char buf[4] = &#123;static_cast&lt;char&gt;(192), static_cast&lt;char&gt;(168), static_cast&lt;char&gt;(1), static_cast&lt;char&gt;(2)&#125;;        int num = *(int *)buf;    int sum = htonl(num);    unsigned char *p = reinterpret_cast&lt;unsigned char *&gt;(&amp;sum);    std::cout &lt;&lt; static_cast&lt;int&gt;(*p) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(*(p + 1)) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(*(p + 2)) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(*(p + 3)) &lt;&lt; std::endl;    return 0;&#125;\n\n2 1 168 192\n\nc语言代码转c++时，在初始化buf数组时，对于大于一个字节的整数，需要将其强制转换为char类型，使用static_cast&lt;char&gt;(value)进行转换即可。这样做可以避免narrowing conversion错误。\n网络里面的数据类型定义都应该用无符号，更加保险\n点分十进制转换// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1int inet_pton(int af, const char * src, void* dst);// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)const char* inet_ntop(int af, const void*  src, char* dst, socklen_t cnt);\n\n// 创建 命名 监听 socket# include &lt;sys/types.h&gt;# include &lt;sys/socket.h&gt;// domain指定使用那个协议族 PF_INET PF_INET6// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)// protocol设置为默认的0// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1int socket(int domain, int type, int protocol);// socket为socket文件描述符// my_addr 为地址信息// addrlen为socket地址长度// 成功返回0 失败返回 -1int bind(int socket, const struct sockaddr* my_addr, socklen_t addrlen);// backlog表示队列最大的长度int listen(int socket, int backlog);// 接受连接 失败返回-1 成功时返回socketint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)\n\n在Linux内核2.2之后，socket backlog参数的形为改变了，现在它指等待accept的完全建立的套接字的队列长度，而不是不完全连接请求的数量。 不完全连接的长度可以使用/proc/sys/net/ipv4/tcp_max_syn_backlog设置。这意味着当前Linux版本使用上面第二种说法，有两个队列：具有由系统范围设置指定的大小的SYN队列 和 应用程序（也就是backlog参数）指定的accept队列。\ncat /proc/sys/net/ipv4/tcp_max_syn_backlog512\n\nTCP协议\n\nTCP三次握手\n客户端#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123;    // 1. 创建套接字    int socket_fd;    socket_fd = socket(AF_INET,SOCK_STREAM,0);    // 2. 连接服务器    struct  sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(8080);    inet_pton(AF_INET,&quot;172.18.192.1&quot;,&amp;addr.sin_addr.s_addr);        connect(socket_fd,(struct sockaddr*)&amp;addr,sizeof(addr));    // 3. 读写数据    char buf[1024] = &quot;&quot;;    while(1)&#123;        int n = read(STDIN_FILENO,buf,sizeof(buf));        write(socket_fd,buf,n);     //发送数据给服务器        n = read(socket_fd,buf,sizeof(buf));        write(STDOUT_FILENO,buf,sizeof(buf));    &#125;    // 4. 关闭链接    close(socket_fd);    return 0;&#125;\n\n服务器#include&lt;iostream&gt;#include&lt;sys/socket.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123;    // 1. 创建套接字    int socket_fd;    socket_fd = socket(AF_INET,SOCK_STREAM,0);    cout&lt;&lt;socket_fd&lt;&lt;endl;    // 2. 绑定 bind    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(8010);    addr.sin_addr.s_addr = 0;   //如果是0，绑定的是通配地址   // inet_pton(AF_INET,&quot;192.168.0.102&quot;,&amp;addr.sin_addr.s_addr);    int ret = bind(socket_fd,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ret &lt; 0)&#123;        perror(&quot;&quot;);        exit(0);    &#125;    // 3. 监听 listen    listen(socket_fd,128);  //参数128是等待监听队列和已连接监听队列之和的最大值（linux2.2后，只表示已连接队列）    // 4. 提取 accept    struct sockaddr_in cliaddr; //已建立连接    socklen_t len = sizeof(cliaddr);    int Con_fd = accept(socket_fd,(struct sockaddr *)&amp;cliaddr,&amp;len);  //已连接套接字    char ip[16]=&quot;&quot;;    printf(&quot;new client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));    // 5. 读写    char buf[1024] = &quot;&quot;;    while(1)&#123;        bzero(buf,sizeof(buf));     //清空buff        int n = read(STDIN_FILENO,buf,sizeof(buf));        write(Con_fd,buf,n);        n = read(Con_fd,buf,sizeof(buf));        printf(&quot;%s\\n&quot;,buf);            &#125;    // 6. 关闭    close(socket_fd);    close(Con_fd);    return 0;&#125;\n\n可以使用命令 nc 127.0.0.1 8008连接服务器\nnew client ip=127.0.0.1 port=56918\n\n出错处理封装函数warp.c#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;void perr_exit(const char *s)&#123;\tperror(s);\texit(1);&#125;int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)&#123;\tint n;\tagain:\tif ( (n = accept(fd, sa, salenptr)) &lt; 0) &#123;\t\tif ((errno == ECONNABORTED) || (errno == EINTR))\t\t\tgoto again;\t\telse\t\t\tperr_exit(&quot;accept error&quot;);\t&#125;\treturn n;&#125;int Bind(int fd, const struct sockaddr *sa, socklen_t salen)&#123;\tint n;\tif ((n = bind(fd, sa, salen)) &lt; 0)\t\tperr_exit(&quot;bind error&quot;);\treturn n;&#125;int Connect(int fd, const struct sockaddr *sa, socklen_t salen)&#123;\tint n;\tif ((n = connect(fd, sa, salen)) &lt; 0)\t\tperr_exit(&quot;connect error&quot;);\treturn n;&#125;int Listen(int fd, int backlog)&#123;\tint n;\tif ((n = listen(fd, backlog)) &lt; 0)\t\tperr_exit(&quot;listen error&quot;);\treturn n;&#125;int Socket(int family, int type, int protocol)&#123;\tint n;\tif ( (n = socket(family, type, protocol)) &lt; 0)\t\tperr_exit(&quot;socket error&quot;);\treturn n;&#125;ssize_t Read(int fd, void *ptr, size_t nbytes)&#123;\tssize_t n;again:\tif ( (n = read(fd, ptr, nbytes)) == -1) &#123;\t\tif (errno == EINTR)\t\t\tgoto again;\t\telse\t\t\treturn -1;\t&#125;\treturn n;&#125;ssize_t Write(int fd, const void *ptr, size_t nbytes)&#123;\tssize_t n;again:\tif ( (n = write(fd, ptr, nbytes)) == -1) &#123;\t\tif (errno == EINTR)\t\t\tgoto again;\t\telse\t\t\treturn -1;\t&#125;\treturn n;&#125;int Close(int fd)&#123;\tint n;\tif ((n = close(fd)) == -1)\t\tperr_exit(&quot;close error&quot;);\treturn n;&#125;ssize_t Readn(int fd, void *vptr, size_t n)&#123;\tsize_t nleft;\tssize_t nread;\tchar *ptr;\tptr = vptr;\tnleft = n;\twhile (nleft &gt; 0) &#123;\t\tif ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123;\t\t\tif (errno == EINTR)\t\t\t\tnread = 0;\t\t\telse\t\t\t\treturn -1;\t\t&#125; else if (nread == 0)\t\t\tbreak;\t\tnleft -= nread;\t\tptr += nread;\t&#125;\treturn n - nleft;&#125;ssize_t Writen(int fd, const void *vptr, size_t n)&#123;\tsize_t nleft;\tssize_t nwritten;\tconst char *ptr;\tptr = vptr;\tnleft = n;\twhile (nleft &gt; 0) &#123;\t\tif ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123;\t\t\tif (nwritten &lt; 0 &amp;&amp; errno == EINTR)\t\t\t\tnwritten = 0;\t\t\telse\t\t\t\treturn -1;\t\t&#125;\t\tnleft -= nwritten;\t\tptr += nwritten;\t&#125;\treturn n;&#125;static ssize_t my_read(int fd, char *ptr)&#123;\tstatic int read_cnt;\tstatic char *read_ptr;\tstatic char read_buf[100];\tif (read_cnt &lt;= 0) &#123;again:\t\tif ((read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) &#123;\t\t\tif (errno == EINTR)\t\t\t\tgoto again;\t\t\treturn -1;\t\t\t&#125; else if (read_cnt == 0)\t\t\treturn 0;\t\tread_ptr = read_buf;\t&#125;\tread_cnt--;\t*ptr = *read_ptr++;\treturn 1;&#125;ssize_t Readline(int fd, void *vptr, size_t maxlen)&#123;\tssize_t n, rc;\tchar c, *ptr;\tptr = vptr;\tfor (n = 1; n &lt; maxlen; n++) &#123;\t\tif ( (rc = my_read(fd, &amp;c)) == 1) &#123;\t\t\t*ptr++ = c;\t\t\tif (c == &#x27;\\n&#x27;)\t\t\t\tbreak;\t\t&#125; else if (rc == 0) &#123;\t\t\t*ptr = 0;\t\t\treturn n - 1;\t\t&#125; else\t\t\treturn -1;\t&#125;\t*ptr = 0;\treturn n;&#125;\n\nwarp.h#ifndef __WRAP_H_#define __WRAP_H_void perr_exit(const char *s);int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr);int Bind(int fd, const struct sockaddr *sa, socklen_t salen);int Connect(int fd, const struct sockaddr *sa, socklen_t salen);int Listen(int fd, int backlog);int Socket(int family, int type, int protocol);ssize_t Read(int fd, void *ptr, size_t nbytes);ssize_t Write(int fd, const void *ptr, size_t nbytes);int Close(int fd);ssize_t Readn(int fd, void *vptr, size_t n);ssize_t Writen(int fd, const void *vptr, size_t n);ssize_t my_read(int fd, char *ptr);ssize_t Readline(int fd, void *vptr, size_t maxlen);#endif\n\n\n多进程服务端#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt; #define BUF_SIZE 256 void do_sigchld(int signo, siginfo_t *siginfo, void *p)&#123;    int status;    pid_t pid;    while((pid = waitpid(0, &amp;status, WNOHANG)) &gt; 0) //0:回收跟调用进程同组的子进程的资源，WNOHANG:不阻塞    &#123;        if (WIFEXITED(status))            printf(&quot;pid = %d, parent pid = %d, child pid = %d, exit status %d\\n&quot;, pid, getpid(), siginfo-&gt;si_pid, WEXITSTATUS(status));        else if (WEXITSTATUS(status))            printf(&quot;pid = %d, parent pid = %d, child pid = %d, exit by signal %d\\n &quot;, pid, getpid(), siginfo-&gt;si_pid, WIFSIGNALED(status));    &#125;&#125; void sys_err(const char *str, int err)&#123;    perror(str);    exit(err);&#125; int main(int argc, char *argv[])&#123;    if (argc &lt; 2)    &#123;        printf(&quot;%s port\\n&quot;, argv[0]);        exit(1);    &#125;    //创建流式套接字    int lfd = socket(AF_INET, SOCK_STREAM, 0);    if (lfd &lt; 0)        sys_err(&quot;socket&quot;, 1);     //绑定ip端口        struct sockaddr_in server_addr;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons((unsigned short)atoi(argv[1]));    server_addr.sin_addr.s_addr = 0; //0表示将本机所有ip都绑定上    int ret = bind(lfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));    if (ret &lt; 0)        sys_err(&quot;bind&quot;, 1);        //监听    ret = listen(lfd, 128);    if (ret &lt; 0)        sys_err(&quot;listen&quot;, 1);        //阻塞SIGCHLD信号    sigset_t set;    sigemptyset(&amp;set);    sigaddset(&amp;set, SIGCHLD);    sigprocmask(SIG_BLOCK, &amp;set, NULL);    int block = 1;    //循环提取    int cfd;    pid_t pid;    struct sockaddr_in client_addr;     socklen_t len = sizeof(client_addr);    char buf[BUF_SIZE];    ssize_t size;    char ip[INET_ADDRSTRLEN] = &quot;&quot;;    while(1)    &#123;        cfd = accept(lfd, (struct sockaddr *)&amp;client_addr, &amp;len);        if (cfd &lt; 0)        &#123;            if (errno == EINTR)                continue;             sys_err(&quot;accept&quot;, 1);        &#125;         printf(&quot;client ip = %s, port = %d connect success\\n&quot;, inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, ip, sizeof(ip)), ntohs(client_addr.sin_port));        pid = fork();        if (pid == 0)        &#123;            //in child            close(lfd); //关闭不用了的监听套接字            //解除阻塞SIGCHLD信号            sigprocmask(SIG_UNBLOCK, &amp;set, NULL);            block = 0;             while(1)            &#123;                memset(buf, 0, sizeof(buf));                size = read(cfd, buf, sizeof(buf));                if (size == 0) //客户端断开连接                &#123;                    printf(&quot;client close\\n&quot;);                    break;                &#125;                 printf(&quot;%s\\n&quot;, buf);                write(cfd, buf, size);            &#125;             break;        &#125;        else if (pid &gt; 0)        &#123;            //in parent            close(cfd); //关闭不用了的跟客户端通讯的套接字            if (1 == block)            &#123;                //先捕捉                struct sigaction sa;                sa.sa_sigaction = do_sigchld;                sigemptyset(&amp;sa.sa_mask);                sa.sa_flags = SA_SIGINFO;                sigaction(SIGCHLD, &amp;sa, NULL);                //后解除阻塞                sigprocmask(SIG_UNBLOCK, &amp;set, NULL);                block = 0;            &#125;        &#125;        else            sys_err(&quot;fork&quot;, 1);    &#125;        //关闭套接字    if (pid == 0)        close(cfd);    else if (pid &gt; 0)        close(lfd);     return 0;&#125;\n\nnew client ip=127.0.0.1 port=53766wnew client ip=127.0.0.1 port=53768q\n\nfree_process 函数是用于处理子进程的结束的信号处理函数。当子进程结束时，父进程会收到 SIGCHLD 信号，该信号会触发 free_process 函数。这个函数使用 waitpid 函数来回收子进程，避免它们成为僵尸进程。\n多线程服务端#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &quot;wrap.h&quot;typedef struct c_info&#123;    int cfd;    struct sockaddr_in cliaddr;&#125;CINFO;void* client_fun(void *arg);int main(int argc, char *argv[])&#123;    if(argc &lt; 2)&#123;        printf(&quot;argc &lt; 2  \\n ./test 8000\\n&quot;);        return 0;    &#125;    pthread_attr_t attr;    pthread_attr_init(&amp;attr);    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED); //设置线程的分离状态为分离态,线程在退出后会自动释放其资源，而不需要其他线程等待它结束。    short port = atoi(argv[1]);    int lfd = tcp4bind(port,NULL);  //创建套接字，绑定    Listen(lfd,5);    struct sockaddr_in cliaddr;    socklen_t len = sizeof(cliaddr);    CINFO *info;    while(1)&#123;        int cfd = Accept(lfd,(struct sockaddr *)&amp;cliaddr,&amp;len);        char ip[16]=&quot;&quot;;       // printf(&quot;new client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));        pthread_t pthid;        info = malloc(sizeof(CINFO));        info-&gt;cfd = cfd;        info-&gt;cliaddr = cliaddr;       // pthread_create(&amp;pthid,NULL,client_fun,info);         pthread_create(&amp;pthid,&amp;attr,client_fun,info);    &#125;    return 0;&#125;void* client_fun(void *arg)&#123;    CINFO *info = (CINFO *)arg;    char ip[16];    printf(&quot;new client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET,&amp;info-&gt;cliaddr.sin_addr.s_addr,ip,16),ntohs(info-&gt;cliaddr.sin_port));    while(1)&#123;        char buf[1024]=&quot;&quot;;        int n = read(info-&gt;cfd,buf,sizeof(buf));        if(n &lt; 0)&#123;            perror(&quot;&quot;);            break;        &#125;else if(n == 0)&#123;            printf(&quot;client close\\n&quot;);            break;        &#125;else&#123;            printf(&quot;%s\\n&quot;,buf);            write(info-&gt;cfd,buf,n);        &#125;    &#125;    close(info-&gt;cfd);    free(info);&#125;\n\n端口复用int opt = 1;setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));\n\n","categories":["笔记"],"tags":["c++","linux","c","网络编程"]},{"title":"define和const区别","url":"/2023/11/24/define%E5%92%8Cconst%E5%8C%BA%E5%88%AB/","content":"define 和 const 区别对于 define 来说， 宏定义实际上是在预编译阶段进行处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进行字符串的展开，遇到多少次就展开多少次，而且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为define宏定义仅仅是展开，因此运行时系统并不为宏定义分配内存，（但是从汇编的角度来讲，define却以立即数的方式保留了多份数据的拷贝）。\n对于 const 来说， const 是在编译期间进行处理的，const 有类型，也有类型检查，程序运行时系统会为 const 常量分配内存，而且从汇编的角度讲，const 常量在出现的地方保留的是真正数据的内存地址，只保留了一份数据的拷贝，省去了不必要的内存空间。而且，有时编译器不会为普通的const常量分配内存，而是直接将const常量添加到符号表中，省去了读取和写入内存的操作，效率更高。\n","categories":["每日一题"],"tags":["c++"]},{"title":"http怎么实现长连接","url":"/2023/12/21/http%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5/","content":"http怎么实现长连接HTTP/1.1起，默认使⽤长连接，⽤以保持连接特性。使⽤长连接的 HTTP协议，会在响应头加⼊这⾏代码：Connection:keep-alive\n在使⽤长连接的情况下，当⼀个⽹页打开完成后，客户端和服务器之间⽤于传输 HTTP 数据 的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。\nKeep-Alive 不会永久保持连接，它有⼀个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都⽀持长连接。 HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。\n","categories":["每日一题"],"tags":["c++"]},{"title":"new和delete与malloc和free的区别","url":"/2023/11/26/new%E5%92%8Cdelete%E4%B8%8Emalloc%E5%92%8Cfree%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"new &#x2F; delete malloc &#x2F; free 区别都可以用来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。\n执行 new 实际上执行两个过程：\n\n分配未初始化的内存空间（malloc）；\n\n使用对象的构造函数对空间进行初始化；返回空间的首地址。\n\n\n如果在第一步分配空间中出现问题，则抛出std::bad_alloc异常，或被某个设定的异常处理函数捕获处理；如果在第二步构造对象时出现异常，则自动调用delete释放内存。\n\n\n执行 delete 实际上也有两个过程：\n\n使用析构函数对对象进行析构；\n回收内存空间（free）。\n\n以上也可以看出new和 malloc 的区别，new 得到的是经过初始化的空间，而malloc得到的是未初始化的空间。所以 new 是 new 一个类型，而 malloc 则是malloc一个字节长度的空间。delete 和 free同理，delete不仅释放空间还析构对象，delete 一个类型，free 一个字节长度的空间。\n\n\n为什么有了 malloc／free ,还需要 new／delete？ \n因为对于非内部数据类型而言，光用 malloc／free 无法满足动态对象的要求。对象在创建的同时需要自动执行构造函数，对象在消亡以前要自动执行析构函数。由于 mallo／free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于 malloc／free，所以有了new／delete操作符。\n","categories":["每日一题"],"tags":["c++"]},{"title":"sprintf与snprintf区别","url":"/2023/11/21/sprintf%E4%B8%8Esnprintf%E5%8C%BA%E5%88%AB/","content":"sprintf与snprintf区别int sprintf(char *str, const char &amp;format, ...);\n\nsprintf是字符串格式化命令，主要功能是把格式化的数据写入字符串str中，返回值为写入str的字节数，结束字符\\0不计入内。其中， str是指要写入的缓冲区，format控制要写入str中数据的格式，例如%s、%d、%x等。\nint snprintf(char *str, size_t size, const char *format, ...);\n\nsnprintf是字符串格式化命令，主要功能是把格式化的数据写入字符串str中，最多写size个字节，包括自动添加在字符串末尾处的结束字符\\0;返回值为写入str的字节数，**包括结束字符\\0**。\nsprintf函数返回的是实际输出到字符串缓冲中的字符个数,而snprintf函数返回的是应该输出到字符串缓冲的字符个数\n#define snprintf_nowarn(...) (snprintf(__VA_ARGS__) &lt; 0 ? abort() : (void)0)\n\n该宏用于调用 snprintf 函数，并检查其返回值是否小于 0。snprintf 函数是一个安全的字符串格式化函数，用于将格式化的数据写入字符串。这里的目的是在调用 snprintf 时，如果返回值小于 0，就调用 abort() 函数，中止程序运行，以防止潜在的错误。\n","categories":["每日一题"],"tags":["c++"]},{"title":"strlen和sizeof的区别","url":"/2023/11/18/strlen%E5%92%8Csizeof%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"strlen 和 sizeof的区别sizeof是C语言中的一个单目运算符，用来计算数据类型所占空间的大小，单位为字节；而strlen是一个函数，用来计算字符串长度。简单来说，就是sizeof不包含\\0,而strlen包含\\0。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar arr1[]=&quot;abcd&quot;;//d的后面自动补上\\0;\tchar arr2[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;//以单个元素赋值，没有\\0的结束符\tprintf(&quot;strlen1=%d\\n&quot;,strlen(arr1));//strlen()计算\\0之前的字符长度\tprintf(&quot;strlen2=%d\\n&quot;,strlen(arr2));//该处计算结果应为随机值，因为arr2[]没定义元素个数，就无法知道在哪能遇到\\0;\tprintf(&quot;sizeof1=%d\\n&quot;,sizeof(arr1));//计算了包含\\0的数据空间大小\tprintf(&quot;sizeof2=%d\\n&quot;,sizeof(arr2));\treturn 0; &#125; \n\nstrlen1=4strlen2=8sizeof1=5sizeof2=4","categories":["每日一题"],"tags":["c++"]},{"title":"vector怎么扩容","url":"/2023/11/22/vector%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9/","content":"vector怎么扩容在 C++ 的标准库中，std::vector 是一个动态数组，其扩容是通过重新分配内存来实现的。当 std::vector 的元素数量达到当前分配的内存大小时，系统会为std::vector分配一块更大的内存，并将原来的元素复制到新的内存中。这个过程中原来的内存会被释放。\nstd::vector 扩容的基本步骤：\n\n分配新的内存：当 std::vector 中的元素个数达到当前分配的内存大小时，需要分配一块新的内存。新的内存大小通常是当前内存大小的两倍(Linux端），(Windows是1.5倍），这样做是为了保证std::vector的操作复杂度为平摊 O(1)。\n将元素复制到新内存：将原来的元素逐个复制到新分配的内存中。\n释放旧内存：释放原来的内存空间。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"五种I/O模型","url":"/2023/12/19/%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/","content":"五种I&#x2F;O模型阻塞 I&#x2F;O 模型（Blocking I&#x2F;O）：\n\n在阻塞 I&#x2F;O 模型中，当应用程序发起一个 I&#x2F;O 操作时，它会被阻塞，直到操作完成。\n这意味着应用程序无法执行其他任务，直到 I&#x2F;O 操作完成。\n\n非阻塞 I&#x2F;O 模型（Non-blocking I&#x2F;O）：\n\n在非阻塞 I&#x2F;O 模型中，应用程序可以继续执行其他任务而不必等待 I&#x2F;O 操作的完成。\n当一个 I&#x2F;O 操作发起后，应用程序可以立即返回并执行其他任务，然后周期性地检查 I&#x2F;O 操作是否完成。\n\n多路复用 I&#x2F;O 模型（I&#x2F;O Multiplexing）：\n\n多路复用 I&#x2F;O 模型使用 select、poll 或 epoll 等机制，允许应用程序监视多个文件描述符，等待其中任何一个变为可读或可写状态。\n当有数据准备好时，应用程序会得到通知，然后可以进行读或写操作。\n\n信号驱动IO\n\nlinux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。\n\n阻塞I&#x2F;O，非阻塞I&#x2F;O，信号驱动I&#x2F;O和I&#x2F;O复用都是同步I&#x2F;O。同步I&#x2F;O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I&#x2F;O操作，异步I&#x2F;O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I&#x2F;O操作。\nUNIX五种IO模型 | 蓝亭书序 (lantingshuxu.github.io)\n","categories":["每日一题"],"tags":["c++"]},{"title":"从零实现WebServer之定时器模块","url":"/2024/01/02/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0WebServer%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A8%A1%E5%9D%97/","content":"从零实现WebServer之定时器模块客户端结构体// 前向声明class util_timer;// 客户端数据结构体struct client_data&#123;    sockaddr_in address;    // 客户端地址    int sockfd;             // 客户socket    util_timer *timer;      // 定时器&#125;;\n\n这段代码进行了对 util_timer 类的前向声明，并定义了一个客户端数据结构体 client_data。这样的设计是为了解决头文件的循环包含问题，即在头文件中需要引用对方的类或结构体，但又不能直接包含对方的头文件。\n以下是代码的解释：\n\nclass util_timer;：这是对 util_timer 类的前向声明。前向声明告诉编译器，在这个文件中会用到 util_timer 类，但具体的定义会在其他地方（可能是其他源文件）给出。\nstruct client_data：这是一个结构体的定义，用于存储客户端的相关信息。结构体包含以下成员：\nsockaddr_in address;：用于存储客户端的地址信息，包括 IP 地址和端口号。\nint sockfd;：客户端的套接字文件描述符，用于标识连接。\nutil_timer *timer;：指向 util_timer 类型的指针，用于关联客户端的定时器。\n\n\n\n通过前向声明，可以在该头文件中使用 util_timer 类型的指针而不需要包含完整的 util_timer 类定义。这有助于避免循环包含问题。\n定时器类这个定时器类通常用于实现定时任务，比如在网络编程中，可以使用定时器来管理连接的超时，定期清理不活跃的连接等。\n// 定时器类class util_timer&#123;public:    util_timer():prev(nullptr), next(nullptr)&#123;&#125;public:     time_t expire;                  // 超时时间    void (*cb_func)(client_data*);  // 回调函数    client_data *user_data;         // 连接资源    util_timer *prev;               // 前指针    util_timer *next;               // 后指针private:&#125;;\n\n这是一个定时器类 util_timer 的实现。以下是该类中的主要成员和说明：\n\nutil_timer()：构造函数，用于初始化 util_timer 对象。在构造函数中，prev 和 next 被初始化为 nullptr，表示初始时还没有前一个和后一个定时器。\nexpire：定时器的超时时间，使用 time_t 类型表示。当当前时间超过 expire 时，定时器即过期。\ncb_func：回调函数指针，指向一个以 client_data* 为参数的函数。当定时器到期时，将调用这个回调函数进行特定的操作。\nuser_data：连接资源，通常是一个指向连接相关信息的结构体或对象的指针，用于在定时器到期时执行回调函数时提供必要的参数。\nprev 和 next：分别表示定时器链表中的前一个定时器和后一个定时器。这两个指针用于将定时器组织成一个双向链表，方便在定时器到期或者被删除时快速地进行链表操作。\n\n定时器双向链表类这个类主要用于管理定时器对象，通过添加、调整、删除、处理定时器来实现定时任务的功能。链表中的定时器按照过期时间升序排序，方便快速定位到期的定时器。\n// 定时器双向链表，按过期时间升序排序class sort_timer_lst&#123;public:    sort_timer_lst();    ~sort_timer_lst();    void add_timer(util_timer *timer);      // 添加定时器    void adjust_timer(util_timer *timer);   // 调整定时器    void del_timer(util_timer *timer);      // 删除定时器    void tick();    // 定时任务处理函数private:    void add_timer(util_timer *timer, util_timer *lst_head);    // 辅助添加函数    util_timer *head;   // 链表头    util_timer *tail;   // 链表尾&#125;;\n\n\n这段代码定义了一个定时器双向链表类 sort_timer_lst，用于管理定时器对象，并按照过期时间升序排序。以下是代码的解释：\n\nclass sort_timer_lst：定时器双向链表类的声明。\npublic 成员函数：\nsort_timer_lst()：构造函数，用于初始化链表头尾。\n~sort_timer_lst()：析构函数，用于释放链表中的所有定时器对象。\nvoid add_timer(util_timer *timer)：添加定时器到链表中。\nvoid adjust_timer(util_timer *timer)：调整定时器，即将定时器从原位置移动到合适的位置。\nvoid del_timer(util_timer *timer)：从链表中删除定时器。\nvoid tick()：定时任务处理函数，用于处理到期的定时器。\n\n\nprivate 成员函数：\nvoid add_timer(util_timer *timer, util_timer *lst_head)：辅助添加函数，用于在指定的链表头 lst_head 处添加定时器。\n\n\n成员变量：\nutil_timer *head;：链表头指针，指向定时器链表的第一个节点。\nutil_timer *tail;：链表尾指针，指向定时器链表的最后一个节点。\n\n\n\n构造函数 sort_timer_lst// 定时器链表构造函数sort_timer_lst::sort_timer_lst()&#123;    head = nullptr;    tail = nullptr;&#125;\n\n这是 sort_timer_lst 类的构造函数的实现，初始化链表的头尾指针：\n构造函数 (sort_timer_lst::sort_timer_lst())：\n\n将链表头指针 head 和链表尾指针 tail 初始化为 nullptr，表示初始时链表为空。\n\n析构函数 ~sort_timer_lst// 定时器链表析构函数，析构所有定时器sort_timer_lst::~sort_timer_lst()&#123;    util_timer *tmp = head;    while (tmp)    &#123;        head = tmp-&gt;next;        delete tmp;        tmp = head;    &#125;    &#125;\n\n这是 sort_timer_lst 类的析构函数的实现，用于释放链表中的所有定时器：\n析构函数 (sort_timer_lst::~sort_timer_lst())：\n\n使用循环遍历整个链表，删除每个节点（定时器），释放相关内存。\n遍历过程中，将链表头指针 head 指向下一个节点，然后删除当前节点。循环直到链表为空。\n\n添加定时器（指定位置） add_timer// 添加定时器，从给定head开始寻找可以插入的位置void sort_timer_lst::add_timer(util_timer *timer, util_timer *lst_head)&#123;    util_timer *prev = lst_head;    util_timer *tmp = prev-&gt;next;    // 遍历链表，找到合适的位置插入    while(tmp != nullptr)&#123;        if(timer-&gt;expire &lt; tmp-&gt;expire)&#123;            prev-&gt;next = timer;            timer-&gt;next = tmp;            tmp-&gt;prev = timer;            timer-&gt;prev = prev;            break;        &#125;        prev = tmp;        tmp = tmp-&gt;next;    &#125;    // 如果找到位置，则插入；否则插入到链表尾部    if(tmp != nullptr)&#123;        prev-&gt;next = timer;        timer-&gt;prev = prev;        timer-&gt;next = nullptr;        tail = timer;    &#125;&#125;\n\n\nadd_timer 函数用于向定时器链表中添加定时器。\n参数 timer 是待添加的定时器，参数 lst_head 是链表的头节点，表示从哪个位置开始寻找插入位置。\n首先，定义两个指针 prev 和 tmp 分别指向 lst_head 的下一个节点，初始化为链表头部。\n然后，遍历链表，比较 timer 的超时时间和当前节点 tmp 的超时时间，找到合适的位置插入。\n如果找到合适的位置，插入 timer 到 prev 和 tmp 之间，调整指针指向。\n如果找不到合适的位置，将 timer 插入到链表尾部，更新 tail 指针。\n这样，保证链表按照超时时间升序排列。\n\n添加定时器（头结点） add_timer// 添加定时器，按过期时间升序插入void sort_timer_lst::add_timer(util_timer *timer)&#123;    if(timer == nullptr)        return ;    if(head == nullptr)&#123;        head = tail = timer;        return ;    &#125;    // 添加到链表头    if(timer-&gt;expire &lt; head-&gt;expire)&#123;        timer-&gt;next = head;        head-&gt;prev = timer;        head = timer;        return ;    &#125;    // 添加到链表中    add_timer(timer,head);&#125;\n\n这是 sort_timer_lst 类的添加定时器函数的实现，用于将定时器按照超时时间升序插入链表中：\n详解：\n\n空链表情况：\n如果链表为空（head 为 nullptr），直接将 head 和 tail 指向传入的定时器，表示链表中只有一个定时器。\n\n\n插入到链表头部情况：\n如果传入的定时器的超时时间小于链表头部定时器的超时时间，将传入的定时器插入到链表头部，更新 head 指针。\n\n\n调用辅助函数 add_timer：\n如果传入的定时器的超时时间大于等于链表头部定时器的超时时间，调用辅助函数 add_timer 进行插入操作。\n\n\n辅助函数 add_timer：\n辅助函数的目标是在链表中找到合适的位置插入新的定时器，以保持链表的升序排序。\n通过比较定时器的超时时间，找到合适的位置插入新的定时器。\n如果找到合适的位置，插入定时器并调整前后指针，保持链表的有序性。\n如果找不到合适的位置，将定时器插入到链表尾部，更新 tail 指针。\n\n\n\n调整定时器 adjust_timer// 调整定时器void sort_timer_lst::adjust_timer(util_timer *timer)&#123;    if(timer == nullptr)&#123;        return ;    &#125;    util_timer *tmp = timer-&gt;next;    if(tmp == nullptr || (timer-&gt;expire &lt; tmp-&gt;expire))&#123;        return ;    &#125;    // 先从链表中删除，再重新按顺序插入    if(timer == head)&#123;        head = head-&gt;next;        head-&gt;prev = nullptr;        timer-&gt;next = nullptr;        add_timer(timer,head);    &#125;else&#123;        timer-&gt;prev-&gt;next = timer-&gt;next;        timer-&gt;next-&gt;prev = timer-&gt;prev;        add_timer(timer,timer-&gt;next);    &#125;&#125;\n\n这是 sort_timer_lst 类的调整定时器函数的实现，用于将链表中的定时器重新按照超时时间升序排列：\n\n空链表或只有一个定时器情况：\n如果链表为空或只有一个定时器，无需调整，直接返回。\n\n\n比较当前定时器和下一个定时器的超时时间：\n如果当前定时器的超时时间小于下一个定时器的超时时间，无需调整，直接返回。\n\n\n删除当前定时器并重新插入：\n如果当前定时器是链表头部的定时器，从链表头部删除，然后调用添加定时器函数 add_timer 重新插入链表。\n如果当前定时器不是链表头部的定时器，从链表中删除，然后调用添加定时器函数 add_timer 从删除点的下一个位置开始重新插入链表。\n\n\n\n删除定时器 del_timer// 删除定时器void sort_timer_lst::del_timer(util_timer *timer)&#123;    if(timer == nullptr)&#123;        return ;    &#125;    if((timer == head) &amp;&amp; (timer == tail))&#123;        delete timer;        head = nullptr;        tail = nullptr;        return ;    &#125;    if(timer == head)&#123;        head = head-&gt;next;        head-&gt;prev = nullptr;        delete timer;        return ;    &#125;    if(timer == tail)&#123;        tail = tail-&gt;prev;        tail-&gt;next = nullptr;        delete timer;        return ;    &#125;    timer-&gt;prev-&gt;next = timer-&gt;next;    timer-&gt;next-&gt;prev = timer-&gt;prev;    delete timer;&#125;\n\n这是 sort_timer_lst 类的删除定时器函数的实现，用于从链表中删除指定的定时器：\n\n空链表情况：\n如果链表为空，直接返回，无需删除。\n\n\n删除链表头部定时器情况：\n如果待删除的定时器是链表头部的定时器，将链表头部指针移动到下一个定时器，并删除原链表头部定时器。\n\n\n删除链表尾部定时器情况：\n如果待删除的定时器是链表尾部的定时器，将链表尾部指针移动到上一个定时器，并删除原链表尾部定时器。\n\n\n一般情况：\n如果待删除的定时器不是头部或尾部定时器，将待删除定时器的前后节点连接起来，然后删除待删除定时器。\n\n\n\n定时任务处理函数 tick// SIGALRM 信号每次被触发，主循环中调有一次定时任务处理函数，处理链表容器中到期的定时器void sort_timer_lst::tick()&#123;    if(head == nullptr)&#123;        return ;    &#125;    time_t cur = time(nullptr);    util_timer *tmp = head;    while(tmp != nullptr)&#123;        if(cur &lt; tmp-&gt;expire)&#123;            break;        &#125;        // 过期时间小于当前时间，释放连接        tmp-&gt;cb_func(tmp-&gt;user_data);        head = tmp-&gt;next;        if(head != nullptr)&#123;            head-&gt;prev = nullptr;        &#125;        delete tmp;        tmp = head;    &#125;&#125;\n\n通用类这个类主要包含了一些通用的工具函数，例如处理信号、初始化定时器、设置非阻塞模式、添加文件描述符到 epoll 事件表等。这些工具函数在服务器程序中可能会被频繁调用，用于处理与网络、定时器相关的操作。\n// 通用类class Utils&#123;public:    Utils()&#123;&#125;    ~Utils()&#123;&#125;    // 静态函数避免this指针    static void sig_handler(int sig);    void init(int timeslot);    int setnonblocking(int fd);    void addfd(int epollfd, int fd, bool one_shot, int TRIGMode);    void addsig(int sig, void(*handler)(int), bool restart = true);    void timer_handler();    void show_error(int connfd, const char *info);public:    static int *u_pipefd;           // 本地套接字    static int u_epollfd;           // epoll句柄    sort_timer_lst m_timer_lst;     // 定时器链表    int m_timeslot;                 // 定时时间&#125;;\n\n这段代码定义了一个通用类 Utils，主要包含了一些静态和非静态的工具函数。以下是对这个类的主要函数的解释：\n\n构造函数和析构函数：\nUtils()：构造函数，用于初始化 Utils 类的实例。\n~Utils()：析构函数，用于释放 Utils 类的实例。\n\n\n静态成员变量：\nstatic int *u_pipefd;：本地套接字数组。\nstatic int u_epollfd;：epoll 句柄。\n\n\n非静态成员变量：\nsort_timer_lst m_timer_lst;：定时器链表对象。\nint m_timeslot;：定时时间。\n\n\n静态函数：\nstatic void sig_handler(int sig)：信号处理函数。用于处理指定信号 sig 的行为。\n\n\n非静态函数：\nvoid init(int timeslot)：初始化函数，用于初始化定时时间。\nint setnonblocking(int fd)：设置文件描述符 fd 为非阻塞模式。\nvoid addfd(int epollfd, int fd, bool one_shot, int TRIGMode)：将文件描述符 fd 添加到 epoll 事件表中。\nvoid addsig(int sig, void(*handler)(int), bool restart = true)：添加信号处理函数，指定信号 sig 的处理函数为 handler。\nvoid timer_handler()：定时器处理函数，用于处理定时器到期的事件。\nvoid show_error(int connfd, const char *info)：显示错误信息。\n\n\n\n初始化函数 initvoid Utils::init(int timeslot)&#123;    m_timeslot = timeslot;&#125;\n\n设置时间槽大小：\n\n将函数参数 timeslot 赋值给类成员变量 m_timeslot，即设置定时器时间槽大小。\n\n该函数用于初始化 Utils 类的定时器时间槽大小。\n设置非阻塞 setnoblocking// 设置非阻塞，读不到数据时返回-1，并设置errno为EAGAINint Utils::setnoblocking(int fd)&#123;    int old_option = fcntl(fd,F_GETFL);    int new_option = old_option | O_NONBLOCK;    fcntl(fd,F_SETFL,new_option);    return old_option;&#125;\n\n这是 Utils 类的设置非阻塞函数 setnonblocking 的实现，用于将指定文件描述符设置为非阻塞模式：\n\n获取旧的文件描述符状态：\n使用 fcntl 函数的 F_GETFL 命令获取文件描述符 fd 的当前状态，并将其保存在变量 old_option 中。\n\n\n设置新的文件描述符状态：\n使用位运算将 O_NONBLOCK 标志加入到 old_option 中，形成新的文件描述符状态 new_option。\n\n\n将新的文件描述符状态应用到文件描述符：\n使用 fcntl 函数的 F_SETFL 命令，将新的文件描述符状态 new_option 应用到文件描述符 fd 上。\n\n\n返回旧的文件描述符状态：\n返回调用该函数之前文件描述符的状态，即返回 old_option。\n\n\n\n向epoll注册事件 addfd// 向epoll注册事件void Utils::addfd(int epollfd, int fd, bool one_shot, int TRIGMode)&#123;    epoll_event event;    event.data.fd = fd;    // ET模式    if(TRIGMode == 1)&#123;        // EPOLLRDHUP 对端关闭        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;    &#125;else&#123;  // 默认LT模式        event.events = EPOLLIN | EPOLLRDHUP;    &#125;    // 只触发一次    if(one_shot)&#123;        event.events |= EPOLLONESHOT;    &#125;    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;event);    // 设置非阻塞    setnoblocking(fd);&#125;\n\n这是 Utils 类的向 epoll 注册事件的函数 addfd 的实现，用于向指定的epoll实例注册事件：\n参数：\n\nepollfd:epoll 实例的文件描述符。\nfd: 要注册的文件描述符。\none_shot: 是否设置为一次性事件。\nTRIGMode: 触发模式，1 表示使用 ET 模式，0 表示使用默认的 LT 模式。\n\n详解：\n\n初始化 epoll_event 结构体：\n创建一个 epoll_event 结构体实例 event，并将要注册的文件描述符 fd 存储在 event.data.fd 中。\n\n\n设置事件类型：\n根据触发模式 TRIGMode 的值设置事件类型，如果为 1（ET 模式），则设置 EPOLLIN、EPOLLET 和 EPOLLRDHUP 事件；否则，默认使用 LT 模式，只设置 EPOLLIN 和 EPOLLRDHUP 事件。\n\n\n设置一次性事件：\n如果 one_shot 为 true，则将 EPOLLONESHOT 标志添加到事件类型中，表示这是一个一次性事件。\n\n\n向 epoll 实例注册事件：\n使用 epoll_ctl 函数向 epoll实例注册事件，将事件添加到事件列表中。\n\n\n设置文件描述符为非阻塞模式：\n调用 setnonblocking 函数将文件描述符 fd 设置为非阻塞模式。\n\n\n\n信号处理函数 sig_handler// 信号处理函数void Utils::sig_handler(int sig)&#123;    // 为保证函数的可重入性，保留原来的errno    // 可重入性表示中断后再次进入该函数，环境变量与之前相同，不会丢失数据    int save_errno = errno;    int msg = sig;    // 将信号从管道写端写入，以字符类型传输    // 回到主循环处理信号业务逻辑    send(u_epollfd[1],(char *)&amp;msg,1,0);    // 恢复errno    errno = save_errno;&#125;\n\n这是 Utils 类中的信号处理函数 sig_handler 的实现，用于处理捕获到的信号：\n参数：\n\nsig: 捕获到的信号。\n\n详解：\n\n保留原始 errno：\n为了保证函数的可重入性，首先保存当前的 errno，以便后续恢复。\n\n\n将信号写入管道：\n将捕获到的信号 sig 通过管道的写端（u_epollfd[1]）写入，以字符类型传输。\n\n\n恢复 errno：\n恢复之前保存的 errno，保证函数的可重入性。\n\n\n\n该函数将捕获到的信号发送到主循环中，通过管道实现了信号的跨线程通信，主循环将会从管道的读端读取到信号，并进行相应的处理逻辑。这种机制常用于处理信号与主程序逻辑的异步通信。\n设置信号 addsig// 设置信号void Utils::addsig(int sig, void (*handler)(int), bool restart)&#123;    // 创建sigaction结构体    struct sigaction sa;    memset(&amp;sa,0,sizeof(sa));    // 设置信号处理函数    sa.sa_handler = handler;    if(restart)&#123;        // 使被信号打断的系统调用重新自动发起        sa.sa_flags |= SA_RESTART;    &#125;    // 对信号集初始化，将所有信号添加到信号集中    sigfillset(&amp;sa.sa_mask);    // 设置信号， -1 表示有错误发生    assert(sigaction(sig,&amp;sa,NULL) != -1);&#125;\n\n这是 Utils 类中的设置信号函数 addsig 的实现，用于设置捕获到的信号的处理函数：\n参数：\n\nsig: 要设置的信号。\nhandler: 信号处理函数的指针。\nrestart: 是否开启对系统调用的自动重启。\n\n详解：\n\n初始化 sigaction 结构体：\n创建 sigaction 结构体并用 memset 初始化。\n\n\n设置信号处理函数：\n将信号处理函数指针设置为传入的 handler。\n\n\n设置自动重启标志（可选）：\n如果 restart 为 true，则设置 SA_RESTART 标志，使被信号打断的系统调用重新自动发起。\n\n\n初始化信号集：\n使用 sigfillset 将所有信号添加到信号集中，以确保在信号处理函数执行期间，所有信号都被阻塞。\n\n\n设置信号处理：\n使用 sigaction 函数将指定信号与设置好的 sigaction 结构体关联起来，实现信号的处理函数设置。\n\n\n\n定时器触发 timer_handler// 定时器触发void Utils::timer_handler()&#123;    // 处理连接链表    m_timer_lst.tick();    // 重新设置时钟    alarm(m_timeslot);&#125;\n\n这是 Utils 类中的定时器处理函数 timer_handler 的实现，用于处理定时器链表中的定时器触发事件，并重新设置时钟：\n\n处理连接链表：\n调用 m_timer_lst.tick() 处理定时器链表中的定时器触发事件。该函数的具体实现逻辑是遍历定时器链表，找到超时的定时器并执行相应的操作。\n\n\n重新设置时钟：\n调用 alarm(m_timeslot) 重新设置时钟，以确保下一次定时器的触发事件。\n\n\n\n该函数的执行流程是在定时器触发时被调用，首先处理定时器链表中的定时器触发事件，然后重新设置时钟，为下一次触发事件做准备。这样可以保证定时器链表中的定时器得到及时处理。\n错误信息显示函数 show_errorvoid Utils::show_error(int connfd, const char *info)&#123;    send(connfd,info,strlen(info),0);    close(connfd);&#125;\n\n这是 Utils 类中的错误信息显示函数 show_error 的实现，用于向指定连接发送错误信息并关闭连接：\n详解：\n\n发送错误信息：\n使用 send 函数向连接（connfd）发送错误信息（info）。strlen(info) 表示发送 info 字符串的长度。\n\n\n关闭连接：\n使用 close 函数关闭连接，确保错误信息发送后连接得到关闭。\n\n\n\n该函数在处理连接过程中出现错误时使用，通过发送错误信息告知连接一些错误详情，并关闭连接以终止与客户端的通信。\n回调函数 cb_funcint *Utils::u_pipefd = 0;int Utils::u_epollfd = 0;// 定时器回调函数，释放客户端连接void cb_func(client_data *user_data)&#123;    // 删除非活动连接在socket上的注册事件    epoll_ctl(Utils::u_epollfd,EPOLL_CTL_DEL,user_data-&gt;sockfd,0);    assert(user_data);    // 关闭socket    close(user_data-&gt;sockfd);    // 减少连接数    &#125;\n\n这是 Utils 类中的回调函数 cb_func 的实现，用于释放客户端连接资源：\n详解：\n\n删除 epoll 注册事件：\n使用 epoll_ctl 函数删除非活动连接在 epoll 上的注册事件。这样，该连接将不再被 epoll 监听。\n\n\n关闭连接 socket：\n使用 close 函数关闭客户端连接的 socket。\n\n\n减少连接数：\n减少连接数，这可能是通过某种计数机制来实现的，具体实现可能在其他部分的代码中。\n\n\n\n该回调函数通常在定时器处理过程中被调用，用于释放非活动连接的资源。\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"从零实现WebServer之HTTP请求类","url":"/2024/01/05/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0WebServer%E4%B9%8BHTTP%E8%AF%B7%E6%B1%82%E7%B1%BB/","content":"从零实现WebServer之HTTP请求类http请求类class http_conn&#123;public:    // 文件名称长度    static const int FILENAME_LEN = 200;    // 读缓冲大小    static const int READ_BUFFER_SIZE = 2048;    // 写缓冲大小    static const int WRITE_BUFFER_SIZE = 1024;    // 请求方法    enum METHOD&#123;        GET = 0, POST, HEAD, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATH    &#125;;    // 主状态机状态    enum CHECK_STATE&#123;        CHECK_STATE_REQUESTLINE = 0,        CHECK_STATE_HEADER,        CHECK_STATE_CONTENT    &#125;;    // 报文解析结果    enum HTTP_CODE&#123;        NO_REQUEST = 0, GET_REQUEST, BAD_REQUEST, NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION    &#125;;    // 从状态机状态    enum LINE_STATUS&#123;        LINE_OK = 0, LINE_BAD, LINE_OPEN    &#125;;public:    http_conn()&#123;&#125;    ~http_conn()&#123;&#125;public:    // 初始化连接    void init(int sockfd, const sockaddr_in &amp;addr, const char *, int, int, string user, string passwd, string sqlname);    // 关闭连接    void close_conn(bool real_close=true);    void process();    // 读取客户端全部数据    bool read_once();    // 写响应报文    bool write();    sockaddr_in* get_address()&#123;        return &amp;m_address;    &#125;    // 初始化数据库读取表    void initmysql_result(connection_pool *connPool);    int timer_flag;     // reactor是否处理数据    int improv;         // reactor是否处理失败private:    void init();    // 从m_read_buf读取，处理请求报文    HTTP_CODE process_read();    // 向m_write_buf写入响应报文    bool process_write(HTTP_CODE ret);    // 主状态机解析请求行数据    HTTP_CODE parse_request_line(char *text);    // 主状态机解析请求头数据    HTTP_CODE parse_headers(char *text);    // 主状态机解析请求内容    HTTP_CODE parse_content(char *text);    // 生成响应报文    HTTP_CODE do_request();    // 获得未解读数据位置    //m_start_line是行在buffer中的起始位置，将该位置后面的数据赋给text    //此时从状态机已提前将一行的末尾字符\\r\\n变为\\0\\0，所以text可以直接取出完整的行进行解析    char* get_line()&#123;return m_read_buf + m_start_line;&#125;;    // 从状态机读取一行    LINE_STATUS parse_line();    void unmap();    // 生成具体响应报文    bool add_response(const char *format, ...);    bool add_content(const char *content);    bool add_status_line(int status, const char *title);    bool add_headers(int content_length);    bool add_content_type();    bool add_content_length(int content_length);    bool add_linger();    bool add_blank_line();public:    static int m_epollfd;       // epoll事件表    static int m_user_count;    // 客户数量    MYSQL *mysql;               // 数据库连接    int m_state;                // reactor区分读写任务，0读，1写private:    int m_sockfd;               // 客户socket    sockaddr_in m_address;      // 客户地址    char m_read_buf[READ_BUFFER_SIZE];    int m_read_idx;             // 已读数据结尾    int m_checked_idx;          // 解析进行处    int m_start_line;           // 解析开始处    char m_write_buf[WRITE_BUFFER_SIZE];    int m_write_idx;            // 已写数据结尾    CHECK_STATE m_check_state;  // 主状态机状态    METHOD m_method;            // 请求方法    // 解析请求报文变量    char m_real_file[FILENAME_LEN]; // 实际文件路径    char *m_url;    char *m_version;    char *m_host;    int m_content_length;    bool m_linger;          // 是否为长连接    char *m_file_address;   // 服务器上文件指针    struct stat m_file_stat;// 文件信息结构体    struct iovec m_iv[2];   // 向量元素    int m_iv_count;         // 向量元素个数    int cgi;                // 是否启用POST    char *m_string;    uint32_t bytes_to_send;      // 剩余发送字节    uint32_t bytes_have_send;    // 已发送字节    const char *doc_root;        // 资源根目录    map&lt;string, string&gt; m_users;    // 用户表    int m_TRIGMode;         // ET模式    int m_close_log;        // 是否关闭日志    char sql_user[100];     // 数据库用户名    char sql_passwd[100];   // 数据库密码    char sql_name[100];     // 数据库名&#125;;#endif\n\n主要成员变量和枚举：\n\nFILENAME_LEN：文件名长度常量，设为200。\nREAD_BUFFER_SIZE：读缓冲大小常量，设为2048。\nWRITE_BUFFER_SIZE：写缓冲大小常量，设为1024。\nMETHOD：枚举类型，表示HTTP请求方法，包括GET、POST等。\nCHECK_STATE：枚举类型，表示主状态机的三个可能状态：解析请求行、解析请求头、解析请求内容。\nHTTP_CODE：枚举类型，表示报文解析结果，包括无请求、GET请求、错误请求等。\nLINE_STATUS：枚举类型，表示从状态机的三个可能状态：行正常、行错误、行未完成。\n\n主要成员函数：\n\ninit：初始化连接。\nclose_conn：关闭连接。\nprocess：处理HTTP请求。\nread_once：一次性读取客户端全部数据。\nwrite：写响应报文。\nget_address：获取客户端地址。\ninitmysql_result：初始化数据库读取表。\nparse_request_line：解析请求行数据。\nparse_headers：解析请求头数据。\nparse_content：解析请求内容。\ndo_request：生成响应报文。\nget_line：获得未解读数据位置。\nparse_line：从状态机读取一行。\nunmap：解除映射关系。\nadd_response：生成具体响应报文。\nadd_content：添加响应内容。\nadd_status_line：添加响应状态行。\nadd_headers：添加响应头。\nadd_content_type：添加响应内容类型。\nadd_content_length：添加响应内容长度。\nadd_linger：添加连接状态。\nadd_blank_line：添加空行。\n\n静态成员：\n\nm_epollfd：epoll事件表。\nm_user_count：客户数量。\n\n获取用户表数据 initmysql_result这段代码是在初始化阶段从MySQL数据库中获取用户表数据，并将用户名和密码存储在内存中的map&lt;string, string&gt; users中。同时，使用了mutexlocker进行表的互斥锁操作，确保在多线程环境下对用户表的访问是安全的。\nmutexlocker m_lock;         // 表互斥锁map&lt;string, string&gt; users;  // 内存用户表void http_conn::initmysql_result(connection_pool *connPool)&#123;    // 从数据库连接池取一个连接    MYSQL *mysql = nullptr;    connectionRAII mysqlcon(&amp;mysql, connPool);    // 在user表中检索    if(mysql_query(mysql, &quot;SELECT username, password FROM user&quot;))&#123;        LOG_ERROR(&quot;SELECT error:%s\\n&quot;, mysql_error(mysql));    &#125;    // 从表中检索完整的结果集    MYSQL_RES *result = mysql_store_result(mysql);    // 结果集的列数    // int num_fields = mysql_num_fields(result);    // 所有字段结构的数组    // MYSQL_FIELD *fields = mysql_fetch_field(result);    // 将用户名和密码存入map中    while(MYSQL_ROW row = mysql_fetch_row(result))&#123;        string temp1(row[0]);        string temp2(row[1]);        users[temp1] = temp2;    &#125;&#125;mutexlocker m_lock;         // 表互斥锁map&lt;string, string&gt; users;  // 内存用户表void http_conn::initmysql_result(connection_pool *connPool)&#123;    // 从数据库连接池取一个连接    MYSQL *mysql = nullptr;    connectionRAII mysqlcon(&amp;mysql, connPool);    // 在user表中检索    if(mysql_query(mysql, &quot;SELECT username, password FROM user&quot;))&#123;        LOG_ERROR(&quot;SELECT error:%s\\n&quot;, mysql_error(mysql));    &#125;    // 从表中检索完整的结果集    MYSQL_RES *result = mysql_store_result(mysql);    // 结果集的列数    // int num_fields = mysql_num_fields(result);    // 所有字段结构的数组    // MYSQL_FIELD *fields = mysql_fetch_field(result);    // 将用户名和密码存入map中    while(MYSQL_ROW row = mysql_fetch_row(result))&#123;        string temp1(row[0]);        string temp2(row[1]);        users[temp1] = temp2;    &#125;&#125;\n\n\nmutexlocker m_lock;：定义了一个名为m_lock的mutexlocker对象，用于在多线程环境中对用户表进行互斥操作。\nmap&lt;string, string&gt; users;：定义了一个名为users的map，用于存储从数据库中读取的用户名和密码。\nvoid http_conn::initmysql_result(connection_pool *connPool)：这是http_conn类的成员函数，用于从MySQL数据库中获取用户表数据。\nconnectionRAII mysqlcon(&amp;mysql, connPool);：创建了一个connectionRAII对象，通过该对象获取了一个数据库连接。\nif(mysql_query(mysql, &quot;SELECT username, password FROM user&quot;))：执行了一个SQL查询语句，从user表中选择用户名和密码。\nMYSQL_RES *result = mysql_store_result(mysql);：将查询结果存储在result中。\nwhile(MYSQL_ROW row = mysql_fetch_row(result))：遍历查询结果的每一行，将用户名和密码存入map&lt;string, string&gt; users中。\n\n\n\n在这个过程中，由于涉及到对共享数据的读写操作，使用了互斥锁来确保线程安全。这是因为在多线程环境中，多个线程可能同时访问和修改users表，为了防止数据不一致和竞争条件，使用互斥锁是一种常见的做法。\n设置非阻塞 setnonblocking这段代码定义了一个函数setnonblocking，用于将给定的文件描述符设置为非阻塞模式。\n// 对文件描述符设置非阻塞int setnonblocking(int fd)&#123;    int old_option = fcntl(fd, F_GETFL);    int new_option = old_option | O_NONBLOCK;    fcntl(fd, F_SETFL, new_option);    return old_option;&#125;\n\n\nint setnonblocking(int fd)：这是一个函数，接受一个文件描述符fd作为参数，返回一个整数值。\nint old_option = fcntl(fd, F_GETFL);：使用fcntl系统调用获取当前文件描述符fd的文件状态标志。\nint new_option = old_option | O_NONBLOCK;：将O_NONBLOCK标志与原有的文件状态标志进行按位或操作，设置文件描述符为非阻塞模式。\nfcntl(fd, F_SETFL, new_option);：使用fcntl系统调用将新的文件状态标志设置回文件描述符，使文件描述符变为非阻塞模式。\nreturn old_option;：返回原有的文件状态标志，方便之后需要的情况下恢复文件描述符的状态。\n\n这种设置非阻塞模式的操作通常用于套接字和其他I&#x2F;O操作，以便在进行读写时不会被阻塞，能够更好地适应异步I&#x2F;O的编程模型。\n注册读事件 addfd这段代码定义了一个函数addfd，用于向内核事件表注册文件描述符的读事件。在ET（边缘触发）模式下，可以选择开启EPOLLONESHOT标志，表示这个文件描述符只能被一个线程处理一次。\n// 将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOTvoid addfd(int epollfd, int fd, bool one_shot, int TRIGMode)&#123;    epoll_event event;    event.data.fd = fd;    if(TRIGMode == 1)        // 读事件、ET模式、对方断开连接        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;    else        event.events = EPOLLIN | EPOLLRDHUP;    if(one_shot)        event.events |= EPOLLONESHOT;    // 注册事件    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);    setnonblocking(fd);&#125;\n\n\nvoid addfd(int epollfd, int fd, bool one_shot, int TRIGMode)：这是一个函数，接受四个参数，分别是epollfd（内核事件表的文件描述符）、fd（要注册的文件描述符）、one_shot（是否开启EPOLLONESHOT标志）、TRIGMode（触发模式，这里使用了一个TRIGMode参数，值为1表示使用ET模式）。\n\nepoll_event event;：创建一个epoll_event结构体对象，用于描述事件。\n\nevent.data.fd = fd;：设置event结构体中的文件描述符字段。\n\nif(TRIGMode == 1)：判断是否使用ET模式，如果是，设置事件为EPOLLIN（可读事件）、EPOLLET（边缘触发）、EPOLLRDHUP（对方断开连接）。\n如果不是ET模式，仅设置事件为EPOLLIN和EPOLLRDHUP。\n\nif(one_shot)：判断是否开启EPOLLONESHOT标志，如果是，将event结构体中的事件字段加上EPOLLONESHOT。\n\nepoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);：将文件描述符fd添加到内核事件表中，并指定对应的事件。\n\nsetnonblocking(fd);：调用之前定义的setnonblocking函数，将文件描述符设置为非阻塞模式。\n\n\n这个函数的目的是将文件描述符注册到内核事件表中，以便后续可以通过epoll来监听这个文件描述符的事件。在ET模式下，EPOLLONESHOT标志的使用表明了一次触发的事件只会被一个线程处理一次，需要重新注册。\n删除描述符 removefd这段代码定义了一个函数removefd，用于从内核事件表中删除文件描述符，并关闭该文件描述符。\n// 从内核事件表删除描述符，关闭描述符void removefd(int epollfd, int fd)&#123;    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0);    close(fd);&#125;\n\n\nvoid removefd(int epollfd, int fd)：这是一个函数，接受两个参数，分别是epollfd（内核事件表的文件描述符）和fd（要删除的文件描述符）。\nepoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0);：调用epoll_ctl系统调用，从内核事件表中删除文件描述符fd。\nclose(fd);：关闭文件描述符，释放相应的资源。\n\n这个函数的目的是在某些情况下，例如文件描述符对应的连接已经关闭，需要从内核事件表中移除该文件描述符，并释放相关资源，以防止不必要的事件触发。\n重置 modfd这段代码定义了一个函数modfd，用于修改已注册在内核事件表中的文件描述符的事件，将其重置为EPOLLONESHOT。这个操作通常在使用边缘触发（ET）模式时，表示一次事件只触发一次，需要重新注册。\n// 将事件重置为EPOLLONESHOTvoid modfd(int epollfd, int fd, int ev, int TRIGMode)&#123;    epoll_event event;    event.data.fd = fd;    if(TRIGMode == 1)        event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;    else        event.events = ev | EPOLLONESHOT | EPOLLRDHUP;    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);&#125;\n\n\nvoid modfd(int epollfd, int fd, int ev, int TRIGMode)：这是一个函数，接受四个参数，分别是epollfd（内核事件表的文件描述符）、fd（要修改的文件描述符）、ev（新的事件）、TRIGMode（触发模式，这里使用了一个TRIGMode参数，值为1表示使用ET模式）。\n\nepoll_event event;：创建一个epoll_event结构体对象，用于描述事件。\n\nevent.data.fd = fd;：设置event结构体中的文件描述符字段。\n\nif(TRIGMode == 1)：判断是否使用ET模式，如果是，设置事件为传入的ev，并加上EPOLLET（边缘触发）、EPOLLONESHOT（一次触发一次）和EPOLLRDHUP（对方断开连接）标志。\n如果不是ET模式，设置事件为传入的ev，并加上EPOLLONESHOT和EPOLLRDHUP标志。\n\nepoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);：调用epoll_ctl系统调用，将修改后的事件重新注册到内核事件表中。\n\n\n这个函数的目的是在某些情况下，例如需要重新监听的事件，将已注册的文件描述符重新设置为EPOLLONESHOT，以确保下一次事件触发时需要重新注册。\n关闭一个客户连接 close_conn这部分代码是http_conn类的成员函数close_conn的实现。主要功能是关闭一个客户连接，并在需要真正关闭时，从内核事件表中移除相应的文件描述符，同时更新类的静态成员m_user_count，表示当前的客户数量。\nint http_conn::m_user_count = 0;int http_conn::m_epollfd = -1;// 关闭一个客户连接void http_conn::close_conn(bool real_close)&#123;    if(real_close &amp;&amp; (m_sockfd != -1))&#123;        printf(&quot;close %d\\n&quot;, m_sockfd);        removefd(m_epollfd, m_sockfd);        m_sockfd = -1;        m_user_count--;    &#125;&#125;\n\n\nvoid http_conn::close_conn(bool real_close)：这是一个成员函数，接受一个布尔参数real_close，表示是否真正关闭连接。\nif(real_close &amp;&amp; (m_sockfd != -1))：判断是否真正关闭连接，并且确保m_sockfd不为-1。如果条件成立，执行以下操作：\nprintf(&quot;close %d\\n&quot;, m_sockfd);：打印关闭的客户端的文件描述符。\nremovefd(m_epollfd, m_sockfd);：调用之前定义的removefd函数，从内核事件表中删除该文件描述符，同时关闭文件描述符。\nm_sockfd = -1;：将类的成员变量m_sockfd设置为-1，表示连接已关闭。\nm_user_count--;：减少静态成员m_user_count，表示当前的客户数量减少了一个。\n\n\n\n这个函数的主要作用是关闭客户连接，释放相关资源，并更新当前客户数量。在一些情况下，可能需要保持文件描述符在内核事件表中注册，待后续操作。但在这里，采取了一次性关闭文件描述符并从内核事件表中移除的方式。\n初始化新接受的连接 init这段代码是http_conn类的成员函数init的实现，用于初始化新接受的连接。\n// 初始化新接受的连接void http_conn::init()&#123;    mysql = nullptr;    bytes_to_send = 0;    bytes_have_send = 0;    m_check_state = CHECK_STATE_REQUESTLINE;    m_linger = false;    m_method = GET;    m_url = 0;    m_version = 0;    m_host = 0;    m_start_line = 0;    m_checked_idx = 0;    m_read_idx = 0;    m_write_idx = 0;    cgi = 0;    m_state = 0;    timer_flag = 0;    improv = 0;    memset(m_read_buf, 0, READ_BUFFER_SIZE);    memset(m_write_buf, 0, WRITE_BUFFER_SIZE);    memset(m_real_file, 0, FILENAME_LEN);&#125;\n\n\nmysql = nullptr;：将mysql指针设置为nullptr，表示暂时没有数据库连接。\nbytes_to_send = 0;：将bytes_to_send设置为0，表示待发送的字节数为0。\nbytes_have_send = 0;：将bytes_have_send设置为0，表示已发送的字节数为0。\nm_check_state = CHECK_STATE_REQUESTLINE;：将主状态机状态设置为CHECK_STATE_REQUESTLINE，表示正在解析请求行。\nm_linger = false;：将m_linger设置为false，表示不使用长连接。\nm_method = GET;：将请求方法设置为GET。\nm_url = 0;、m_version = 0;、m_host = 0;：将与请求相关的指针设置为0，表示未初始化。\nm_start_line = 0;：将解析开始位置设置为0。\nm_checked_idx = 0;：将解析进行位置设置为0。\nm_read_idx = 0;：将已读数据结尾位置设置为0。\nm_write_idx = 0;：将已写数据结尾位置设置为0。\ncgi = 0;：将CGI标志设置为0。\nm_state = 0;：将Reactor区分读写任务的标志设置为0，表示当前状态为读。\ntimer_flag = 0;：将timer_flag设置为0，表示Reactor是否处理数据。\nimprov = 0;：将improv设置为0，表示Reactor是否处理失败。\nmemset(m_read_buf, 0, READ_BUFFER_SIZE);：使用memset函数将m_read_buf数组中的所有元素设置为0。\nmemset(m_write_buf, 0, WRITE_BUFFER_SIZE);：使用memset函数将m_write_buf数组中的所有元素设置为0。\nmemset(m_real_file, 0, FILENAME_LEN);：使用memset函数将m_real_file数组中的所有元素设置为0。\n\n这个函数的作用是将http_conn类的各个成员变量重置为初始状态，以便处理新接受的连接。\n初始化连接 init这段代码是http_conn类的成员函数init的另一种实现，用于初始化连接。该函数接受多个参数，包括套接字描述符（sockfd）、客户端地址信息（addr）、根目录（root）、触发模式（TRIGMode）、是否关闭日志（close_log）、数据库用户名（user）、数据库密码（passwd）以及数据库名（sqlname）。\n// 初始化连接void http_conn::init(int sockfd, const sockaddr_in &amp;addr, const char *root, int TRIGMode,                      int close_log, string user, string passwd, string sqlname)&#123;    m_sockfd = sockfd;    m_address = addr;    addfd(m_epollfd, sockfd, true, m_TRIGMode);    m_user_count++;    doc_root = root;    m_TRIGMode = TRIGMode;    m_close_log = close_log;    strcpy(sql_user, user.c_str());    strcpy(sql_passwd, passwd.c_str());    strcpy(sql_name, sqlname.c_str());    init();&#125;\n\n\nm_sockfd = sockfd;：将成员变量m_sockfd设置为传入的套接字描述符。\nm_address = addr;：将成员变量m_address设置为传入的客户端地址信息。\naddfd(m_epollfd, sockfd, true, m_TRIGMode);：调用之前定义的addfd函数，将套接字描述符注册到内核事件表中，同时设置EPOLLONESHOT标志。\nm_user_count++;：增加静态成员变量m_user_count，表示当前的客户数量增加了一个。\ndoc_root = root;：将成员变量doc_root设置为传入的根目录。\nm_TRIGMode = TRIGMode;：将成员变量m_TRIGMode设置为传入的触发模式。\nm_close_log = close_log;：将成员变量m_close_log设置为传入的是否关闭日志标志。\nstrcpy(sql_user, user.c_str());、strcpy(sql_passwd, passwd.c_str());、strcpy(sql_name, sqlname.c_str());：将数据库用户名、密码和数据库名拷贝到相应的成员变量中。\ninit();：调用之前定义的init函数，将http_conn类的各个成员变量重置为初始状态。\n\n这个函数的作用是初始化http_conn类的连接信息，包括套接字描述符、地址信息、根目录、触发模式等，并将连接注册到内核事件表中。\n分析一行内容 parse_line这段代码是http_conn类的成员函数parse_line的实现，用于从状态机中分析一行内容。\n// 从状态机，用于分析一行内容http_conn::LINE_STATUS http_conn::parse_line()&#123;    char temp;    //m_read_idx指向缓冲区m_read_buf的数据末尾的下一个字节    //m_checked_idx指向从状态机当前正在分析的字节    for(; m_checked_idx &lt; m_read_idx; ++m_checked_idx)&#123;        temp = m_read_buf[m_checked_idx];        // 可能读取到完整行        if(temp == &#x27;\\r&#x27;)&#123;            // 不完整            if((m_checked_idx + 1) == m_read_idx)&#123;                return LINE_OPEN;            &#125;            // 完整，\\r\\n替换为\\0\\0            else if(m_read_buf[m_checked_idx + 1] == &#x27;\\n&#x27;)&#123;                m_read_buf[m_checked_idx++] = &#x27;\\0&#x27;;                m_read_buf[m_checked_idx++] = &#x27;\\0&#x27;;                return LINE_OK;            &#125;            // 格式错误            return LINE_BAD;        &#125;        // 可能读取到完整行        else if(temp == &#x27;\\n&#x27;)&#123;            // 完整，\\r\\n替换为\\0\\0            if(m_checked_idx &gt; 1 &amp;&amp; m_read_buf[m_checked_idx - 1] == &#x27;\\r&#x27;)&#123;                m_read_buf[m_checked_idx - 1] = &#x27;\\0&#x27;;                m_read_buf[m_checked_idx++] = &#x27;\\0&#x27;;                return LINE_OK;            &#125;            return LINE_BAD;        &#125;    &#125;    // 继续接收    return LINE_OPEN;&#125;\n\n\nchar temp;：定义一个临时变量temp，用于存储当前分析的字符。\nfor(; m_checked_idx &lt; m_read_idx; ++m_checked_idx)：循环遍历已经读取的数据缓冲区m_read_buf中的内容，从m_checked_idx开始，直到当前已读取的数据结尾m_read_idx。\ntemp = m_read_buf[m_checked_idx];：获取当前分析的字符。\nif(temp == &#39;\\r&#39;)：判断当前字符是否为回车符（\\r），如果是，表示可能读取到了一行。\nif((m_checked_idx + 1) == m_read_idx)：如果回车符后面没有字符了，表示不完整的行，返回LINE_OPEN，继续接收数据。\nelse if(m_read_buf[m_checked_idx + 1] == &#39;\\n&#39;)：如果回车符后面是换行符（\\n），表示读取到了完整的一行，将\\r\\n替换为\\0\\0，并返回LINE_OK。\nelse：如果回车符后面不是换行符，表示行格式错误，返回LINE_BAD。\n\n\nelse if(temp == &#39;\\n&#39;)：如果当前字符是换行符（\\n），表示可能读取到了一行。\nif(m_checked_idx &gt; 1 &amp;&amp; m_read_buf[m_checked_idx - 1] == &#39;\\r&#39;)：如果换行符前面是回车符，表示读取到了完整的一行，将\\r\\n替换为\\0\\0，并返回LINE_OK。\nelse：如果换行符前面不是回车符，表示行格式错误，返回LINE_BAD。\n\n\n如果以上条件都不满足，继续循环，继续接收数据，返回LINE_OPEN。\n\n这个函数的主要目的是在已接收的数据中分析一行内容，判断是否读取到了完整的一行，并进行相应的处理。\n循环读取客户数据 read_once这段代码是http_conn类的成员函数read_once的实现，用于循环读取客户端数据，直到无数据可读或对方关闭连接。\n// 循环读取客户数据，直到无数据可读或对方关闭连接bool http_conn::read_once()&#123;    if(m_read_idx &gt;= READ_BUFFER_SIZE)&#123;        return false;    &#125;    int bytes_read = 0;    // LT模式    if(m_TRIGMode == 0)&#123;        // 读取数据到缓冲区        bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, 0);        m_read_idx += bytes_read;        if(bytes_read &lt;= 0)&#123;            return false;        &#125;        return true;    &#125;    // ET模式    else&#123;        while(true)&#123;            bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, 0);            // 无数据可读            if(bytes_read == -1)&#123;                // 非阻塞、连接正常                if(errno == EAGAIN || errno == EWOULDBLOCK)                    break;                return false;            &#125;            // 另一端已关闭            else if(bytes_read == 0)&#123;                return false;            &#125;            m_read_idx += bytes_read;        &#125;        return true;    &#125;&#125;\n\n\nif(m_read_idx &gt;= READ_BUFFER_SIZE)：判断当前已读取的数据是否已经达到缓冲区的最大容量，如果是，返回false，表示缓冲区已满，无法再读取更多数据。\nint bytes_read = 0;：定义一个变量bytes_read，用于存储每次读取的字节数。\nif(m_TRIGMode == 0)：如果是LT模式（level-triggered模式）。\nbytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, 0);：调用recv函数从套接字中读取数据到缓冲区中。\nm_read_idx += bytes_read;：更新已读取的数据结尾位置。\nif(bytes_read &lt;= 0)：如果读取的字节数小于等于0，表示对方关闭了连接或发生了错误，返回false。\n返回true，表示读取数据成功。\n\n\nelse：如果是ET模式（edge-triggered模式）。\nwhile(true)：进入无限循环，持续读取数据。\nbytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, 0);：调用recv函数从套接字中读取数据到缓冲区中。\nif(bytes_read == -1)：如果读取的字节数为-1，表示无数据可读。\nif(errno == EAGAIN || errno == EWOULDBLOCK)：如果是非阻塞模式，并且连接正常，退出循环，表示当前没有更多数据可读。\nbreak;\n\n\n返回false，表示发生了错误或对方关闭了连接。\n\n\nelse if(bytes_read == 0)：如果读取的字节数为0，表示对方已关闭了连接，返回false。\nm_read_idx += bytes_read;：更新已读取的数据结尾位置。\n\n\n返回true，表示读取数据成功。\n\n\n\n这个函数的主要目的是在LT或ET模式下，从套接字中循环读取数据，直到无数据可读或对方关闭连接。在ET模式下，通过循环读取保证将所有的可读数据都读取出来。\n解析HTTP请求行 parse_request_line这段代码是http_conn类的成员函数parse_request_line的实现，用于解析HTTP请求行，获取请求方法、目标URL及HTTP版本号。\n// 解析HTTP请求行，获得请求方法、目标url及http版本号http_conn::HTTP_CODE http_conn::parse_request_line(char *text)&#123;    // 寻找空格和\\t位置    m_url = strpbrk(text, &quot; \\t&quot;);    if(!m_url)&#123;        return BAD_REQUEST;    &#125;    // 将该位置改为\\0，方便取出    *m_url++ = &#x27;\\0&#x27;;    // 取出请求方法并比较    char *method = text;    if(strcasecmp(method, &quot;GET&quot;) == 0)        m_method = GET;    else if(strcasecmp(method, &quot;POST&quot;) == 0)&#123;        m_method = POST;        cgi = 1;    &#125;    else return BAD_REQUEST;    // 跳过空格和\\t    m_url += strspn(m_url, &quot; \\t&quot;);    // 再寻找空格和\\t    m_version = strpbrk(m_url, &quot; \\t&quot;);    if(!m_version)        return BAD_REQUEST;    *m_version++ = &#x27;\\0&#x27;;    // 跳过空格和\\t    m_version += strspn(m_version, &quot; \\t&quot;);    // 仅支持HTTP1.1    if(strcasecmp(m_version, &quot;HTTP/1.1&quot;) != 0)        return BAD_REQUEST;    // 去除http://    if(strncasecmp(m_url, &quot;http://&quot;, 7) == 0)&#123;        m_url += 7;        m_url = strchr(m_url, &#x27;/&#x27;);    &#125;    // 去除https://    if(strncasecmp(m_url, &quot;https://&quot;, 8) == 0)&#123;        m_url += 8;        m_url = strchr(m_url, &#x27;/&#x27;);    &#125;    if(!m_url || m_url[0] != &#x27;/&#x27;)        return BAD_REQUEST;    // url为/，显示主页    if(strlen(m_url) == 1)        strcat(m_url, &quot;judge.html&quot;);    // 主状态机状态修改为处理请求头    m_check_state = CHECK_STATE_HEADER;    return NO_REQUEST;&#125;\n\n\nm_url = strpbrk(text, &quot; \\t&quot;);：在请求行中寻找空格和制表符的位置，返回第一个匹配的位置，赋值给m_url。如果没有找到，返回BAD_REQUEST，表示请求行格式错误。\nif(!m_url)：如果m_url为空，返回BAD_REQUEST，表示请求行格式错误。\n*m_url++ = &#39;\\0&#39;;：将m_url指向的位置改为\\0，即将请求方法和URL分隔开。\nchar *method = text;：将method指针指向请求行的开始位置，即请求方法的起始位置。\nif(strcasecmp(method, &quot;GET&quot;) == 0)：比较请求方法是否为”GET”，如果是，将m_method设置为GET；否则，如果是”POST”，将m_method设置为POST，并设置cgi标志为1（表示启用CGI）；否则，返回BAD_REQUEST，表示请求方法不支持。\nm_url += strspn(m_url, &quot; \\t&quot;);：跳过空格和制表符，将m_url指向下一个非空白字符。\nm_version = strpbrk(m_url, &quot; \\t&quot;);：在新的位置继续寻找空格和制表符的位置，返回第一个匹配的位置，赋值给m_version。如果没有找到，返回BAD_REQUEST，表示请求行格式错误。\nif(!m_version)：如果m_version为空，返回BAD_REQUEST，表示请求行格式错误。\n*m_version++ = &#39;\\0&#39;;：将m_version指向的位置改为\\0，即将URL和HTTP版本号分隔开。\nm_version += strspn(m_version, &quot; \\t&quot;);：跳过空格和制表符，将m_version指向下一个非空白字符。\nif(strcasecmp(m_version, &quot;HTTP/1.1&quot;) != 0)：比较HTTP版本号是否为”HTTP&#x2F;1.1”，如果不是，返回BAD_REQUEST，表示不支持的HTTP版本。\nif(strncasecmp(m_url, &quot;http://&quot;, 7) == 0)：如果URL以”http:&#x2F;&#x2F;“开头，去除该部分。\nif(strncasecmp(m_url, &quot;https://&quot;, 8) == 0)：如果URL以”https:&#x2F;&#x2F;“开头，去除该部分。\nif(!m_url || m_url[0] != &#39;/&#39;)：如果URL为空或者不以’&#x2F;‘开头，返回BAD_REQUEST，表示请求行格式错误。\nif(strlen(m_url) == 1)：如果URL长度为1，表示只有’&#x2F;‘，将其拼接为”judge.html”，作为默认的主页。\nm_check_state = CHECK_STATE_HEADER;：将主状态机状态修改为处理请求头。\nreturn NO_REQUEST;：返回NO_REQUEST，表示成功解析请求行。\n\n这个函数的主要目的是解析HTTP请求行，获取请求方法、目标URL及HTTP版本号，并进行相应的处理。\n解析HTTP请求头 parse_headers这段代码是http_conn类的成员函数parse_headers的实现，用于解析HTTP请求的一个头部信息。\n// 解析HTTP请求的一个头部信息http_conn::HTTP_CODE http_conn::parse_headers(char *text)&#123;    // 首位为\\0是空行    if(text[0] == &#x27;\\0&#x27;)&#123;        if(m_content_length != 0)&#123;            // POST继续解析消息体            m_check_state = CHECK_STATE_CONTENT;            return NO_REQUEST;        &#125;        // GET请求解析完成        return GET_REQUEST;    &#125;    // 连接字段    else if(strncasecmp(text, &quot;connection:&quot;, 11) == 0)&#123;        text += 11;        text += strspn(text, &quot; \\t&quot;);        if(strcasecmp(text, &quot;keep-alive&quot;) == 0)&#123;            // 长连接            m_linger = true;        &#125;    &#125;    // 内容长度字段    else if(strncasecmp(text, &quot;Content-length:&quot;, 15) == 0)&#123;        text += 15;        text += strspn(text, &quot;\\t&quot;);        m_content_length = atol(text);    &#125;    // Host字段，请求站点    else if(strncasecmp(text, &quot;Host:&quot;, 5) == 0)&#123;        text += 5;        text += strspn(text, &quot; \\t&quot;);        m_host = text;    &#125;    else&#123;        LOG_INFO(&quot;oop! unknow header: %s&quot;, text);    &#125;    return NO_REQUEST;&#125;\n\n\nif(text[0] == &#39;\\0&#39;)：判断头部信息的首位是否为\\0，如果是，表示空行，说明当前请求的头部信息解析完成。\nif(m_content_length != 0)：如果请求方法是POST且有消息体，将主状态机状态修改为处理请求体，返回NO_REQUEST。\n否则，表示GET请求头部解析完成，返回GET_REQUEST。\n\n\nelse if(strncasecmp(text, &quot;connection:&quot;, 11) == 0)：如果头部字段以”Connection:”开头，表示连接字段。\ntext += 11;：跳过”Connection:”部分。\ntext += strspn(text, &quot; \\t&quot;);：跳过空格和制表符，指向字段值的开始。\nif(strcasecmp(text, &quot;keep-alive&quot;) == 0)：如果字段值为”keep-alive”，表示使用长连接，将m_linger标志设置为true。\n\n\nelse if(strncasecmp(text, &quot;Content-length:&quot;, 15) == 0)：如果头部字段以”Content-length:”开头，表示内容长度字段。\ntext += 15;：跳过”Content-length:”部分。\ntext += strspn(text, &quot;\\t&quot;);：跳过制表符，指向字段值的开始。\nm_content_length = atol(text);：将字段值转换为长整型，表示消息体的长度。\n\n\nelse if(strncasecmp(text, &quot;Host:&quot;, 5) == 0)：如果头部字段以”Host:”开头，表示Host字段，即请求的站点。\ntext += 5;：跳过”Host:”部分。\ntext += strspn(text, &quot; \\t&quot;);：跳过空格和制表符，指向字段值的开始。\nm_host = text;：将m_host指针指向Host字段的值，即请求的站点。\n\n\nelse：如果是其他未知的头部字段，输出日志记录。\n返回NO_REQUEST，表示继续解析后续的头部信息。\n\n这个函数的主要目的是解析HTTP请求的一个头部信息，包括连接字段、内容长度字段和Host字段。在解析过程中，如果发现空行，表示当前请求的头部信息解析完成，根据情况进行处理。\n判断HTTP请求是否被完全读入 parse_content这段代码是http_conn类的成员函数parse_content的实现，用于判断HTTP请求是否已经完全读入消息体。\n// 判断HTTP请求是否被完全读入http_conn::HTTP_CODE http_conn::parse_content(char *text)&#123;    // 判断buffer中是否读取了消息体    if(m_read_idx &gt;= (m_content_length + m_checked_idx))&#123;        // 最后填充\\0        text[m_content_length] = &#x27;\\0&#x27;;        // 获取消息体        m_string = text;        return GET_REQUEST;    &#125;    return NO_REQUEST;&#125;\n\n\nif(m_read_idx &gt;= (m_content_length + m_checked_idx))：判断当前已读取的数据长度是否大于等于消息体长度加上已解析的数据位置。\ntext[m_content_length] = &#39;\\0&#39;;：在消息体结束位置填充\\0，将消息体转换为以\\0结尾的字符串。\nm_string = text;：将m_string指针指向消息体的起始位置，即请求体的内容。\n返回GET_REQUEST，表示HTTP请求的消息体已经完全读入。\n\n\n返回NO_REQUEST，表示HTTP请求的消息体还未完全读入，需要继续读取。\n\n处理接收到的HTTP请求数据 process_read这段代码是http_conn类的成员函数process_read的实现，用于处理接收到的HTTP请求数据。\nhttp_conn::HTTP_CODE http_conn::process_read()&#123;    // 初始化状态    LINE_STATUS line_status = LINE_OK;    HTTP_CODE ret = NO_REQUEST;    char *text = nullptr;    // 消息体末尾没有字符，POST请求报文不能用从状态机LINE_OK状态判断    // 加上&amp;&amp; line_status == LINE_OK防止陷入死循环    while((m_check_state == CHECK_STATE_CONTENT &amp;&amp; line_status == LINE_OK) || ((line_status = parse_line()) == LINE_OK))&#123;        // 取一行数据        text = get_line();        m_start_line = m_checked_idx;        LOG_INFO(&quot;get line: %s&quot;, text);        // 主状态机状态        switch (m_check_state)&#123;            case CHECK_STATE_REQUESTLINE:&#123;                ret = parse_request_line(text);                if(ret == BAD_REQUEST)                    return BAD_REQUEST;                break;            &#125;            case CHECK_STATE_HEADER:&#123;                ret = parse_headers(text);                if(ret == BAD_REQUEST)                    return BAD_REQUEST;                // 完整解析GET请求                else if(ret == GET_REQUEST)                    return do_request();                break;            &#125;            case CHECK_STATE_CONTENT:&#123;                ret = parse_content(text);                // 完整解析POST请求                if(ret == GET_REQUEST)                    return do_request();                // 完成报文解析，防止进入循环                line_status = LINE_OPEN;                break;            &#125;            default:                return INTERNAL_ERROR;        &#125;    &#125;    return NO_REQUEST;&#125;\n\n\nLINE_STATUS line_status = LINE_OK;：初始化行状态为LINE_OK，表示当前行的状态正常。\n\nHTTP_CODE ret = NO_REQUEST;：初始化HTTP处理状态为NO_REQUEST，表示当前没有完整的HTTP请求。\n\nchar *text = nullptr;：初始化字符指针text为空指针。\n\nwhile((m_check_state == CHECK_STATE_CONTENT &amp;&amp; line_status == LINE_OK) || ((line_status = parse_line()) == LINE_OK))\n：循环条件，如果当前主状态机状态是解析消息体并且当前行状态是OK，或者解析行的状态是OK，则进入循环。- `text = get_line();`：获取一行数据，`get_line()`函数返回指向当前行的指针，并将`m_start_line`设置为当前解析位置。- `m_start_line = m_checked_idx;`：更新解析起始位置。- `LOG_INFO(&quot;get line: %s&quot;, text);`：记录日志，输出获取的行数据。- ```  switch (m_check_state)&#123;\n\n  ：根据主状态机的状态进行处理。\n\n  - `case CHECK_STATE_REQUESTLINE:`：处理请求行，调用`parse_request_line`函数解析请求行，返回相应的处理结果，如果是`BAD_REQUEST`，返回`BAD_REQUEST`；如果是`GET_REQUEST`，则调用`do_request`函数进行处理。\n  - `case CHECK_STATE_HEADER:`：处理请求头，调用`parse_headers`函数解析请求头，返回相应的处理结果，如果是`BAD_REQUEST`，返回`BAD_REQUEST`；如果是`GET_REQUEST`，则调用`do_request`函数进行处理。\n  - `case CHECK_STATE_CONTENT:`：处理请求体，调用`parse_content`函数解析请求体，返回相应的处理结果，如果是`GET_REQUEST`，则调用`do_request`函数进行处理；将行状态设置为`LINE_OPEN`，防止进入死循环。\n  - `default:`：如果状态无法匹配，返回`INTERNAL_ERROR`，表示内部错误。\n\n\nreturn NO_REQUEST;：最终返回NO_REQUEST，表示处理完成，等待下一次读取请求。\n\n\n请求实现 do_request这段代码是http_conn类的成员函数do_request的实现，用于处理HTTP请求。\nhttp_conn::HTTP_CODE http_conn::do_request()&#123;    // 网站根目录    strcpy(m_real_file, doc_root);    int len = strlen(doc_root);    // 找到最后一个/的位置    const char *p = strrchr(m_url, &#x27;/&#x27;);    // POST请求，实现登录和注册校验    if(cgi == 1 &amp;&amp; (*(p + 1) == &#x27;2&#x27; || *(p + 1) == &#x27;3&#x27;))&#123;        char *m_url_real = (char *)malloc(sizeof(char) * 200);        strcpy(m_url_real, &quot;/&quot;);        strcat(m_url_real, m_url + 2);        strncpy(m_real_file + len, m_url_real, FILENAME_LEN - len - 1);        free(m_url_real);        // 将用户名和密码提取出来        // user=123&amp;password=123        char name[100], password[100];        int i;        for(i = 5; m_string[i] != &#x27;&amp;&#x27;; ++i)            name[i - 5] = m_string[i];        name[i - 5] = &#x27;\\0&#x27;;        int j = 0;        for(i = i + 10; m_string[i] != &#x27;\\0&#x27;; ++i, ++j)            password[j] = m_string[i];        password[j] = &#x27;\\0&#x27;;        if(*(p + 1) == &#x27;3&#x27;)&#123;            //如果是注册，先检测数据库中是否有重名的            //没有重名的，进行增加数据            char *sql_insert = (char *)malloc(sizeof(char) * 200);            strcpy(sql_insert, &quot;INSERT INTO user(username, password) VALUES(&quot;);            strcat(sql_insert, &quot;&#x27;&quot;);            strcat(sql_insert, name);            strcat(sql_insert, &quot;&#x27;, &#x27;&quot;);            strcat(sql_insert, password);            strcat(sql_insert, &quot;&#x27;)&quot;);            if(users.find(name) == users.end())&#123;                m_lock.lock();                int res = mysql_query(mysql, sql_insert);                users.insert(pair&lt;string, string&gt;(name, password));                m_lock.unlock();                if(!res)                    strcpy(m_url, &quot;/log.html&quot;);                else                    strcpy(m_url, &quot;/registerError.html&quot;);            &#125;            else                strcpy(m_url, &quot;/registerError.html&quot;);        &#125;        //如果是登录，直接判断        //若浏览器端输入的用户名和密码在表中可以查找到，返回1，否则返回0        else if(*(p + 1) == &#x27;2&#x27;)        &#123;            if(users.find(name) != users.end() &amp;&amp; users[name] == password)                strcpy(m_url, &quot;/welcome.html&quot;);            else                strcpy(m_url, &quot;/logError.html&quot;);        &#125;    &#125;    // GET请求，跳转到注册页面    if(*(p + 1) == &#x27;0&#x27;)&#123;        char *m_url_real = (char *)malloc(sizeof(char) * 200);        strcpy(m_url_real, &quot;/register.html&quot;);        strncpy(m_real_file + len, m_url_real, strlen(m_url_real));        free(m_url_real);    &#125;    // GET请求，跳转到登录页面    else if(*(p + 1) == &#x27;1&#x27;)&#123;        char *m_url_real = (char *)malloc(sizeof(char) * 200);        strcpy(m_url_real, &quot;/log.html&quot;);        strncpy(m_real_file + len, m_url_real, strlen(m_url_real));        free(m_url_real);    &#125;    // POST请求，图片页面    else if(*(p + 1) == &#x27;5&#x27;)&#123;        char *m_url_real = (char *)malloc(sizeof(char) * 200);        strcpy(m_url_real, &quot;/picture.html&quot;);        strncpy(m_real_file + len, m_url_real, strlen(m_url_real));        free(m_url_real);    &#125;    // POST请求，视频页面    else if(*(p + 1) == &#x27;6&#x27;)&#123;        char *m_url_real = (char *)malloc(sizeof(char) * 200);        strcpy(m_url_real, &quot;/video.html&quot;);        strncpy(m_real_file + len, m_url_real, strlen(m_url_real));        free(m_url_real);    &#125;    // POST请求，关注页面    else if(*(p + 1) == &#x27;7&#x27;)&#123;        char *m_url_real = (char *)malloc(sizeof(char) * 200);        strcpy(m_url_real, &quot;/fans.html&quot;);        strncpy(m_real_file + len, m_url_real, strlen(m_url_real));        free(m_url_real);    &#125;    else        // 都不是则直接拼接        strncpy(m_real_file + len, m_url, FILENAME_LEN - len - 1);    // 获取不到文件信息，资源不存在    if(stat(m_real_file, &amp;m_file_stat) &lt; 0)        return NO_RESOURCE;    // 文件是否可读    if(!(m_file_stat.st_mode &amp; S_IROTH))        return FORBIDDEN_REQUEST;    // 文件是否为目录    if(S_ISDIR(m_file_stat.st_mode))        return BAD_REQUEST;    // 以只读方式打开文件并映射到内存中    int fd = open(m_real_file, O_RDONLY);    m_file_address = (char *)mmap(0, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0);    // 关闭文件描述符    close(fd);    return FILE_REQUEST;&#125;\n\n\nstrcpy(m_real_file, doc_root);：复制网站根目录到m_real_file。\n\nconst char *p = strrchr(m_url, &#39;/&#39;);：找到请求URL中最后一个’&#x2F;‘的位置。\n\nif(cgi == 1 &amp;&amp; (*(p + 1) == &#39;2&#39; || *(p + 1) == &#39;3&#39;))\n   ：判断是否是CGI请求（登录或注册）。   - `char *m_url_real = (char *)malloc(sizeof(char) * 200);`：为`m_url_real`分配内存。   - 根据请求类型（&#x27;2&#x27;为登录，&#x27;3&#x27;为注册），拼接请求的URL到`m_url_real`。   - 将`m_url_real`拼接到`m_real_file`，得到完整的文件路径。   - 解析POST请求中的用户名和密码，然后进行相应的处理。4. ```c++   else if(*(p + 1) == &#x27;0&#x27;)\n\n：GET请求，跳转到注册页面。\n\n- `char *m_url_real = (char *)malloc(sizeof(char) * 200);`：为`m_url_real`分配内存。\n- 将注册页面的URL拼接到`m_url_real`，然后将其拼接到`m_real_file`。\n\n\nelse if(*(p + 1) == &#39;1&#39;)\n   ：GET请求，跳转到登录页面。   - `char *m_url_real = (char *)malloc(sizeof(char) * 200);`：为`m_url_real`分配内存。   - 将登录页面的URL拼接到`m_url_real`，然后将其拼接到`m_real_file`。6. ```c++   else if(*(p + 1) == &#x27;5&#x27;)\n\n：POST请求，图片页面。\n\n- 类似地处理图片、视频、关注等不同类型的页面。\n\n\nelse：都不是上述情况，则直接拼接URL到m_real_file。\n\nif(stat(m_real_file, &amp;m_file_stat) &lt; 0)：获取文件信息，如果失败则返回NO_RESOURCE表示资源不存在。\n\nif(!(m_file_stat.st_mode &amp; S_IROTH))：判断文件是否可读，如果不可读则返回FORBIDDEN_REQUEST表示禁止访问。\n\nif(S_ISDIR(m_file_stat.st_mode))：判断文件是否为目录，如果是目录则返回BAD_REQUEST表示请求不合法。\n\nint fd = open(m_real_file, O_RDONLY);：以只读方式打开文件。\n\nm_file_address = (char *)mmap(0, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0);：将文件映射到内存中。\n\nclose(fd);：关闭文件描述符。\n\nreturn FILE_REQUEST;：返回FILE_REQUEST，表示文件请求处理完成。\n\n\n关闭文件映射 unmap这段代码是http_conn类的成员函数unmap的实现，用于关闭文件映射。\n// 关闭文件映射void http_conn::unmap()&#123;    if(m_file_address)&#123;        munmap(m_file_address, m_file_stat.st_size);        m_file_address = 0;    &#125;&#125;\n\n\nif(m_file_address)：检查m_file_address是否非空，即是否已经映射了文件。\nmunmap(m_file_address, m_file_stat.st_size);：调用munmap函数关闭文件映射，释放映射的内存。\nm_file_address = 0;：将m_file_address置为0，表示文件映射已关闭。\n\n向客户端写响应 write这段代码是http_conn类的成员函数write的实现，主要用于向客户端写响应。\n// 向客户端写响应bool http_conn::write()&#123;    int temp = 0;    // 响应报文为空    if(bytes_to_send == 0)&#123;        modfd(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);        init();        return true;    &#125;    while(1)&#123;        // 发送响应        temp = writev(m_sockfd, m_iv, m_iv_count);        if(temp &lt; 0)&#123;            // 重试，继续监听写事件            if(errno == EAGAIN)            &#123;                modfd(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);                // 不要断开连接                return true;            &#125;            // 断开连接            unmap();            return false;        &#125;        // 正常发送        bytes_have_send += temp;        bytes_to_send -= temp;        // 第一个元素已经发送完        if(bytes_have_send &gt;= m_iv[0].iov_len)&#123;            m_iv[0].iov_len = 0;            m_iv[1].iov_base = m_file_address + (bytes_have_send - m_write_idx);            m_iv[1].iov_len = bytes_to_send;        &#125;        // 继续发送第一个元素        else&#123;            m_iv[0].iov_base = m_write_buf + bytes_have_send;            m_iv[0].iov_len = m_iv[0].iov_len - bytes_have_send;        &#125;        // 全部发送完毕        if(bytes_to_send &lt;= 0)&#123;            unmap();            modfd(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);            // 长连接            if(m_linger)&#123;                init();                return true;            &#125;            else&#123;                return false;            &#125;        &#125;    &#125;&#125;\n\n\nif(bytes_to_send == 0)：如果响应报文为空，表示数据已经发送完毕，可以修改epoll事件，然后初始化连接，准备处理下一个请求。\n\nwhile(1)：进入一个无限循环，用于循环发送响应数据。\n\ntemp = writev(m_sockfd, m_iv, m_iv_count);：使用writev函数向客户端发送响应，m_iv是iovec结构体数组，指定了发送的数据块和长度。\n\n判断temp的返回值：\n\ntemp &lt; 0\n     ：发生错误，根据错误类型采取相应的处理措施。     - 如果是 `EAGAIN`，表示当前无法写入更多数据，此时应该修改`epoll`事件监听写事件，等待下一次写事件到来，然后继续循环。     - 如果是其他错误，可能是连接断开等问题，调用`unmap`关闭文件映射，然后返回`false`表示写入失败。5. `temp &gt;= 0`：正常发送数据，更新已发送和剩余待发送的字节数。如果第一个`iovec`元素的数据已经发送完毕，将其长度置为0，并更新第二个元素的位置和长度，继续发送。6. 判断`bytes_to_send`是否小于等于0：   - 如果是，表示全部数据发送完毕，调用`unmap`关闭文件映射，修改`epoll`事件为监听读事件，并根据长连接标志决定是否初始化连接准备处理下一个请求。   - 如果不是，继续下一轮循环，继续发送。### 写响应 add_response这段代码是`http_conn`类的成员函数`add_response`的实现，主要用于往写缓冲区中添加HTTP响应内容。```c++// 写响应bool http_conn::add_response(const char *format, ...)&#123;    // 写入内容超过buffer长度则报错    if(m_write_idx &gt;= WRITE_BUFFER_SIZE)        return false;        // 可变参数列表    va_list arg_list;    // 初始化列表    va_start(arg_list, format);    // 按照format写入缓存    int len = vsnprintf(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - 1 - m_write_idx, format, arg_list);    // 超出缓存则报错    if(len &gt;= (WRITE_BUFFER_SIZE - 1 - m_write_idx))&#123;        va_end(arg_list);        return false;    &#125;    // 更新idx    m_write_idx += len;    va_end(arg_list);    LOG_INFO(&quot;add response: %s&quot;, m_write_buf);    return true;&#125;\n\n\n\n\nif(m_write_idx &gt;= WRITE_BUFFER_SIZE)：检查写缓冲区是否已满，如果已满，则表示无法继续添加响应内容，返回false。\n\nva_list arg_list;：声明一个变量参数列表。\n\nva_start(arg_list, format);：初始化变量参数列表，使其指向参数列表中的第一个可变参数。\n\nint len = vsnprintf(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - 1 - m_write_idx, format, arg_list);：使用vsnprintf函数按照指定的format格式将可变参数列表中的内容写入写缓冲区。vsnprintf会根据指定的格式将可变参数列表中的内容格式化并写入指定长度的缓冲区。\n\nif(len &gt;= (WRITE_BUFFER_SIZE - 1 - m_write_idx))：检查写入的内容长度是否超过了写缓冲区的剩余空间，如果超过则表示写入过程中发生截断，返回false。\n\nm_write_idx += len;：更新写缓冲区的索引位置，将已写入的长度加到索引上。\n\nva_end(arg_list);：结束变量参数列表的使用。\n\nLOG_INFO(&quot;add response: %s&quot;, m_write_buf);：打印日志，记录添加的响应内容。\n\nreturn true;：表示添加响应内容成功。\n\n\n该函数允许通过格式化字符串和可变参数列表的方式往写缓冲区中添加HTTP响应内容，便于构建响应报文。\n状态行 add_status_line这是http_conn类的成员函数add_status_line的实现，用于向写缓冲区中添加HTTP响应的状态行。\n// 状态行bool http_conn::add_status_line(int status, const char *title)&#123;    return add_response(&quot;%s %d %s\\r\\n&quot;, &quot;HTTP/1.1&quot;, status, title);&#125;\n\n\nadd_response(&quot;%s %d %s\\r\\n&quot;, &quot;HTTP/1.1&quot;, status, title)：通过调用add_response函数，使用格式化字符串往写缓冲区中添加状态行内容。&quot;%s %d %s\\r\\n&quot;是格式化字符串，其中：\n%s 会被替换为 “HTTP&#x2F;1.1”\n%d 会被替换为 status 参数传递的状态码\n%s 会被替换为 title 参数传递的状态码对应的文本描述\n\\r\\n 表示回车和换行，标识行结束\n\n\n返回add_response的执行结果。如果写缓冲区已满或其他写入错误，可能返回false。\n\n该函数主要用于构建HTTP响应的状态行，指定协议版本、状态码和状态码的文本描述。\n响应报头 add_headers这是http_conn类的成员函数add_headers的实现，用于向写缓冲区中添加HTTP响应的报头。\n// 响应报头bool http_conn::add_headers(int content_len)&#123;    return add_content_length(content_len) &amp;&amp; add_linger() &amp;&amp;           add_blank_line();&#125;\n\n\nadd_content_length(content_len)：通过调用add_content_length函数，向写缓冲区中添加”Content-Length”字段，表示消息体的长度。content_len是传递的消息体长度。\nadd_linger()：通过调用add_linger函数，向写缓冲区中添加”Connection”字段，表示是否使用持久连接。该函数会根据成员变量m_linger的值来确定是”keep-alive”还是”close”。\nadd_blank_line()：通过调用add_blank_line函数，向写缓冲区中添加一个空行，用于分隔报头和消息体。\n返回上述三个函数的执行结果的逻辑与(&amp;&amp;)运算结果。如果有任何一个函数返回false，整体结果也为false。\n\n该函数主要用于构建HTTP响应的报头，包括”Content-Length”字段、”Connection”字段以及一个空行。\n消息报头 add_content_length// 消息报头bool http_conn::add_content_length(int content_len)&#123;    return add_response(&quot;Content-Length:%d\\r\\n&quot;, content_len);&#125;\n\n这是http_conn类的成员函数add_content_length的实现，用于向写缓冲区中添加HTTP响应的”Content-Length”字段。以下是该函数的解释：\n\nadd_response(&quot;Content-Length:%d\\r\\n&quot;, content_len)：通过调用add_response函数，向写缓冲区中添加”Content-Length”字段，指定消息体的长度为content_len。\n返回上述函数的执行结果。\n\n该函数主要用于构建HTTP响应的报头中的”Content-Length”字段，指明消息体的长度。\nContent-Type add_content_type这是http_conn类的成员函数add_content_type的实现，用于向写缓冲区中添加HTTP响应的Content-Type字段。\nbool http_conn::add_content_type()&#123;    return add_response(&quot;Content-Type:%s\\r\\n&quot;, &quot;text/html&quot;);&#125;\n\n\nadd_response(&quot;Content-Type:%s\\r\\n&quot;, &quot;text/html&quot;)：通过调用add_response函数，向写缓冲区中添加”Content-Type”字段，指定消息体的类型为”text&#x2F;html”，表示HTML文档。\n返回上述函数的执行结果。\n\n该函数主要用于构建HTTP响应的报头中的”Content-Type”字段，指明消息体的类型。在这里，它指定消息体的类型为HTML文档。\nadd_linger这是http_conn类的成员函数add_linger的实现，用于向写缓冲区中添加HTTP响应的”Connection”字段。以下是该函数的解释：\nbool http_conn::add_linger()&#123;    return add_response(&quot;Connection:%s\\r\\n&quot;, (m_linger == true) ? &quot;keep-alive&quot; : &quot;close&quot;);&#125;\n\n\nadd_response(&quot;Connection:%s\\r\\n&quot;, (m_linger == true) ? &quot;keep-alive&quot; : &quot;close&quot;)：通过调用add_response函数，向写缓冲区中添加”Connection”字段。如果m_linger成员变量为true，表示使用长连接，将”keep-alive”添加到字段中；否则，表示使用短连接，将”close”添加到字段中。\n返回上述函数的执行结果。\n\n该函数主要用于构建HTTP响应的报头中的”Connection”字段，指明连接的持久性。如果m_linger为true，则使用长连接；否则，使用短连接。\n空行 add_blank_line// 空行bool http_conn::add_blank_line()&#123;    return add_response(&quot;%s&quot;, &quot;\\r\\n&quot;);&#125;这是`http_conn`类的成员函数`add_blank_line`的实现，用于向写缓冲区中添加一个空行，即`\\r\\n`，表示HTTP响应头部的结束。以下是该函数的解释：\n\n\nadd_response(&quot;%s&quot;, &quot;\\r\\n&quot;)：通过调用add_response函数，向写缓冲区中添加一个空行。\n返回上述函数的执行结果。\n\n该函数主要用于构建HTTP响应头的结束标志，以便与响应的实体主体（如果有的话）分隔开来。\n响应正文 add_content// 响应正文bool http_conn::add_content(const char *content)&#123;    return add_response(&quot;%s&quot;, content);&#125;\n\n这是http_conn类的成员函数add_content的实现，用于向写缓冲区中添加HTTP响应正文内容。以下是该函数的解释：\n\nadd_response(&quot;%s&quot;, content)：通过调用add_response函数，向写缓冲区中添加传入的content参数，即HTTP响应的实体主体内容。\n返回上述函数的执行结果。\n\n该函数主要用于向HTTP响应中添加实体主体的内容，例如 HTML 内容、图片、视频等。\n向缓冲区写响应 process_write// 向缓冲区写响应bool http_conn::process_write(HTTP_CODE ret)&#123;    switch (ret)&#123;        case INTERNAL_ERROR:&#123;            add_status_line(500, error_500_title);            add_headers(strlen(error_500_form));            if(!add_content(error_500_form))                return false;            break;        &#125;        case BAD_REQUEST:&#123;            add_status_line(404, error_404_title);            add_headers(strlen(error_404_form));            if(!add_content(error_404_form))                return false;            break;        &#125;        case FORBIDDEN_REQUEST:&#123;            add_status_line(403, error_403_title);            add_headers(strlen(error_403_form));            if(!add_content(error_403_form))                return false;            break;        &#125;        case FILE_REQUEST:&#123;            add_status_line(200, ok_200_title);            if(m_file_stat.st_size != 0)&#123;                add_headers(m_file_stat.st_size);                // 第一个元素指向响应报文写缓冲                m_iv[0].iov_base = m_write_buf;                m_iv[0].iov_len = m_write_idx;                // 第二个元素指向mmap返回的文件指针                m_iv[1].iov_base = m_file_address;                m_iv[1].iov_len = m_file_stat.st_size;                m_iv_count = 2;                bytes_to_send = m_write_idx + m_file_stat.st_size;                return true;            &#125;            // 资源大小为0则返回空白html            else&#123;                const char *ok_string = &quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;;                add_headers(strlen(ok_string));                if(!add_content(ok_string))                    return false;            &#125;        &#125;        default:            return false;    &#125;    // 除FILE_REQUEST外只指向响应报文缓冲    m_iv[0].iov_base = m_write_buf;    m_iv[0].iov_len = m_write_idx;    m_iv_count = 1;    bytes_to_send = m_write_idx;    return true;&#125;\n\nprocess_write 函数主要用于根据不同的 HTTP_CODE 处理响应。具体来说，根据传入的 HTTP_CODE，生成相应的 HTTP 响应报文。以下是对每个情况的解释：\n\nINTERNAL_ERROR：生成 500 Internal Server Error 错误响应。设置状态行、响应头、实体主体，并将相关信息写入缓冲区。\nBAD_REQUEST：生成 404 Not Found 错误响应。设置状态行、响应头、实体主体，并将相关信息写入缓冲区。\nFORBIDDEN_REQUEST：生成 403 Forbidden 错误响应。设置状态行、响应头、实体主体，并将相关信息写入缓冲区。\nFILE_REQUEST：处理正常的文件请求。设置状态行、响应头，并将文件内容映射到写缓冲区中。这里使用 writev 函数进行数据的直接写入。\n其他情况：返回 false。\n\n最后，根据生成的响应，设置写缓冲区的数据，并准备发送给客户端。\nhttp处理 process// http处理void http_conn::process()&#123;    HTTP_CODE read_ret = process_read();    // 请求不完整，继续注册读事件    if(read_ret == NO_REQUEST)&#123;        modfd(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);        return;    &#125;    bool write_ret = process_write(read_ret);    if(!write_ret)&#123;        close_conn();    &#125;    // 准备好写缓冲，加入监听可写事件    modfd(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);&#125;\n\nprocess 函数用于处理 HTTP 请求。首先调用 process_read 函数进行请求的解析，根据返回的 HTTP_CODE 判断请求是否完整。如果请求不完整，则继续注册监听读事件。\n如果请求完整，接着调用 process_write 函数生成相应的响应。如果 process_write 返回 false，则关闭连接。否则，准备好写缓冲，加入监听可写事件。\n这个函数的逻辑是基于事件驱动的异步非阻塞模型，通过监听和处理事件来实现高并发。\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"从零实现WebServer之数据库连接池类","url":"/2023/12/29/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0WebServer%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%B1%BB/","content":"从零实现WebServer之数据库连接池类数据库连接池类流程图\n\n获取实例 get_instance // 单例模式static connection_pool* get_instance()&#123;    static connection_pool connPool;    return &amp;connPool;&#125;\n\n这是一个典型的单例模式实现，通过在静态成员函数 get_instance 中创建 static 局部变量 connPool，确保了在程序的生命周期内只有一个实例被创建。这种方式被称为懒汉式单例模式，因为实例在第一次调用 get_instance 时被创建。 在 C++11 及以上标准中，对于静态局部变量的初始化是线程安全的，因此这种实现在多线程环境下是安全的。在早期的 C++ 标准中，可能需要考虑额外的线程安全性措施。当程序结束时，connPool 对象将在全局静态存储区自动销毁，确保了释放资源。\n构造函数 connection_poolconnection_pool::connection_pool()&#123;    m_cur_conn = 0;    m_free_conn = 0;&#125;\n\n在构造函数 connection_pool::connection_pool() 中，初始化了 m_cur_conn 和 m_free_conn 两个成员变量。这样的初始化是很常见的，通常用于确保在对象创建时，这些成员变量处于一个已知的初始状态。\n\nm_cur_conn 用于记录当前已经使用的数据库连接数。\nm_free_conn 用于记录当前空闲的数据库连接数。\n\n通过将它们初始化为零，确保了在对象创建时，这两个计数器的初始值为零。接下来，在程序运行时，通过 get_connection 获取连接时，m_cur_conn 会递增，而在 release_connection 释放连接时，m_cur_conn 会递减，同时 m_free_conn 也会相应地增加或减少。这样的设计方案有助于在连接池中管理数据库连接的数量，以及追踪当前连接的使用情况。\n析构函数 ~connection_poolconnection_pool::~connection_pool()&#123;    list&lt;MYSQL*&gt;::iterator iter;    for(iter = conn_list.begin(); iter != conn_list.end(); ++iter)&#123;        MYSQL * conn = *iter;        mysql_close(conn);    &#125;&#125;\n\n在 connection_pool 类的析构函数 connection_pool::~connection_pool() 中，对连接池中的 MySQL 连接进行了关闭。\n具体地说，它遍历了 conn_list 列表，关闭了每个 MySQL 连接。这是一个良好的实践，因为在对象销毁时，应该释放所有的资源，包括打开的数据库连接。通过在析构函数中完成这个工作，确保了在对象生命周期结束时，相关资源能够被正确释放，从而避免了潜在的资源泄漏问题。\n需要注意的是，MySQL 连接的关闭不仅仅是释放连接对象本身，还包括释放底层的资源，确保在数据库连接不再需要时，相关资源能够被正确释放。\n初始化连接池 init// 初始化连接池void connection_pool::init(string url, string user, string password, string database_name, int port, int max_conn, int close_log)&#123;    m_url = url;    m_port = port;    m_user = user;    m_password = password;    m_database_name = database_name;    m_close_log = close_log;    // 构造连接    for(int i = 0; i &lt; max_conn; ++i)&#123;        // 初始化一个mysql连接的实例对象，MYSQL* mysql_init(MYSQL *mysql);        MYSQL *conn = nullptr;        conn = mysql_init(conn);        if(conn == nullptr)&#123;            LOG_ERROR(&quot;MySQL init Error&quot;);            exit(1);        &#125;        // 与数据库引擎建立连接        conn = mysql_real_connect(conn,url.c_str(),user.c_str(),password.c_str(),database_name.c_str(),port,nullptr,0);        if(conn == nullptr)&#123;            LOG_ERROR(&quot;MySQL real connect Error&quot;);            exit(1);        &#125;        // 添加到连接链表        conn_list.push_back(conn);        ++m_free_conn;    &#125;    // 创建信号量    reserve = semaphore(m_free_conn);    m_max_conn = m_free_conn;&#125;\n\n在 connection_pool 类的初始化函数 connection_pool::init 中，进行了数据库连接池的初始化工作。下面是对该函数的一些主要步骤的解释：\n\n初始化成员变量： 将函数参数中传递的各种连接信息（如主机地址、用户名、密码等）赋值给类的成员变量。\nm_url = url;m_port = port;m_user = user;m_password = password;m_database_name = database_name;m_close_log = close_log;\n\n构造连接： 使用 mysql_init 函数初始化一个 MySQL 连接的实例对象。\nMYSQL *conn = nullptr;conn = mysql_init(conn);\n\n如果初始化失败，记录错误日志并退出程序。\n\n建立与数据库引擎的连接： 使用 mysql_real_connect 函数与数据库引擎建立连接。\nconn = mysql_real_connect(conn, url.c_str(), user.c_str(), password.c_str(), database_name.c_str(), port, nullptr, 0);\n\n如果连接失败，记录错误日志并退出程序。\n\n添加到连接链表： 将成功建立连接的 MySQL 对象添加到连接链表中，并增加空闲连接数。\nconn_list.push_back(conn);++m_free_conn;\n\n创建信号量： 使用 semaphore 类创建一个信号量对象 reserve，初始值为空闲连接数。\nreserve = semaphore(m_free_conn);\n\n设置最大连接数： 将当前的空闲连接数作为最大连接数。\nm_max_conn = m_free_conn;\n\n该函数的目标是初始化数据库连接池，包括创建连接、建立与数据库引擎的连接、管理连接链表和信号量等。这是一个典型的连接池初始化流程。\n获取可用连接 get_connection// 有请求时，从数据库连接池返回一个可用连接MYSQL* connection_pool::get_connection()&#123;    // 无空闲连接    if(conn_list.size() == 0)&#123;        return nullptr;    &#125;    MYSQL *conn = nullptr;    // 等待空闲连接    reserve.wait();    // 加互斥锁    lock.lock();    // 取连接池第一个连接    conn = conn_list.front();    conn_list.pop_front();    --m_free_conn;    ++m_cur_conn;    lock.unlock();    return conn;&#125;\n\nconnection_pool::get_connection 函数用于在有请求时从数据库连接池返回一个可用连接。下面是对该函数的主要步骤解释：\n\n检查连接池是否有空闲连接： 如果连接池中没有空闲连接（conn_list.size() == 0），则返回 nullptr 表示没有可用连接。\nif(conn_list.size() == 0)&#123;    return nullptr;&#125;\n\n等待空闲连接： 调用信号量的 wait 函数等待有可用连接为止。\nreserve.wait();\n\n这里使用了信号量 reserve 来表示有多少个可用连接。如果 reserve 的值为零，表示没有可用连接，该函数将会被阻塞。\n\n获取连接： 在获取连接之前，使用互斥锁保护临界区，以确保线程安全。从连接链表的头部获取一个连接，并从链表中移除。\nlock.lock();conn = conn_list.front();conn_list.pop_front();\n\n更新连接计数： 减少空闲连接数，增加当前已使用连接数。\n--m_free_conn;++m_cur_conn;lock.unlock();\n\n返回连接： 返回获取到的连接。\nreturn conn;\n\n该函数在有请求时从连接池中获取一个可用连接，确保线程安全地管理连接池状态。\n在 connection_pool::init 函数中，初始化的过程是在单线程环境下进行的，因此不需要加锁。在初始化过程中，不会有其他线程同时尝试修改连接池的状态，因此不存在竞争条件。\n而在 connection_pool::get_connection 函数中，涉及到获取连接、更新连接池状态等操作，这些操作在多线程环境下可能会被多个线程同时调用。所有需要使用互斥锁进行保护。\n\n\n释放连接 release_connection// 释放当前使用的连接，成功返回truebool connection_pool::release_connection(MYSQL *conn)&#123;    if(conn == nullptr)&#123;        return false;    &#125;    lock.lock();    conn_list.push_back(conn);    ++m_free_conn;    --m_cur_conn;    lock.unlock();    reserve.post();    return true;&#125;\n\n在 connection_pool::release_connection 函数中，通过互斥锁 lock 对连接池的状态进行了修改，确保在多线程环境下对连接池的操作是互斥的。这是因为在释放连接的过程中，会涉及到对连接池中的连接列表、空闲连接数、当前使用连接数等状态的修改，而这些修改是不可分割的操作。\n以下是函数中的主要操作：\n\n加锁： 使用互斥锁 lock.lock()，将当前线程锁住，防止其他线程同时修改连接池状态。\n连接释放： 将当前使用的连接 conn 放回连接池的连接列表 conn_list 中，同时更新空闲连接数 m_free_conn 和当前使用连接数 m_cur_conn。\n解锁： 使用互斥锁 lock.unlock()，释放锁，允许其他线程访问连接池。\n信号量增加： 调用 reserve.post()，将信号量的计数增加，表示有一个空闲连接可用。\n\n这样设计确保了在多线程环境下对连接池状态的修改是线程安全的。如果不使用互斥锁进行保护，可能会导致多个线程同时修改连接池状态而出现问题。\n当前空闲连接数 get_freeconn// 当前空闲连接数int connection_pool::get_freeconn()&#123;    return this-&gt;m_free_conn;&#125;\n\n资源获取即初始化connectionRAII 类是一个简单的资源获取即初始化（RAII）类。在构造函数中获取资源（数据库连接），在析构函数中释放这些资源。这个类的主要目的是通过构造函数获得资源（数据库连接），并在对象销毁时通过析构函数释放这些资源。使用这个类可以确保在任何情况下都能正确地释放数据库连接，避免资源泄漏。这是 C++ 中一种常见的资源管理方式，称为 RAII 设计模式。\n\n\n获取连接 connectionRAII// 从连接池获取一个数据库连接connectionRAII::connectionRAII(MYSQL **conn, connection_pool *connPool)&#123;    *conn = connPool-&gt;get_connection();    connRAII = *conn;    poolRAII = connPool;&#125;\n\nconnectionRAII 类的构造函数是一个资源获取即初始化的操作，通过该构造函数可以获取一个数据库连接并初始化 connRAII 和 poolRAII 成员变量。\n具体步骤如下：\n\n获取连接： 调用 connPool-&gt;get_connection() 从数据库连接池中获取一个连接，并将连接指针赋值给 *conn，这是通过传入的参数来返回连接的。\n初始化成员变量： 将获取的连接赋值给 connRAII，表示当前对象拥有该数据库连接。\n保存连接池指针： 将传入的 connPool 赋值给 poolRAII，表示当前对象持有该连接所属的连接池的指针。\n\n这样，在 connectionRAII 对象构造时，就完成了数据库连接的获取，并且通过 connRAII 持有了这个连接，同时也保存了连接所属的连接池的指针。这符合资源获取即初始化的 RAII 设计思想。\n释放连接 ~connectionRAII// 释放持有的数据库连接connectionRAII::~connectionRAII()&#123;    poolRAII-&gt;release_connection(connRAII);&#125;\n\nconnectionRAII 类的析构函数实现了资源的释放操作。在析构函数中，它调用了 poolRAII-&gt;release_connection(connRAII) 来释放持有的数据库连接。\n释放连接： 调用 poolRAII-&gt;release_connection(connRAII)，将持有的数据库连接 connRAII 释放回连接池。这个操作会使连接池的空闲连接数量增加，同时当前对象持有的连接数量减少。\n通过这样的设计，当 connectionRAII 对象生命周期结束时（例如，超出了其作用域），它会自动释放持有的数据库连接，确保连接得到有效的回收和重用。这符合 RAII 设计模式，简化了资源管理的代码。\n以下部分参考：C++多线程连接池MySQL (foryouos.cn)\n\nC++ 封装 MySQL API构造函数 (MySqlConnect::MySqlConnect)：MySqlConnect::MySqlConnect() &#123;    m_conn = mysql_init(nullptr);    mysql_set_character_set(m_conn, &quot;utf8&quot;);&#125;\n\n\n功能： 初始化m_conn，即MySQL连接对象。\n详解：\n使用mysql_init初始化MySQL连接对象。\n通过mysql_set_character_set设置字符集为”utf8”，以支持UTF-8编码。\n\n\n\n析构函数 (MySqlConnect::~MySqlConnect)：MySqlConnect::~MySqlConnect() &#123;    if (m_conn != nullptr) &#123;        mysql_close(m_conn);    &#125;    freeResult();&#125;\n\n\n功能： 关闭MySQL连接，释放相关资源。\n详解：\n使用mysql_close关闭MySQL连接。\n调用freeResult释放执行查询时产生的结果集。\n\n\n\n释放结果集 (MySqlConnect::freeResult)：void MySqlConnect::freeResult() &#123;    if (m_result) &#123;        mysql_free_result(m_result);        m_result = nullptr;    &#125;&#125;\n\n\n功能： 释放结果集占用的内存。\n详解：\n使用mysql_free_result释放结果集占用的内存。\n将m_result置为nullptr，确保不再指向已释放的内存。\n\n\n\n连接数据库 (MySqlConnect::connect)：bool MySqlConnect::connect(string user, string passwd, string dbName, string ip, unsigned short port) &#123;    MYSQL* ptr = mysql_real_connect(m_conn, ip.c_str(), user.c_str(), passwd.c_str(), dbName.c_str(), port, nullptr, 0);    return ptr != nullptr;&#125;\n\n\n功能： 连接到MySQL数据库。\n详解：\n使用mysql_real_connect进行实际的数据库连接。\n返回连接是否成功的布尔值。\n\n\n\n执行更新操作 (MySqlConnect::update)：bool MySqlConnect::update(string sql) &#123;    if (mysql_query(m_conn, sql.c_str())) &#123;        return false;    &#125;    return true;&#125;\n\n\n功能： 执行更新操作（插入、更新、删除等）的SQL语句。\n详解：\n使用mysql_query执行SQL语句。\n返回执行是否成功的布尔值。\n\n\n\n执行查询操作 (MySqlConnect::query)：bool MySqlConnect::query(string sql) &#123;    freeResult();    if (mysql_query(m_conn, sql.c_str())) &#123;        return false;    &#125;    m_result = mysql_store_result(m_conn);    return true;&#125;\n\n\n功能： 执行查询操作的SQL语句。\n详解：\n在执行查询之前通过freeResult释放之前的结果集。\n使用mysql_query执行SQL语句。\n使用mysql_store_result将查询结果存储在m_result中。\n返回执行是否成功的布尔值。\n\n\n\n遍历查询结果 (MySqlConnect::next)：bool MySqlConnect::next() &#123;    if (m_result != nullptr) &#123;        m_row = mysql_fetch_row(m_result);        return true;    &#125;    return false;&#125;\n\n\n功能： 移动到结果集中的下一行。\n详解：\n使用mysql_fetch_row获取结果集中的下一行数据。\n返回是否成功移动到下一行的布尔值。\n\n\n\n获取结果集中的字段值 (MySqlConnect::value)：string MySqlConnect::value(int index) &#123;    int row_num = mysql_num_fields(m_result);    if (index &gt;= row_num || index &lt; 0) &#123;        return string();    &#125;    char* val = m_row[index];    unsigned long length = mysql_fetch_lengths(m_result)[index];    return string(val, length);&#125;\n\n\n功能： 获取当前行中指定列的值。\n详解：\n使用mysql_num_fields获取结果集中的列数。\n如果指定的列索引超出范围，返回空字符串。\n使用mysql_fetch_lengths获取列的长度。\n返回当前行中指定列的字符串值。\n\n\n\n事务操作 (MySqlConnect::transaction, MySqlConnect::commit, MySqlConnect::rollback)：bool MySqlConnect::transaction() &#123;    return mysql_autocommit(m_conn, false);&#125;bool MySqlConnect::commit() &#123;    return mysql_commit(m_conn);&#125;bool MySqlConnect::rollback() &#123;    return mysql_rollback(m_conn);&#125;\n\n\n功能： 执行事务操作（开启事务、提交、回滚）。\n详解：\ntransaction方法用于开启事务，关闭自动提交。\ncommit方法用于提交事务。\nrollback方法用于回滚事务。\n返回执行是否成功的布尔值。\n\n\n\nMySQLConnect.h#pragma once#ifndef MYSQLCONNECT_H#define MYSQLCONNECT_H#include &lt;iostream&gt;#include &lt;mysql.h&gt;using namespace std;class MySqlConnect&#123;private:\t// 什么时候调用释放结果集\t//1, 析构函数 2，可能会对数据库进行多次查询，每次查询一次都会得到结果集，查询是清空掉上次的结果集\tvoid freeResult(); // 释放结果集\tMYSQL* m_conn = nullptr; // 保存 MySQL 初始化的私有成员\tMYSQL_RES* m_result = nullptr; // 报错结果集\tMYSQL_ROW m_row = nullptr; // 保存着当前字段的所有列的数值public:\t// 初始化数据库连接\tMySqlConnect();\t// 释放数据库连接\t~MySqlConnect();\t// 连接数据库，使用默认端口可省略端口书写\tbool connect(string user, string passwd,string dbName,string ip,unsigned short port = 3306 );\t// 更新数据库 (插入，更新，删除)，传递字符串\tbool update(string sql);\t// 查询数据库，单词 query: 查询\tbool query(string sql);\t// 遍历查询得到的结果集，每调一次，从结果集中取出一条数据\tbool next(); \t// 得到结果集中的字段值，取记录里面字段方法\tstring value(int index); \t// 事务操作，关闭自动提交\tbool transaction();\t// 提交事务\tbool commit();\t// 事务回滚；\tbool rollback();&#125;;#endif // !MYSQLCONNECT_H\n\nMySQLConnect.cpp#include &quot;MySQLConnect.h&quot;void MySqlConnect::freeResult()&#123;\tif (m_result)\t&#123;\t\tmysql_free_result(m_result);\t\tm_result = nullptr;\t&#125;&#125;MySqlConnect::MySqlConnect()&#123;\tm_conn = mysql_init(nullptr);\tmysql_set_character_set(m_conn, &quot;utf8&quot;);&#125;MySqlConnect::~MySqlConnect()&#123;\tif (m_conn != nullptr)\t&#123;\t\tmysql_close(m_conn);\t&#125;\tfreeResult();&#125;bool MySqlConnect::connect(string user, string passwd, string dbName, string ip, unsigned short port)&#123;\t//ip 传入为 string，使用.str 将 ip 转为 char * 类型\tMYSQL* ptr = mysql_real_connect(m_conn, ip.c_str(), user.c_str(), passwd.c_str(), dbName.c_str(), port, nullptr, 0);\t// 连接成功返回 true\t// 如果连接成功返回 TRUE，失败返回 FALSE\treturn ptr!=nullptr;&#125;bool MySqlConnect::update(string sql)&#123;\t//query 执行成功返回 0\tif (mysql_query(m_conn, sql.c_str()))\t&#123;\t\treturn false;\t&#125;;\treturn true;&#125;boolMySqlConnect::query(string sql)&#123;\tfreeResult();\t//query 执行成功返回 0\tif (mysql_query(m_conn, sql.c_str()))\t&#123;\t\treturn false;\t&#125;;\tm_result = mysql_store_result(m_conn);\treturn true;&#125;bool MySqlConnect::next()&#123;\t// 如果结果集为空则没有必要遍历\tif (m_result != nullptr)\t&#123;\t\t// 保存着当前字段的所有列的数值\t\tm_row = mysql_fetch_row(m_result);\t\treturn true;\t&#125;\treturn false;&#125;string MySqlConnect::value(int index)&#123; \t// 表示列的数量\tint row_num = mysql_num_fields(m_result); // 函数得到结果集中的列数\t// 如果查询的的 index 列大于总列，或小于 0，是错误的\tif (index &gt;= row_num || index &lt; 0)\t&#123;\t\treturn string();\t&#125;\tchar* val = m_row[index]; // 若为二进制数据，中间是有 &quot;\\0&quot; 的\tunsigned long length = mysql_fetch_lengths(m_result)[index];\treturn string(val,length); // 传入 length 就不会以 &quot;\\0&quot; 为结束符，而是通过长度把对应的字符转换为 string 类型&#125;bool MySqlConnect::transaction()&#123;\treturn mysql_autocommit(m_conn,false); // 函数返回值本身就是 bool 类型&#125;bool MySqlConnect::commit()&#123;\treturn mysql_commit(m_conn);// 提交&#125;bool MySqlConnect::rollback()&#123;\treturn mysql_rollback(m_conn);//bool 类型，函数成功返回 TRUE，失败返回 FALSE&#125;\n\n数据库连接池：包含封装MySQL API构造函数 (ConnectionPool::ConnectionPool)：ConnectionPool::ConnectionPool() &#123;    if (!parseJsonFile()) &#123;        cout &lt;&lt; &quot;数据库连接失败&quot; &lt;&lt; endl;        return;    &#125;    for (int i = 0; i &lt; m_minSize; ++i) &#123;        if (m_connectionQ.size() &lt; m_maxSize) &#123;            MySqlConnect* conn = new MySqlConnect;            conn-&gt;connect(m_user, m_passwd, m_dbName, m_ip, m_port);            m_connectionQ.push(conn);        &#125; else &#123;            cout &lt;&lt; &quot;当前连接数量已超过允许的最大连接数&quot; &lt;&lt; endl;            break;        &#125;    &#125;    thread producer(&amp;ConnectionPool::produceConnection, this);    thread recycler(&amp;ConnectionPool::recycleConnection, this);    producer.detach();    recycler.detach();&#125;\n\n\n功能： 构造函数，初始化连接池。\n详解：\n调用parseJsonFile加载配置信息。\n初始化连接池中的连接，保证达到最小连接数。\n创建两个线程，一个用于生成新连接(produceConnection)，一个用于回收连接(recycleConnection)。\n将生成连接线程和回收连接线程分离。\n\n\n\n析构函数 (ConnectionPool::~ConnectionPool)：ConnectionPool::~ConnectionPool() &#123;    while (!m_connectionQ.empty()) &#123;        MySqlConnect* conn = m_connectionQ.front();        m_connectionQ.pop();        delete conn;    &#125;&#125;\n\n\n功能： 析构函数，释放连接池中的连接。\n详解：\n循环弹出连接队列中的连接，并释放内存。\n\n\n\n解析JSON文件 (ConnectionPool::parseJsonFile)：bool ConnectionPool::parseJsonFile() &#123;    try &#123;        ifstream ifs(&quot;dbconf.json&quot;);        Reader rd;        Value root;        rd.parse(ifs, root);        if (root.isObject()) &#123;            m_ip = root[&quot;ip&quot;].asString();            m_port = root[&quot;port&quot;].asInt();            m_user = root[&quot;userName&quot;].asString();            m_passwd = root[&quot;password&quot;].asString();            m_dbName = root[&quot;dbName&quot;].asString();            m_minSize = root[&quot;minSize&quot;].asInt();            m_maxSize = root[&quot;maxSize&quot;].asInt();            m_maxIdleTime = root[&quot;maxIdleTime&quot;].asInt();            m_timeout = root[&quot;timeout&quot;].asInt();            return true;        &#125;        throw(&quot;读取连接数据库json失败！&quot;);        return false;    &#125; catch (exception&amp; e) &#123;        cout &lt;&lt; e.what() &lt;&lt; endl;        return false;    &#125;&#125;\n\n\n功能： 解析JSON配置文件。\n详解：\n打开dbconf.json文件，使用Reader解析JSON。\n从JSON中提取数据库连接的相关信息。\n\n\n\n生产连接 (ConnectionPool::produceConnection)：void ConnectionPool::produceConnection() &#123;    while (true) &#123;        unique_lock&lt;mutex&gt; locker(m_mutexQ);        while (m_connectionQ.size() &gt;= m_minSize) &#123;            m_cond.wait(locker);        &#125;        addConnection();        m_cond.notify_all();    &#125;&#125;\n\n\n功能： 生成新的数据库连接。\n详解：\n在连接池连接数不足时，生成新的数据库连接。\n使用addConnection添加连接到连接池。\n唤醒等待的消费者。\n\n\n\n回收连接 (ConnectionPool::recycleConnection)：void ConnectionPool::recycleConnection() &#123;    while (true) &#123;        this_thread::sleep_for(chrono::milliseconds(500));        lock_guard&lt;mutex&gt; locker(m_mutexQ);        while (m_connectionQ.size() &gt; m_minSize) &#123;            MySqlConnect* conn = m_connectionQ.front();            if (conn-&gt;getAliveTime() &gt;= m_maxIdleTime) &#123;                m_connectionQ.pop();                delete conn;            &#125; else &#123;                break;            &#125;        &#125;    &#125;&#125;\n\n\n功能： 回收空闲连接。\n详解：\n每隔一定时间检查连接池中的连接，将超过最大空闲时间的连接释放。\n通过sleep_for休息一段时间。\n\n\n\n添加连接 (ConnectionPool::addConnection)：void ConnectionPool::addConnection() &#123;    MySqlConnect* conn = new MySqlConnect;    conn-&gt;connect(m_user, m_passwd, m_dbName, m_ip, m_port);    conn-&gt;refreshAliveTime();    m_connectionQ.push(conn);&#125;\n\n\n功能： 添加新连接到连接池。\n详解：\n创建新的MySqlConnect对象，连接数据库。\n刷新连接的起始空闲时间。\n将连接添加到连接池队列中。\n\n\n\n获取连接 (ConnectionPool::getConnection)：shared_ptr&lt;MySqlConnect&gt; ConnectionPool::getConnection() &#123;    unique_lock&lt;mutex&gt; locker(m_mutexQ);    while (m_connectionQ.empty()) &#123;        if (cv_status::timeout == m_cond.wait_for(locker, chrono::milliseconds(m_timeout))) &#123;            if (m_connectionQ.empty()) &#123;                continue;            &#125;        &#125;    &#125;    shared_ptr&lt;MySqlConnect&gt; connptr(m_connectionQ.front(), [this](MySqlConnect* conn) &#123;        lock_guard&lt;mutex&gt; locker(m_mutexQ);        conn-&gt;refreshAliveTime();        m_connectionQ.push(conn);    &#125;);    m_connectionQ.pop();    m_cond.notify_all();    return connptr;&#125;\n\n\n功能： 获取数据库连接。\n详解：\n使用unique_lock上锁，保证线程安全。\n当连接池为空时，等待可用连接或超时。\n获取连接并返回其shared_ptr，使用lambda表达式在连接释放时刷新连接的起始空闲时间。\n唤醒等待的生产者线程。\n\n\n\nConnectionPool.h#pragma once// 连接池头文件#ifndef CONNECTIONPOOL_H#define CONNECTIONPOOL_H#include&lt;queue&gt;#include &quot;MySQLConnect.h&quot;#include &lt;mutex&gt; //C++ 独占的互斥锁#include &lt;condition_variable&gt; // 引用 C++ 条件变量using namespace std;// 连接池class ConnectionPool&#123;public:\t// 静态实例，通过静态方法获得唯一的单例对象\tstatic ConnectionPool* getConnectPool();\t// 删除掉构造函数\tConnectionPool(const ConnectionPool&amp; obj) = delete;\t// 移动赋值函数重载，删除掉，防止对象的复制\tConnectionPool&amp; operator =(const ConnectionPool&amp; obj)= delete;\t// 获取连接时返回一个可用的连接，返回共享的智能指针\tshared_ptr&lt;MySqlConnect&gt; getConnection();\t// 析构函数\t~ConnectionPool();private:\tConnectionPool();\t// 解析 JSON 文件的函数\tbool paraseJsonFile();\t// 用来生产数据库连接\tvoid produceConnection();\t\t// 用来销毁数据库连接 回收数据库连接\tvoid recycleConnection();\t// 添加连接\tvoid addConnection();\t// 数据库相关信息\t// 通过加载配置文件 Json，访问用户指定的数据库\t// 数据库 ip\tstring m_ip; \t// 数据库用户\tstring m_user;\t// 数据库密码\tstring m_passwd;\t// 数据库名称\tstring m_dbName;\t// 数据库访问端口\tunsigned short m_port;\t// 设置连接上限\tint m_minSize;\t// 设置连接的上限\tint m_maxSize;\t// 设置线程等待最大时长，单位毫秒\t// 超时时长\tint m_timeout; \t// 最大空闲时长单位毫秒\tint m_maxIdleTime;\t// 存储若干数据库连接队列\tqueue&lt;MySqlConnect*&gt; m_connectionQ;\t// 设置互斥锁\tmutex m_mutexQ;\t// 设置条件变量\tcondition_variable m_cond;&#125;;#endif // !CONNECTIONPOOL_H\n\nConnectionPool.cpp#include &quot;ConnectionPool.h&quot;#include &lt;json/json.h&gt;#include &lt;fstream&gt;#include &lt;mysql.h&gt;#include &lt;thread&gt; // 加载多线程using namespace Json;// 静态函数ConnectionPool* ConnectionPool::getConnectPool()&#123;    static ConnectionPool pool; // 静态局部对象，不管后面调用多少次，得到的都是同一块内存地址    return &amp;pool;&#125;// 打开数据库信息文件，并判断是否读取到相关信息bool ConnectionPool::paraseJsonFile()&#123;    try    &#123;        ifstream ifs(&quot;dbconf.json&quot;);        Reader rd;        Value root;        rd.parse(ifs, root);        if (root.isObject())        &#123;            m_ip = root[&quot;ip&quot;].asString();            m_port = root[&quot;port&quot;].asInt();            m_user = root[&quot;userName&quot;].asString();            m_passwd = root[&quot;password&quot;].asString();            m_dbName = root[&quot;dbName&quot;].asString();            m_minSize = root[&quot;minSize&quot;].asInt();            m_maxSize = root[&quot;maxSize&quot;].asInt();            m_maxIdleTime = root[&quot;maxIdlTime&quot;].asInt();            m_timeout = root[&quot;timeout&quot;].asInt();            return true;        &#125;        throw(&quot;读取连接数据库json失败！&quot;);        return false;    &#125;    catch (exception&amp; e)    &#123;        cout &lt;&lt; e.what() &lt;&lt; endl;    &#125;        &#125;// 子线程对应的任务函数，生成新的可用连接void ConnectionPool::produceConnection()&#123;    //    while (true)     &#123;        // 判断当前连接池是否够用        //uniuqe 模版类，mutex 互斥锁类型 locker 对象管理        unique_lock&lt;mutex&gt; locker(m_mutexQ);        while (m_connectionQ.size() &gt;= m_minSize)        &#123;            // 阻塞条件变量            m_cond.wait(locker);        &#125;        // 生产一个数据库连接        addConnection();        // 调用对应的唤醒函数，唤醒的所有消费者        m_cond.notify_all();    &#125;&#125;// 当空闲的链接数量过多void ConnectionPool::recycleConnection()&#123;    while (true)    &#123;        // 休息一段时间，每隔一秒种，进行一次检测        this_thread::sleep_for(chrono::milliseconds(500));        // 进行加锁        lock_guard&lt;mutex&gt;locker(m_mutexQ);        // 当大于最小连接数        while (m_connectionQ.size() &gt; m_minSize)        &#123;            // 先进后出            MySqlConnect* conn = m_connectionQ.front(); // 取出队头元素            // 判断队头元素存活时长是不是大于指定的最长存活时长            if (conn-&gt;getAliveTime() &gt;= m_maxIdleTime)            &#123;                m_connectionQ.pop(); // 将队头的链接销毁                delete conn;            &#125;            else            &#123;                break;            &#125;        &#125;    &#125;&#125;void ConnectionPool::addConnection()&#123;    MySqlConnect* conn = new MySqlConnect;    conn-&gt;connect(m_user, m_passwd, m_dbName, m_ip, m_port);    // 数据库连接之后就开始记录时间错    conn-&gt;refreshAliveTime();    m_connectionQ.push(conn);&#125;shared_ptr&lt;MySqlConnect&gt; ConnectionPool::getConnection()&#123;    // 封装互斥锁，保证线程安全    unique_lock&lt;mutex&gt; locker(m_mutexQ);    // 检查是否有可用的连接，如果没有阻塞一会    while (m_connectionQ.empty())    &#123;        if (cv_status::timeout == m_cond.wait_for(locker, chrono::milliseconds(m_timeout)))         &#123;            if (m_connectionQ.empty())            &#123;                continue;            &#125;        &#125;    &#125;    shared_ptr&lt;MySqlConnect&gt; connptr(m_connectionQ.front(), [this](MySqlConnect* conn)         &#123;            // 加锁            lock_guard&lt;mutex&gt; locker(m_mutexQ);           // 刷新起始空闲时间            conn-&gt;refreshAliveTime();               m_connectionQ.push(conn);        &#125;);    m_connectionQ.pop();    m_cond.notify_all();// 唤醒生产者    return connptr;&#125;// 线程池析构函数ConnectionPool::~ConnectionPool()&#123;    while (m_connectionQ.empty())    &#123;        MySqlConnect* conn = m_connectionQ.front();        m_connectionQ.pop();        delete conn;    &#125;&#125;// 构造函数的实现ConnectionPool::ConnectionPool()&#123;    // 加载配置文件    if (!paraseJsonFile())    &#123;        cout &lt;&lt; &quot;数据库连接失败&quot; &lt;&lt; endl;        return;    &#125;    // 初始化配置连接数    for (int i = 0; i &lt; m_minSize; ++i)  // 连接数    &#123;         // 如果队列总数小于最大数量        if (m_connectionQ.size() &lt; m_maxSize)        &#123;            // 实例化对象            MySqlConnect* conn = new MySqlConnect;            // 链接数据库            conn-&gt;connect(m_user, m_passwd, m_dbName, m_ip, m_port);            m_connectionQ.push(conn);        &#125;        // 当连接总数大于允许连接的最大数量        else        &#123;            cout &lt;&lt; &quot;当前连接数量以超过允许连接的总数&quot; &lt;&lt; endl;            break;        &#125;    &#125;    // 当前实例对象 this 指针，单例模式，    thread producer(&amp;ConnectionPool::produceConnection,this); // 生成线程池的连接    thread recycler(&amp;ConnectionPool::recycleConnection,this); // 有没有需要销毁的连接    /*    将 producer 线程与当前线程分离，使得它们可以独立执行，    */    // 主线程和子线程分离    producer.detach();    recycler.detach();&#125;\n\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"从零实现WebServer之日志类","url":"/2023/12/29/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0WebServer%E4%B9%8B%E6%97%A5%E5%BF%97%E7%B1%BB/","content":"从零实现WebServer之日志类阻塞队列模板类构造函数，初始化队列的最大容量，默认为1000block_queue(int max_size &#x3D; 1000);析构函数，清空队列~block_queue();清空队列void clear();判断队列是否已满bool full();判断队列是否为空bool empty();返回队首元素bool front(T &amp;item);返回队尾元素bool back(T &amp;item);获取队列当前元素个数int get_size();获取队列的最大容量int get_max_size();向队尾添加元素bool push_back(const T &amp;item);从队头弹出元素bool pop(T &amp;item);增加超时处理的pop函数bool pop(T &amp;item, int ms_timeout);\n\n\n#ifndef BLOCK_QUEUE_H#define BLOCK_QUEUE_H#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;sys/time.h&gt;#include &lt;deque&gt;#include &quot;../locker/locker.h&quot;using namespace std;// 阻塞队列模板类template &lt;class T&gt;class block_queue&#123;    public:    // block_queue类的构造函数用于初始化实例    block_queue(int max_size = 1000)&#123;        if(max_size &lt;= 0)&#123;            exit(-1);        &#125;        m_max_size = max_size;            &#125;    ~block_queue()&#123;        clear();    &#125;    // clear 函数通过互斥锁确保了对队列的操作是线程安全的    void clear()&#123;        m_mutex.lock();     // 加锁，确保在多线程环境中对队列的操作是互斥的        m_deque.clear();    // 清空队列，移除所有元素        m_mutex.unlock();   // 解锁，释放互斥锁，允许其他线程对队列进行操作    &#125;    bool full()&#123;        m_mutex.lock();        if(m_deque.size() &gt;= m_max_size)&#123;            m_mutex.unlock();   // 如果队列已满，解锁互斥锁            return true;        &#125;        m_mutex.unlock();        return false;    &#125;    bool empty()&#123;        m_mutex.lock();        if(m_deque.empty())            return true;        m_mutex.unlock();        return false;    &#125;    bool front(T &amp;item)&#123;        m_mutex.lock();        if(m_deque.empty())&#123;            m_mutex.unlock();            return false;        &#125;        item = m_deque.front();        m_mutex.unlock();        return true;    &#125;    bool back(T &amp;item)&#123;        m_mutex.lock();        if(m_deque.empty())&#123;            m_mutex.unlock();            return false;        &#125;        item = m_deque.back();        m_mutex.unlock();        return true;    &#125;    int get_size()&#123;        int temp = 0;        m_mutex.lock();        temp = m_deque.size();        m_mutex.unlock();        return temp;    &#125;    int get_max_size()&#123;        int temp = 0;        m_mutex.lock();        temp = m_max_size;        m_mutex.unlock();        return temp;    &#125;    bool push_back(const T &amp;item)&#123;        m_mutex.lock();     // 加锁，确保在多线程环境中对队列的操作是互斥的        if(m_deque.size() &gt;= m_max_size)&#123;   // 判断队列大小是否达到最大允许大小            m_cond.broadcast();     // 唤醒所有在条件变量上等待的线程            m_mutex.unlock();   // 解锁互斥锁            return false;       // 返回false，表示队列已满，无法添加元素        &#125;        m_deque.push_back(item);    // 向队列尾部添加元素        m_cond.broadcast(); // 唤醒所有在条件变量上等待的线程        m_mutex.unlock();   // 解锁互斥锁        return true;    &#125;    bool pop(T &amp;item)&#123;        m_mutex.lock();        while(m_deque.empty())&#123;     // 使用循环等待，直到队列非空            if(!m_cond.wait(m_mutex.get()))&#123;    // 如果条件变量等待失败                m_mutex.unlock();   // 解锁互斥锁                return false;            &#125;        &#125;        item = m_deque.front();        m_deque.pop_front();        m_mutex.unlock();        return true;    &#125;    // 增加超时处理    bool pop(T &amp;item, int ms_timeout) &#123;        struct timespec t = &#123;0, 0&#125;;  // s and ns        struct timeval now = &#123;0, 0&#125;; // s and ms        gettimeofday(&amp;now, nullptr);        m_mutex.lock();        if (m_size &lt;= 0) &#123;            t.tv_sec = now.tv_sec + ms_timeout / 1000;            t.tv_nsec = (ms_timeout % 1000) * 1000;     //使用超时参数 ms_timeout 计算出等待的超时时间            if (!m_cond.timewait(m_mutex.get(), t)) &#123;   // 等待超时处理                m_mutex.unlock();                return false;            &#125;        &#125;        item = m_deque.front();        m_deque.pop_front();        m_mutex.unlock();        return true;    &#125;private:    mutexlocker m_mutex;    // 互斥锁    condvar m_cond;         // 条件变量，用于在队列为空或队列已满时进行等待和唤醒    deque&lt;T&gt; m_deque;    int m_max_size;&#125;;#endif\n\n这个block_queue类是一个线程安全的阻塞队列实现，使用了互斥锁和条件变量来保证在多线程环境中的操作的互斥性和同步性。这个block_queue类适用于需要在多线程环境中进行数据共享的场景，提供了一种安全且高效的队列实现。\n\n线程安全性：通过使用mutexlocker和condvar实现了互斥锁和条件变量，确保多个线程对队列的并发操作是安全的。\n阻塞操作：在队列为空时，pop操作将会等待直到队列中有元素可供取出；在队列已满时，push_back操作将会等待直到队列中有空位可供插入。\n容量控制：通过full()和empty()方法提供了对队列是否已满或为空的判断。\n超时处理：pop操作提供了带有超时参数的版本，允许用户设定最长等待时间，避免无限等待。\n使用deque实现：底层使用了std::deque作为队列容器，相比于std::queue，std::deque允许从队列的前端和后端高效地进行元素的添加和删除。\n清空队列：提供了clear方法，用于清空队列并释放资源。\n异常处理：在构造函数中，如果指定的最大容量小于等于0，程序将终止，以防止非法输入。\n\n日志类流程图\n获取实例 get_instance // 公有静态方法，用于获取唯一的实例static Log* get_instance()&#123;    // 静态局部变量，确保只在第一次调用该函数时创建一个实例    static Log instance;    // 返回指向实例的指针    return &amp;instance;&#125;\n\n\nget_instance 是一个公有的静态成员函数，用于获取类的唯一实例。\nstatic Log instance; 是一个静态局部变量，确保在程序的整个生命周期内只有一个实例。这是C++11引入的线程安全的局部静态变量。\nreturn &amp;instance; 返回指向唯一实例的指针。\n\n构造函数 Logprivate:    Log();    ~Log();    // 防止复制构造和赋值操作，确保单例的唯一性    Log(const Log&amp;) = delete;    Log&amp; operator=(const Log&amp;) = delete;\n\n这是一个典型的单例模式实现，通过将构造函数和析构函数声明为私有的，以及禁用拷贝构造函数和赋值操作符，确保了类的单例性。这样，只能通过 get_instance 函数获取唯一的实例，而不能直接复制或赋值。\n\n构造函数和析构函数是私有的，防止外部直接实例化或销毁对象。\n拷贝构造函数和赋值操作符被删除，防止复制对象。\nget_instance 函数提供了获取类唯一实例的途径，同时在需要时进行实例化。\n\n异步写 async_write_log// 异步写    void async_write_log()&#123;        string single_log;        // 从阻塞队列取出一个日志        while(m_log_duque-&gt;pop(single_log))&#123;            m_mutex.lock();            // 写入后文件指针后移            fputs(single_log.c_str(),m_fp);            m_mutex.unlock();                &#125;    &#125;\n\n\nasync_write_log 函数通过阻塞队列 m_log_duque 获取一个日志条目 single_log。\n通过互斥锁 m_mutex 对文件指针 m_fp 进行保护，确保在多线程环境下对文件的写入操作是互斥的。\n使用 fputs(single_log.c_str(), m_fp); 将日志写入文件。这里假设 single_log 中已经包含了完整的日志内容，因为它是从阻塞队列中取出的。\n写入完成后解锁互斥锁，允许其他线程进行文件写入。\n\n需要注意的是，这个函数的执行是在一个独立的线程中进行的，通过异步写入的方式，避免了在主线程中直接写文件可能导致的性能问题。这种异步的方式允许主线程继续执行其他任务，而不必等待文件写入完成。\n// 线程工作函数，静态函数防止this指针static void* flush_log_thread(void *args)&#123;    Log::get_instance()-&gt;async_write_log();    return nullptr;&#125;\n\n\nflush_log_thread 是一个静态成员函数，它被设计为一个线程的入口函数，用于执行异步写日志的操作。\n静态函数中调用了 Log::get_instance()-&gt;async_write_log();，这样就通过单例模式获取了 Log 类的唯一实例，然后调用了 async_write_log 函数，实现了异步写日志的逻辑。\n函数返回 nullptr，这是符合线程入口函数的标准，即线程执行完毕后返回的是 nullptr。\n\n这段代码的目的是启动一个线程，用于在后台执行异步写日志的操作，从而不阻塞主线程的执行。在 Log 类的构造函数中，可以看到这个线程是在初始化时被创建的。该线程的生命周期和 Log 类的生命周期是一致的。当 Log 类的实例被销毁时，这个线程也应该被正确地终止。\n宏定义 snprintf_nowarn// 检查snprintf返回值，防止warning#define snprintf_nowarn(...) (snprintf(__VA_ARGS__) &lt; 0 ? abort() : (void)0)// 可变参数宏__VA_ARGS__，当可变参数个数为0时，##__VA_ARGS__把前面多余的“，”去掉#define LOG_DEBUG(format, ...) if(m_close_log == 0) &#123;Log::get_instance()-&gt;write_log(0, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_INFO(format, ...) if(m_close_log == 0) &#123;Log::get_instance()-&gt;write_log(1, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_WARN(format, ...) if(m_close_log == 0) &#123;Log::get_instance()-&gt;write_log(2, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_ERROR(format, ...) if(m_close_log == 0) &#123;Log::get_instance()-&gt;write_log(3, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;\n\n这段代码定义了一组宏，用于在日志中输出不同级别的日志信息。下面是对每个宏的解释：\n\nsnprintf_nowarn: 这是一个宏，用于检查 snprintf 的返回值，防止编译器产生警告。如果 snprintf 返回值小于 0，就调用 abort 终止程序，否则不进行任何操作。\nLOG_DEBUG(format, ...): 这是一个宏，用于输出调试级别的日志信息。如果 m_close_log 不为 0（即日志未关闭），则调用 Log::get_instance()-&gt;write_log(0, format, ##__VA_ARGS__) 写入调试日志，然后调用 Log::get_instance()-&gt;flush() 刷新日志。\nLOG_INFO(format, ...): 类似于 LOG_DEBUG，用于输出信息级别的日志。\nLOG_WARN(format, ...): 类似于 LOG_DEBUG，用于输出警告级别的日志。\nLOG_ERROR(format, ...): 类似于 LOG_DEBUG，用于输出错误级别的日志。\n\n这些宏的使用方式类似于普通的日志输出函数，但通过宏的方式可以方便地控制是否输出日志（通过 m_close_log 变量的值判断）。这样的设计可以在日志关闭时，避免不必要的字符串拼接和日志输出操作，提高程序性能。\n初始化日志 init// 初始化日志，异步需要设置阻塞队列的长度，同步不需要bool Log::init(const char *file_name, int log_buf_size, int split_lines, int max_queue_size)&#123;    // 如果设置了max_queue_size,则设置为异步    if(max_queue_size &gt;= 1)&#123;        m_is_async = true;        m_log_duque = new block_queue&lt;string&gt;(max_queue_size);        //创建线程异步写        pthread_t tid;        pthread_create(&amp;tid,nullptr,flush_log_thread,nullptr);    &#125;    // 初始化日志    m_log_buf_size = log_buf_size;    m_buf = new char[m_log_buf_size];    memset(m_buf,0,m_log_buf_size);    m_split_lines = split_lines;    // 获取当前时间    time_t t = time(nullptr);    struct tm *sys_tm = localtime(&amp;t);    struct tm my_tm = *sys_tm;    // 查找字符从右边开始第一次出现的位置，截断文件名    const char *p = strrchr(file_name,&#x27;/&#x27;);    char log_full_name[256] = &#123;0&#125;;    // 构造日志文件名    if(p == nullptr)&#123;        // 将可变参数格式化到字符串中        // 没有/则直接到当前路径下        snprintf_nowarn(log_full_name,255,&quot;%d_%02d_%02d_%s&quot;,my_tm.tm_year + 1900,my_tm.tm_mon+1,my_tm.tm_mday,file_name);    &#125;else&#123;        strcpy(log_name,p+1);   // 日志文件名        strncpy(dir_name,file_name,p-file_name+1);  // 日志路径        snprintf_nowarn(log_full_name,255,&quot;%s%d_%02d_%02d_%s&quot;,dir_name,my_tm.tm_year + 1900,my_tm.tm_mon+1,my_tm.tm_mday,log_name);    &#125;    m_today = my_tm.tm_mday;    // 追加写    m_fp = fopen(log_full_name,&quot;a&quot;);    if(m_fp == nullptr)        return false;    return true;&#125;\n\n这段 C++ 代码定义了日志类 Log 中的初始化函数 init。此函数用于初始化日志记录，包括设置日志文件名、缓冲区大小、拆分行数等参数。如果设置了异步模式，还会创建一个线程用于异步写日志。\n\n判断是否启用异步模式：\n\nif (max_queue_size &gt;= 1) &#123;    m_is_async = true;    m_log_duque = new block_queue&lt;string&gt;(max_queue_size);    // 创建线程异步写    pthread_t tid;    pthread_create(&amp;tid, nullptr, flush_log_thread, nullptr);&#125;\n\n如果设置了 max_queue_size 大于等于 1，表示启用异步模式。在异步模式下，创建了一个 block_queue&lt;string&gt; 类型的阻塞队列，并通过线程 pthread_create 创建了一个用于异步写日志的线程。\n\n初始化日志参数：\n\nm_log_buf_size = log_buf_size;m_buf = new char[m_log_buf_size];memset(m_buf, 0, m_log_buf_size);m_split_lines = split_lines;\n\n初始化日志缓冲区大小、拆分行数等参数。\n\n获取当前时间并构造日志文件名：\n\ntime_t t = time(nullptr);struct tm *sys_tm = localtime(&amp;t);struct tm my_tm = *sys_tm;const char *p = strrchr(file_name, &#x27;/&#x27;);char log_full_name[256] = &#123;0&#125;;\n\n获取当前时间，并通过 localtime 函数转换为本地时间。根据文件名中是否包含路径分隔符 /，构造日志文件名 log_full_name。\n\n设置日志文件名和路径：\n\nif (p == nullptr) &#123;    snprintf_nowarn(log_full_name, 255, &quot;%d_%02d_%02d_%s&quot;, my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, file_name);&#125; else &#123;    strcpy(log_name, p + 1);   // 日志文件名    strncpy(dir_name, file_name, p - file_name + 1);  // 日志路径    snprintf_nowarn(log_full_name, 255, &quot;%s%d_%02d_%02d_%s&quot;, dir_name, my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, log_name);&#125;\n\n根据文件名中是否包含路径分隔符 /，设置日志文件名和路径。如果没有路径分隔符，则直接在当前路径下创建日志文件。如果文件名中包含路径分隔符，首先使用 strcpy 将文件名部分（不包含 /）拷贝到 log_name 中。接着，使用 strncpy 将路径部分拷贝到 dir_name 中，注意这里复制的长度为 p - file_name + 1，确保包含路径分隔符。最后，使用 snprintf_nowarn 将路径和文件名组合成完整的日志文件名。\n\n打开日志文件：\n\nm_fp = fopen(log_full_name, &quot;a&quot;);if (m_fp == nullptr)    return false;\n\n使用 fopen 打开日志文件，以追加写入的方式打开。如果打开失败，则返回 false。\n写日志 write_log// 写日志void Log::write_log(int level, const char *format,...)&#123;    // 秒、微妙    struct timeval now = &#123;0,0&#125;;    gettimeofday(&amp;now,nullptr);    // 获取时间结构体    time_t t = now.tv_sec;    struct tm *sys_tm = localtime(&amp;t);    struct tm my_tm = *sys_tm;    // 临界区加锁    m_mutex.lock();    m_count++;    // 新的一天或者日志达到最大行数，需要更换日志文件    if(m_today != my_tm.tm_mday || m_count % m_split_lines == 0)&#123;        // 刷新文件缓冲并关闭文件        fflush(m_fp);        fclose(m_fp);        // 新日志路径        char new_log[256] = &#123;0&#125;;        char tail[16] = &#123;0&#125;;        snprintf_nowarn(tail,16,&quot;%d_%02d_%02d_&quot;,my_tm.tm_year + 1900,my_tm.tm_mon+1,my_tm.tm_mday);        // 天数变化        if(m_today != my_tm.tm_mday)&#123;            snprintf_nowarn(new_log,255,&quot;%s%s%s&quot;,dir_name,tail,log_name);            m_today = my_tm.tm_mday;            m_count = 0;        &#125;else&#123;  // 日志达到最大行数            snprintf_nowarn(new_log,255,&quot;%s%s%s.%lld&quot;,dir_name,tail,log_name,m_count / m_split_lines);        &#125;        // 打开新日志        m_fp = fopen(new_log,&quot;a&quot;);           &#125;    m_mutex.unlock();    // 日志级别    char s[16] = &#123;0&#125;;    switch(level)&#123;        case 0:             strcpy(s,&quot;[debug]:&quot;);            break;        case 1:            strcpy(s,&quot;[info]:&quot;);            break;        case 2:            strcpy(s,&quot;[warn]:&quot;);            break;        case 3:            strcpy(s,&quot;[error]:&quot;);            break;        default:           strcpy(s,&quot;[debug]:&quot;);            break;     &#125;    // 临界区加锁    m_mutex.lock();    // 构造日志内容、时间、级别    int n = snprintf(m_buf,48,&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s&quot;,                            my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday,                            my_tm.tm_hour,my_tm.tm_min,my_tm.tm_sec,now.tv_usec,s);    if(n &lt; 0)&#123;        abort();    &#125;    // 正文    va_list valst;    va_start(valst,format);    int m = vsnprintf(m_buf + n,m_log_buf_size -1, format, valst);    if(m &lt; 0)&#123;        abort();    &#125;    va_end(valst);    m_buf[n + m] = &#x27;\\n&#x27;;    m_buf[n + m + 1] = &#x27;\\0&#x27;;    // 异步写    if(m_is_async &amp;&amp; !m_log_duque-&gt;full())&#123;        m_log_duque-&gt;push_back(m_buf);    &#125;else&#123;  // 同步写        fputs(m_buf,m_fp);    &#125;    m_mutex.unlock();&#125;\n\n这段代码是 Log 类的写日志函数 write_log，它实现了日志的记录和切割功能。以下是对代码的详细解释：\n\n获取当前时间：\nstruct timeval now = &#123;0,0&#125;;gettimeofday(&amp;now,nullptr);time_t t = now.tv_sec;struct tm *sys_tm = localtime(&amp;t);struct tm my_tm = *sys_tm;\n\n使用 gettimeofday 获取当前时间（秒和微秒），然后将秒数转换为本地时间结构体 tm，保存在 my_tm 中。\n\n判断是否需要切换日志文件：\nm_mutex.lock();m_count++;if (m_today != my_tm.tm_mday || m_count % m_split_lines == 0) &#123;\n\n每次写入日志，都会判断当前日期是否与 m_today 相同，以及是否达到了日志的最大行数。如果是，则需要切换到新的日志文件。\n\n关闭并刷新当前日志文件，打开新日志文件：\nfflush(m_fp);fclose(m_fp);char new_log[256] = &#123;0&#125;;char tail[16] = &#123;0&#125;;\n\n先刷新和关闭当前的日志文件，然后构造新的日志文件名。如果是新的一天，直接拼接日期和文件名，如果是同一天但已达到最大行数，追加一个序号。\n\n构造新的日志文件路径：\nsnprintf_nowarn(tail,16,&quot;%d_%02d_%02d_&quot;,my_tm.tm_year + 1900,my_tm.tm_mon+1,my_tm.tm_mday);if (m_today != my_tm.tm_mday) &#123;    snprintf_nowarn(new_log,255,&quot;%s%s%s&quot;,dir_name,tail,log_name);    m_today = my_tm.tm_mday;    m_count = 0;&#125; else &#123;    snprintf_nowarn(new_log,255,&quot;%s%s%s.%lld&quot;,dir_name,tail,log_name,m_count / m_split_lines);&#125;\n\n使用 snprintf_nowarn 构造新的日志文件路径，并更新 m_today 和 m_count。\n\n打开新的日志文件：\nm_fp = fopen(new_log,&quot;a&quot;);\n\n使用 fopen 打开新的日志文件，以追加写入的方式。\n\n构造日志级别前缀：\nchar s[16] = &#123;0&#125;;switch(level)&#123;    // ...&#125;\n\n根据传入的日志级别（0: Debug, 1: Info, 2: Warn, 3: Error）选择对应的日志级别前缀。\n\n构造日志内容：\nint n = snprintf(m_buf,48,&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s&quot;,                  my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday,                        my_tm.tm_hour,my_tm.tm_min,my_tm.tm_sec,now.tv_usec,s);\n\n使用 snprintf 构造时间戳和日志级别前缀。\n\n构造日志正文：\nva_list valst;va_start(valst,format);int m = vsnprintf(m_buf + n,m_log_buf_size -1, format, valst);va_end(valst);\n\nva_list 是一个指向参数的列表的类型，用于存储可变参数信息。va_start 宏用于初始化 valst，使其指向参数列表中的第一个可变参数。第一个参数是 valst，第二个参数是可变参数列表的最后一个已知的固定参数。vsnprintf 是一个可变参数版本的 snprintf 函数，用于将格式化的数据写入字符串。这里，它将可变参数根据指定的 format 格式化并写入 m_buf 字符数组中，起始位置是 m_buf + n，最大写入长度是 m_log_buf_size - 1。使用 vsnprintf 将可变参数格式化成字符串，追加到之前的时间戳后。\n\n添加换行符和异步&#x2F;同步写入：\nm_buf[n + m] = &#x27;\\n&#x27;;m_buf[n + m + 1] = &#x27;\\0&#x27;;if(m_is_async &amp;&amp; !m_log_duque-&gt;full())&#123;    m_log_duque-&gt;push_back(m_buf);&#125;else&#123;    fputs(m_buf,m_fp);&#125;\n\n在字符串末尾添加换行符，并根据异步标志和队列是否满，选择是异步写入到阻塞队列还是同步写入到文件。最后，解锁临界区。\n\n\n这段代码完成了日志的记录、切割和写入功能，支持同步和异步两种写入模式。\n强制刷新文件缓冲 flush// 强制刷新文件缓冲void Log::flush(void)&#123;    m_mutex.lock();  // 加锁，确保在多线程环境中对文件缓冲的操作是互斥的    fflush(m_fp);    // 刷新文件缓冲，将缓冲区中的数据写入文件    m_mutex.unlock();  // 解锁，释放互斥锁，允许其他线程对文件缓冲进行操作&#125;\n\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"从零实现WebServer之线程同步机制包装类","url":"/2023/12/28/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0WebServer%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%8C%85%E8%A3%85%E7%B1%BB/","content":"从零实现WebServer之线程同步机制包装类信号量封装类初始化信号量\nint sem_init(sem_t *sem, int pshared, unsigned int value);\n  sem 信号量对象\n  pshared 不为0信号量在进程间共享，否则在当前进程的所有线程共享\n  value 信号量值大小\n  成功返回0，失败返回-1并设置errno\n原子操作V\nint sem_wait(sem_t *sem);\n  信号量不为0则-1，为0则阻塞\n  成功返回0，失败返回-1并设置errno\n原子操作P\nint sem_post(sem_t *sem);\n  信号量+1\n  成功返回0，失败返回-1并设置errno\n销毁信号量\nint sem_destroy(sem_t *sem);\n  成功返回0，失败返回-1并设置errno\n\n\n\n\nclass semaphore&#123;public:    // semaphore() 是默认构造函数，用于创建一个初始值为 0 的信号量    semaphore()&#123;        if(sem_init(&amp;m_sem,0,0) != 0)&#123;            throw std::exception();        &#125;    &#125;    // semaphore(int num) 是带参数的构造函数，用于创建一个初始值为 num 的信号量。    semaphore(int num)&#123;        if(sem_init(&amp;m_sem,0,num) != 0)&#123;            throw std::exception();        &#125;    &#125;    // 析构函数负责释放信号量占用的资源，调用 sem_destroy 函数    ~semaphore()&#123;        sem_destroy(&amp;m_sem);    &#125;    // 内部调用了 sem_wait 函数，该函数会使当前线程阻塞，直到信号量的值大于等于 1，然后将信号量的值减少    bool wait()&#123;        return sem_wait(&amp;m_sem) == 0;    &#125;    // 内部调用了 sem_post 函数，该函数将信号量的值增加    bool post()&#123;        return sem_post(&amp;m_sem)  == 0;    &#125;    private:    sem_t m_sem;&#125;;\n\n这段代码定义了一个名为semaphore的类，它实现了一个信号量（Semaphore）。信号量是一种用于多线程或多进程之间同步的机制，它可以用来控制对共享资源的访问。\n\n构造函数 semaphore() 和 semaphore(int num)：\nsemaphore() 是默认构造函数，用于创建一个初始值为 0 的信号量。\nsemaphore(int num) 是带参数的构造函数，用于创建一个初始值为 num 的信号量。\n在两个构造函数中，都调用了 sem_init 函数来初始化信号量。如果初始化失败（sem_init 返回非零值），则抛出 std::exception 异常。\n\n\n析构函数 ~semaphore()：\n析构函数负责释放信号量占用的资源，调用 sem_destroy 函数。\n\n\n成员函数 bool wait()：\nwait 函数用于等待信号量的值变为大于等于 1。如果调用成功，它返回 true；否则，返回 false。\n内部调用了 sem_wait 函数，该函数会使当前线程阻塞，直到信号量的值大于等于 1，然后将信号量的值减少。\nsem_wait 的作用是使调用线程阻塞，直到信号量的值大于等于 1。当信号量的值大于等于 1 时，sem_wait 将信号量的值减一，并立即返回。如果信号量的值已经是 0，那么 sem_wait 将阻塞调用线程，直到有其他线程调用了 sem_post 增加了信号量的值。\n\n\n成员函数 bool post()：\npost 函数用于增加信号量的值，表示资源可用。如果调用成功，它返回 true；否则，返回 false。\n内部调用了 sem_post 函数，该函数将信号量的值增加。\n\n\n私有成员 sem_t m_sem：\nm_sem 是一个 sem_t 类型的信号量变量，用于存储信号量的状态信息。\n\n\n\n这个类的目的是提供一个简单的接口，允许线程之间进行同步，通过 wait 和 post 函数来控制对共享资源的访问。使用信号量的一个常见场景是确保在多线程环境中对临界区（critical section）的互斥访问。\n互斥锁封装类初始化互斥锁\nint pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);\n  mutex 互斥锁对象\n  attr 互斥锁属性，默认普通锁\n  value信号量值大小\n  成功返回0\n加锁\nint pthread_mutex_lock (pthread_mutex_t *mutex);\n  请求锁线程形成等待序列，解锁后按优先级获得锁\n  成功返回0\n解锁\nint pthread_mutex_unlock (pthread_mutex_t *mutex);\n  成功返回0\n销毁互斥锁\nint pthread_mutex_destroy (pthread_mutex_t *mutex);\n  成功返回0\n\n\nclass mutexlocker&#123;public:    // 构造函数负责初始化互斥锁，使用 pthread_mutex_init 函数    mutexlocker()&#123;        if(pthread_mutex_init(&amp;m_mutex,NULL) != 0)&#123;            throw std::exception();        &#125;    &#125;    ~mutexlocker()&#123;        pthread_mutex_destroy(&amp;m_mutex);    &#125;    bool lock()&#123;        return pthread_mutex_lock(&amp;m_mutex) == 0;    &#125;    bool unlock()&#123;        return pthread_mutex_unlock(&amp;m_mutex) == 0;    &#125;    // get 函数返回指向互斥锁的指针，允许用户直接操作互斥锁    pthread_mutex_t* get()&#123;        return &amp;m_mutex;    &#125;private:    pthread_mutex_t m_mutex;&#125;;\n\n这段代码定义了一个名为 mutexlocker 的类，用于实现互斥锁（Mutex）。互斥锁是一种用于多线程之间同步的机制，它确保同时只有一个线程可以访问被保护的资源。\n\n构造函数 mutexlocker()：\n构造函数负责初始化互斥锁，使用 pthread_mutex_init 函数。\n如果初始化失败，即 pthread_mutex_init 返回非零值，那么抛出 std::exception 异常。\n\n\n析构函数 ~mutexlocker()：\n析构函数负责销毁互斥锁，使用 pthread_mutex_destroy 函数。\n\n\n成员函数 bool lock()：\nlock 函数用于获取互斥锁。如果调用成功，它返回 true；否则，返回 false。\n内部调用了 pthread_mutex_lock 函数，该函数会阻塞调用线程，直到成功获取互斥锁。\n\n\n成员函数 bool unlock()：\nunlock 函数用于释放互斥锁。如果调用成功，它返回 true；否则，返回 false。\n内部调用了 pthread_mutex_unlock 函数，该函数会释放互斥锁。\n\n\n成员函数 pthread_mutex_t\\* get()：\nget 函数返回指向互斥锁的指针，允许用户直接操作互斥锁。\n\n\n私有成员 pthread_mutex_t m_mutex：\nm_mutex 是一个 pthread_mutex_t 类型的互斥锁变量，用于存储互斥锁的状态信息。\n\n\n\n这个类的目的是提供一个简单的接口，允许线程对临界区进行互斥访问。通过 lock 和 unlock 函数，以及 get 函数，用户可以方便地操作互斥锁，确保在多线程环境中对共享资源的安全访问。在构造函数和析构函数中进行初始化和销毁操作，确保互斥锁的正确使用。\n条件变量封装类初始化条件变量\nint pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);\n  cv 条件变量对象\n  cattr 条件变量属性\n  成功返回0\n等待条件变量成立\nint pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex);\n  调用该函数时，线程总处于某个临界区，持有某个互斥锁\n  释放mutex防止死锁，阻塞等待唤醒，然后再获取mutex\n  成功返回0\n计时等待条件变量成立\nint pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *mutex, struct timespec *abstime);\n  成功返回0，超时返回ETIMEDOUT\n唤醒一个wait的线程\nint pthread_cond_signal(pthread_cond_t *cv);\n  成功返回0\n唤醒所有wait的线程\nint pthread_cond_broadcast(pthread_cond_t *cv);\n  成功返回0\n\n\nclass condvar&#123;public:    condvar()&#123;        if(pthread_cond_init(&amp;m_cond,NULL) != 0)&#123;            throw std::exception();        &#125;    &#125;    ~condvar()&#123;        pthread_cond_destroy(&amp;m_cond);    &#125;    // wait 函数用于将调用线程放入条件变量的请求队列，并解锁与给定互斥锁关联的临界区。    // 线程将被阻塞，直到其他某个线程调用 signal 或 broadcast 来唤醒它    bool wait(pthread_mutex_t *m_mutex)&#123;        return pthread_cond_wait(&amp;m_cond,m_mutex) == 0;    &#125;    // timewait 函数类似于 wait，但是可以设置超时时间，如果超过指定时间条件还未满足，线程将被唤醒    bool timewait(pthread_mutex_t * m_mutex, struct timespec t)&#123;        return pthread_cond_timedwait(&amp;m_cond,&amp;m_mutex,&amp;t) == 0;    &#125;    // signal 函数用于唤醒等待在条件变量上的一个线程。如果有多个线程在等待，只有其中一个会被唤醒    bool signal()&#123;        return pthread_cond_signal(&amp;m_cond) == 0;    &#125;    // broadcast 函数用于唤醒所有等待在条件变量上的线程    bool broadcast()&#123;        return pthread_cond_broadcast(&amp;m_cond) == 0;    &#125;private:    pthread_cond_t m_cond;&#125;;\n\n这段代码定义了一个名为 condvar 的类，用于实现条件变量（Condition Variable）。条件变量是一种线程同步的机制，它允许线程在某个条件成立之前等待，并在条件成立时被唤醒。\n\n构造函数 condvar()：\n构造函数负责初始化条件变量，使用 pthread_cond_init 函数。\n如果初始化失败，即 pthread_cond_init 返回非零值，那么抛出 std::exception 异常。\n\n\n析构函数 ~condvar()：\n析构函数负责销毁条件变量，使用 pthread_cond_destroy 函数。\n\n\n成员函数 bool wait(pthread_mutex_t \\*m_mutex)：\nwait 函数用于将调用线程放入条件变量的请求队列，并解锁与给定互斥锁关联的临界区。线程将被阻塞，直到其他某个线程调用 signal 或 broadcast 来唤醒它。\n返回值为 true 表示成功，false 表示出错。\n\n\n成员函数 bool timewait(pthread_mutex_t \\*m_mutex, struct timespec t)：\ntimewait 函数类似于 wait，但是可以设置超时时间，如果超过指定时间条件还未满足，线程将被唤醒。\n返回值为 true 表示成功，false 表示出错。\n\n\n成员函数 bool signal()：\nsignal 函数用于唤醒等待在条件变量上的一个线程。如果有多个线程在等待，只有其中一个会被唤醒。\n返回值为 true 表示成功，false 表示出错。\n\n\n成员函数 bool broadcast()：\nbroadcast 函数用于唤醒所有等待在条件变量上的线程。\n返回值为 true 表示成功，false 表示出错。\n\n\n私有成员 pthread_cond_t m_cond：\nm_cond 是一个 pthread_cond_t 类型的条件变量变量，用于存储条件变量的状态信息。\n\n\n\n这个类的目的是提供一个简单的接口，允许线程等待某个条件的发生，并在条件满足时被唤醒。通过 wait、timewait、signal 和 broadcast 函数，以及构造函数和析构函数的初始化和销毁操作，用户可以方便地使用条件变量来实现线程之间的同步。\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"从零实现WebServer之线程池类","url":"/2023/12/30/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0WebServer%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB/","content":"从零实现WebServer之线程池类流程图\n构造函数 threadpooltemplate &lt;typename T&gt;threadpool&lt;T&gt;::threadpool(int actor_model, connection_pool *connPoll, uint32_t thread_number, uint32_t max_request)    : m_actor_model(actor_model), m_connPool(connPoll), m_thread_number(thread_number), m_max_request(max_request) &#123;    if (thread_number &lt;= 0 || max_request &lt;= 0) &#123;        throw std::exception();    &#125;    m_threads = new pthread_t[m_thread_number];    if (!m_threads) &#123;        throw std::exception();    &#125;    for (uint32_t i = 0; i &lt; thread_number; i++) &#123;        // 内存单元、线程属性(NULL)、工作函数，传递参数（线程池）        if (pthread_create(m_threads + i, NULL, worker, this) != 0) &#123;            delete[] m_threads;            throw std::exception();        &#125;        // 分离主线程与子线程，子线程结束后资源自动回收        if (pthread_detach(m_threads[i]) != 0) &#123;            delete[] m_threads;            throw std::exception();        &#125;    &#125;&#125;\n\n在 threadpool 类的构造函数 threadpool::threadpool 中，进行了线程池的初始化工作。下面是对该函数的一些主要步骤的解释：\n\n成员初始化列表： 使用成员初始化列表初始化线程池的各个成员变量。\ntemplate &lt;typename T&gt;threadpool&lt;T&gt;::threadpool(int actor_model, connection_pool *connPool, uint32_t thread_number, uint32_t max_request)    : m_actor_model(actor_model), m_connPool(connPool), m_thread_number(thread_number), m_max_request(max_request) &#123;\n\n在初始化列表中，完成对成员变量 m_actor_model、m_connPool、m_thread_number、m_max_request 的初始化。\n\n线程标识符内存分配： 使用 new 运算符分配存储线程标识符的内存。\nm_threads = new pthread_t[m_thread_number];\n\n如果内存分配失败，抛出异常。\n\n创建工作线程： 使用 pthread_create 函数创建线程，将线程的入口函数设置为 worker。\nfor (uint32_t i = 0; i &lt; thread_number; i++) &#123;    if (pthread_create(m_threads + i, NULL, worker, this) != 0) &#123;        delete[] m_threads;        throw std::exception();    &#125;    // 分离主线程与子线程，子线程结束后资源自动回收    if (pthread_detach(m_threads[i]) != 0) &#123;        delete[] m_threads;        throw std::exception();    &#125;&#125;\n\n循环创建工作线程，将线程的入口函数设置为 worker，并传递当前线程池对象作为参数。同时，使用 pthread_detach 将子线程分离，使其在结束后自动释放资源。\n\n异常检查： 在函数执行过程中，进行异常检查，如果发生异常，释放已分配的资源。\nif (!m_threads) &#123;    throw std::exception();&#125;\n\n在最后，释放线程标识符的内存。\n\n\n该构造函数完成了线程池的初始化工作，包括成员变量的初始化、线程标识符的内存分配、工作线程的创建等。\n析构函数 ~threadpool// 析构，释放线程数组template &lt;typename T&gt;threadpool&lt;T&gt;::~threadpool()&#123;    delete[] m_threads;&#125;\n\n在 threadpool 类的析构函数 threadpool::~threadpool 中，进行了线程池的资源释放工作。\n释放线程标识符数组内存： 使用 delete[] 运算符释放动态分配的线程标识符数组内存。\ndelete[] m_threads;\n\n该步骤的目标是在线程池对象销毁时释放动态分配的线程数组内存，以防止内存泄漏。\n添加请求 append// 添加请求，并利用信号量通知工作线程template &lt;typename T&gt;bool threadpool&lt;T&gt;::append(T *request,int state)&#123;    // 任务队列是临界区，加互斥锁    m_queuelocker.lock();    if(m_workqueue.size() &gt;= m_max_request)&#123;        m_queuelocker.unlock();        return false;    &#125;    // 加入请求队列，然后解锁    request-&gt;m_state = state;    m_workqueue.push_back(request);    m_queuelocker.unlock();     // 增加信号量，表示有任务要处理    m_queuestat.post();    return true;&#125;\n\n在 threadpool 类的成员函数 threadpool::append 中，实现了向任务队列添加请求的操作。下面是对该函数的主要步骤的解释：\n\n加锁： 使用互斥锁 m_queuelocker 对任务队列进行加锁，确保多个线程访问任务队列时的互斥性。\nm_queuelocker.lock();\n\n检查任务队列是否已满： 判断当前任务队列的大小是否已经达到了最大请求数量 m_max_request。\nif (m_workqueue.size() &gt;= m_max_request) &#123;    m_queuelocker.unlock();    return false;&#125;\n\n如果队列已满，释放互斥锁并返回 false，表示添加请求失败。\n\n设置请求状态： 将传入的请求对象的状态设置为函数参数 state。\nrequest-&gt;m_state = state;\n\n加入请求队列： 将请求对象加入到任务队列中。\nm_workqueue.push_back(request);\n\n解锁： 释放互斥锁，允许其他线程访问任务队列。\nm_queuelocker.unlock();\n\n返回添加请求成功： 返回 true，表示成功添加请求。\n\n\n该函数的目标是向任务队列添加请求，并在保证线程安全的情况下进行操作。\n添加请求,不带状态// 添加请求，不带状态template &lt;typename T&gt;bool threadpool&lt;T&gt;::append_p(T *request)&#123;    m_queuelocker.lock();    if(m_workqueue.size() &gt;= m_max_request)&#123;        m_queuelocker.unlock();        return false;    &#125;    m_workqueue.push_back(request);    m_queuelocker.unlock();    m_queuestat.post();    return true;&#125;\n\n在 threadpool 类的成员函数 threadpool::append_p 中，实现了向任务队列添加请求的操作，不带状态。以下是该函数的主要步骤解释：\n\n加锁： 使用互斥锁 m_queuelocker 对任务队列进行加锁，确保多个线程访问任务队列时的互斥性。\nm_queuelocker.lock();\n\n检查任务队列是否已满： 判断当前任务队列的大小是否已经达到了最大请求数量 m_max_request。\nif (m_workqueue.size() &gt;= m_max_request) &#123;    m_queuelocker.unlock();    return false;&#125;\n\n如果队列已满，释放互斥锁并返回 false，表示添加请求失败。\n\n加入请求队列： 将请求对象加入到任务队列中。\nm_workqueue.push_back(request);\n\n解锁： 释放互斥锁，允许其他线程访问任务队列。\nm_queuelocker.unlock();\n\n通知工作线程： 使用信号量 m_queuestat 发送信号，通知工作线程有新的请求可以处理。\nm_queuestat.post();\n\n返回添加请求成功： 返回 true，表示成功添加请求。\n\n\n该函数的目标是向任务队列添加请求，并在保证线程安全的情况下进行操作。\n工作线程 worker// 工作线程运行template &lt;typename T&gt;void* threadpool&lt;T&gt;::worker(void *arg)&#123;    // 转换为线程池类    threadpool *pool = (threadpool *)arg;    pool-&gt;run();    return nullptr;&#125;\n\n在 threadpool 类的静态成员函数 threadpool::worker 中，实现了工作线程的运行。以下是该函数的主要步骤解释：\n\n类型转换： 将传入的 void* 类型参数 arg 转换为 threadpool* 类型，以便访问线程池对象的成员函数。\nthreadpool *pool = (threadpool *)arg;\n\n调用线程池的 run 函数： 调用线程池对象的 run 函数，开始执行工作线程的任务。\npool-&gt;run();\n\n返回空指针： 由于 pthread_create 函数要求线程函数的返回类型为 void*，因此返回 nullptr。\nreturn nullptr;\n\n该静态成员函数的目标是作为线程函数，在工作线程中调用线程池对象的 run 函数，执行具体的任务。\n工作函数 run// 工作函数template &lt;typename T&gt;void threadpool&lt;T&gt;::run()&#123;    while(true)&#123;        // 信号量阻塞，等待任务        m_queuestat.wait();        // 请求队列临界区，加互斥锁        m_queuelocker.lock();        if(m_workqueue.empty())&#123;            m_queuelocker.unlock();            continue;        &#125;        // 从请求队列取第一个请求        T *request = m_workqueue.front();        m_workqueue.pop_front();        m_queuelocker.unlock();        if(!request)            continue;        // reactor        if(m_actor_model == 1)&#123;            // 读            if(request-&gt;m_state == 0)&#123;                if(request-&gt;read_once())&#123;                    request-&gt;improv = 1;                    connectionRAII mysqlcon(&amp;request-&gt;mysql, m_connPool);                    request-&gt;process();                &#125;                else&#123;                    request-&gt;improv = 1;                    request-&gt;timer_flag = 1;                &#125;            &#125;            // 写            else&#123;                if(request-&gt;write())&#123;                    request-&gt;improv = 1;                &#125;                else&#123;                    request-&gt;improv = 1;                    request-&gt;timer_flag = 1;                &#125;            &#125;        &#125;        // proactor        else&#123;            // 从连接池中取出一个数据库连接 RAII            connectionRAII mysqlcon(&amp;request-&gt;mysql, m_connPool);            // 处理请求            request-&gt;process();        &#125;    &#125;&#125;\n\n在 threadpool 类的成员函数 threadpool::run 中，实现了工作线程的具体任务执行。以下是该函数的主要步骤解释：\n\n信号量等待： 使用信号量 m_queuestat 进行阻塞等待，等待任务的到来。\nm_queuestat.wait();\n\n请求队列操作： 进入临界区，加互斥锁，检查请求队列是否为空。\nm_queuelocker.lock();if(m_workqueue.empty())&#123;    m_queuelocker.unlock();    continue;&#125;\n\n取出请求： 如果请求队列非空，从队列头取出第一个请求，并在请求队列中移除。\nT *request = m_workqueue.front();m_workqueue.pop_front();m_queuelocker.unlock();\n\n处理请求： 检查请求是否为空，如果为空则继续循环。根据线程池的处理模式（reactor 或 proactor）执行不同的处理逻辑。\n\nReactor 模式：\n如果请求是读操作（m_state == 0），调用 read_once 函数执行一次读操作，然后创建数据库连接 connectionRAII 对象，执行请求的处理函数 process。\n如果请求是写操作，调用 write 函数执行一次写操作。\n\n\n\nif(!request)    continue;if(m_actor_model == 1)&#123;    if(request-&gt;m_state == 0)&#123;        // 读操作        if(request-&gt;read_once())&#123;            request-&gt;improv = 1;            connectionRAII mysqlcon(&amp;request-&gt;mysql, m_connPool);            request-&gt;process();        &#125;        else&#123;            request-&gt;improv = 1;            request-&gt;timer_flag = 1;        &#125;    &#125;    // 写操作    else&#123;        if(request-&gt;write())&#123;            request-&gt;improv = 1;        &#125;        else&#123;            request-&gt;improv = 1;            request-&gt;timer_flag = 1;        &#125;    &#125;&#125;\n\n\nProactor 模式：\n创建数据库连接 connectionRAII 对象，执行请求的处理函数 process。\n\n\n\nelse&#123;    // Proactor 模式    connectionRAII mysqlcon(&amp;request-&gt;mysql, m_connPool);    request-&gt;process();&#125;\n\n循环继续： 任务处理完成后，继续循环，等待下一个任务的到来。\n\n\n该函数的目标是作为工作线程的执行函数，不断从请求队列中取出请求并执行相应的操作。具体的操作依赖于线程池的处理模式（Reactor 或 Proactor）。\n其他线程池手写线程池 | Mzy’s Blog (dybil.top)\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"信号量和互斥锁有什么区别","url":"/2023/11/23/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","content":"信号量和互斥锁有什么区别信号量用于线程的同步，互斥锁用于线程的互斥。\n信号量值可以为非负整数，互斥锁值只能为0&#x2F;1。\n信号量可以由一个线程释放，另一个线程得到，互斥锁的加锁和解锁必须由同一线程分别对应使用。\n信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这个资源。\n","categories":["每日一题"],"tags":["c++"]},{"title":"使用Qt开发工作上的需求","url":"/2023/10/26/%E4%BD%BF%E7%94%A8Qt%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E4%B8%8A%E7%9A%84%E9%9C%80%E6%B1%82/","content":"记录最近工作设及到一些关于qt编程的相关内容\n\n\n功能1：鼠标点击图片显示坐标和像素最近工作设及到一些关于qt编程的工作，主要内容就是在一个QGraphicsView上显示了一个QGraphicsPixmapItem的相机监控的图片，并用鼠标点击图片显示坐标和像素。\n最初在网上找到的解决方案是重写mousePressEvent()方法\nvoid ImgHelper::mousePressEvent(QGraphicsSceneMouseEvent* event)&#123;    std::cout &lt;&lt; &quot;Item: (&quot; &lt;&lt; event-&gt;scenePos().x() &lt;&lt; &quot;, &quot; &lt;&lt; event-&gt;scenePos().y() &lt;&lt; &#x27;)&#x27; &lt;&lt; std::endl; &#125;\n\n测试发现未响应鼠标事件，网上找到说：重写鼠标点击事件函数时发现鼠标点击事件在子类化后的QGraphicsScene中被响应，但是子类化后的QGraphicsPixmapItem无法响应。QGraphicsView的事件传递机制的顺序是View-&gt;Scene-&gt;Item，也就是说事件被子类化的QGraphicsScene吞没了，没有传递到下一级的item。解决方案，在子类化的QGraphicsScene中重写mousePressEvent()方法内部一定要要记得调用：\nQGraphicsScene::mousePressEvent(event);\n\n注意，要想返回图像坐标系的位置，就需要在子类化的QGraphicsPixmapItem中调用scenePos()函数。即使放大图像，点击图像中相同位置也会返回相同坐标结果。\n结果发现还是没有反应，还有一种说法就是加上下面这句话\n//使能QGraphcisView控件的鼠标跟踪view-&gt;setMouseTracking(true);\n\n最后尝试把mousePressEvent函数在最上层的mainwindow中重写并使能鼠标，有效果，但是坐标并不是我想要的效果，现在的坐标系是整个界面的，我想要的是图像的坐标，然后能通过图像控件的位置和长宽进行筛选，但是获得的图像是经过qt自适应缩放在600X600的容器里的。\n在一筹莫展的时候，突然看到eventFilter事件过滤器。\n\n原本事件应该直接发送给“组件对象”，但是现在却先将事件发送给“过滤器对象”，经过过滤的事件再发给“组件对象”。\n事件过滤器的操作：\n\n首先给需要添加事件过滤器的部件注册监听对象；对象名-&gt;installEventFilter(true);\n重写eventFilter(QObject *obj, QEvent *event)函数进行处理。\n首先使用参数obj进行与绑定的控件对象进行判断，是否与其相等；然后在使用参数event-&gt;type()的返回值与枚举鼠标或者键盘进行判断；最后将event转换为鼠标事件对象或者键盘对象事件，就可以进行操作了。\n\nbool ImgHelper::eventFilter(QObject *watched, QEvent *event)&#123;    //判断信号是不是来自QGraphicsView    if(watched == view-&gt;viewport())&#123;        switch (event-&gt;type()) &#123;        //鼠标移动事件        case  QEvent::MouseMove:        &#123;            QMouseEvent *m_event = (QMouseEvent*)event;            if(pixmapItem == NULL)&#123;                break;            &#125;           // QPoint point = m_event-&gt;pos();            QPixmap pix= pixmapItem-&gt;pixmap();            QImage img = pix.toImage();          //  QSize size = pixmapItem-&gt;pixmap().size();            QPoint point = m_event-&gt;pos();           // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;            // 坐标系转换 - 视图 -&gt; 场景            QPointF scenePoint = view-&gt;mapToScene(point);            //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;            // 坐标系转换 - 场景 -&gt; 图元            QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);           // qDebug()&lt;&lt;&quot;itempoint:&quot;&lt;&lt;itempoint&lt;&lt;endl;            QString str;            // 判断所选点是否在图像范围内            if(itempoint.x()&gt;=0 &amp;&amp;itempoint.x()&lt;=pix.width() &amp;&amp; itempoint.y()&gt;=0 &amp;&amp; itempoint.y()&lt;= pix.height())&#123;                QRgb pixColor = img.pixel(itempoint.x(),itempoint.y());               // qDebug()&lt;&lt;pixColor&lt;&lt;&quot; &quot;&lt;&lt;qRed(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qGreen(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qBlue(pixColor)&lt;&lt;endl;                str = QString(&quot;X:%1\\nY:%2\\nR:%3\\nG:%4\\nB:%5\\n&quot;).arg(QString::number(itempoint.x(),&#x27;f&#x27;,1))                                                                .arg(QString::number(itempoint.y(),&#x27;f&#x27;,1))                                                                .arg(qRed(pixColor))                                                                .arg(qGreen(pixColor))                                                                .arg(qBlue(pixColor)).toLocal8Bit();            &#125;            else&#123;                str = &quot;&quot;;            &#125;            img_xy_pix-&gt;setText(str);            img_xy_pix-&gt;setStyleSheet(&quot;color:red;&quot;);            break;        &#125;        // 鼠标点击事件        case QEvent::MouseButtonPress:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            // 左键点击确定起点            if(m_event-&gt;button() == Qt::LeftButton )&#123;             //   QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                startPoint = itempoint;                break;            &#125;            break;        &#125;        // 送开鼠标，确定终点        case QEvent::MouseButtonRelease:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            if(m_event-&gt;button() == Qt::LeftButton )&#123;//                QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                QPointF endPoint = itempoint;                if(startPoint.x() != 0 &amp;&amp; startPoint.y() != 0)&#123;                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());                    painter.drawRect(rectangle);                    painter.setPen(QPen(Qt::red,1));                    rects = scene-&gt;addRect(rectangle,rectPen);//                    float rectInfo[8];//                    rectcounts++;//                    rectInfo[0] = rectcounts;//                    float x = (endPoint.x()-startPoint.x()) / 2 + startPoint.x();//                    float y = (endPoint.y()-startPoint.y()) / 2 + startPoint.y();//                    float height;//                    float width;//                    if(endPoint.x()-startPoint.x() &gt; endPoint.y()-startPoint.y())&#123;//                       height = endPoint.x()-startPoint.x();//                       width = endPoint.y()-startPoint.y();//                    &#125;else&#123;//                        width = endPoint.x()-startPoint.x();//                        height = endPoint.y()-startPoint.y();//                    &#125;                 //   rectInfo[1] = x;                 //   rectInfo[2] = y;                 //   rectInfo[3] = height;                 //      rectInfo[4] = width;                  //  float angle = -90;                 //   rectInfo[5] = angle;//                    CassUdpHelper* udpClient = new CassUdpHelper(localPort, this);                    //                     bool flag = false;  //                    int rectCountsAddr = 353345520;//                    flag = udpClient-&gt;writeBytesByModbus(rectCountsAddr, (char*)&amp;rectcounts, sizeof(short), hostIpAddr, hostPort);//                    if(!flag) &#123;//                        delete udpClient;//                         break;//                    &#125;//                    int startAddr = 427778712;//                    flag = udpClient-&gt;writeBytesByModbus(startAddr + sizeof(float)*8 *(rectcounts - 1), (char*)rectInfo, sizeof(float)*8, hostIpAddr, hostPort);//                    if(!flag) &#123;//                        delete udpClient;//                         break;//                    &#125;//                    delete udpClient;                                    &#125;                break;            &#125;            break;        &#125;        default:            break;        &#125;    &#125;    return false;&#125;\n\n功能2：Qt拖动鼠标画一个矩形想要画一个矩形就需要过滤鼠标点击事件，鼠标按下时确定矩形的起点，然后拖动一段距离，松开确定终点。\n\n// 鼠标点击事件        case QEvent::MouseButtonPress:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            // 左键点击确定起点            if(m_event-&gt;button() == Qt::LeftButton )&#123;             //   QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                startPoint = itempoint;                break;            &#125;            break;        &#125;        // 送开鼠标，确定终点        case QEvent::MouseButtonRelease:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            if(m_event-&gt;button() == Qt::LeftButton )&#123;//                QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                QPointF endPoint = itempoint;                if(startPoint.x() != 0 &amp;&amp; startPoint.y() != 0)&#123;                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());                    painter.drawRect(rectangle);                    painter.setPen(QPen(Qt::red,1));                    rects = scene-&gt;addRect(rectangle,rectPen);\n\n这是在网上看到其他人重写的一个QGraphicsRectItem类，画出来的矩形可以拖动，变形，旋转，使用时只需要导入这个类\n\nmygraphicrectitem.h\n\n#ifndef MYGRAPHICRECTITEM_H#define MYGRAPHICRECTITEM_H#include &lt;QObject&gt;#include &lt;QWidget&gt;#include &lt;QMouseEvent&gt;#include &lt;QGraphicsScene&gt;#include &lt;QGraphicsRectItem&gt;#include &lt;QGraphicsSceneMouseEvent&gt;#include &lt;QRect&gt;#include &lt;QPainter&gt;#include &lt;QPolygon&gt;#include &lt;QList&gt;enum STATE_FLAG&#123;    DEFAULT_FLAG=0,    MOV_LEFT_LINE,//标记当前为用户按下矩形的左边界区域    MOV_TOP_LINE,//标记当前为用户按下矩形的上边界区域    MOV_RIGHT_LINE,//标记当前为用户按下矩形的右边界区域    MOV_BOTTOM_LINE,//标记当前为用户按下矩形的下边界区域    MOV_RIGHTBOTTOM_RECT,//标记当前为用户按下矩形的右下角    MOV_RECT,//标记当前为鼠标拖动图片移动状态    ROTATE//标记当前为旋转状态&#125;;class myGraphicRectItem:public QObject,public QGraphicsItem&#123;    Q_OBJECTpublic:    myGraphicRectItem(QGraphicsItem *parent = nullptr);    //myGraphicRectItem(QRectF m_OriginRect = QRectF(0,0,100,100));    QRectF  boundingRect() const;    ~myGraphicRectItem();    void setRectSize(QRectF mrect,bool bResetRotateCenter = true);    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);    void mousePressEvent(QGraphicsSceneMouseEvent *event);    void mouseMoveEvent(QGraphicsSceneMouseEvent *event);    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);    void SetRotate(qreal RotateAngle,QPointF ptCenter=QPointF(-999,-999));    QPointF getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle);//获取旋转后的点    QList&lt;QPointF&gt; getRotatePoints(QPointF ptCenter,QList&lt;QPointF&gt; ptIns,qreal angle);//获取多个旋转后的点    QPolygonF getRotatePolygonFromRect(QPointF ptCenter,QRectF rectIn,qreal angle);//将矩形旋转之后返回多边形    QRectF getCrtPosRectToSceen();    QRectF m_SmallRotateRect;//矩形顶部用来表示旋转的标记的矩形    QPolygonF m_SmallRotatePolygon;//矩形顶部用来表示旋转的标记的矩形旋转后形成的多边形    QPointF getSmallRotateRectCenter(QPointF ptA,QPointF ptB);//获取旋转时候矩形正上方的旋转标记矩形    QRectF  getSmallRotateRect(QPointF ptA,QPointF ptB);    bool    m_bRotate;    qreal   m_RotateAngle;    QPointF m_RotateCenter;private:    QRectF  m_oldRect;    QPolygonF m_oldRectPolygon;    QRectF  m_RotateAreaRect;    bool    m_bResize;    QPolygonF m_insicedPolygon;    QRectF  m_insicedRectf;    QPolygonF m_leftPolygon;    QRectF  m_leftRectf;    QPolygonF m_topPolygon;    QRectF  m_topRectf;    QPolygonF m_rightPolygon;    QRectF  m_rightRectf;    QPolygonF m_bottomPolygon;    QRectF  m_bottomRectf;//    QPolygonF m_rbPolygon;//    QRectF  m_rbRectf;    QPointF m_startPos;    STATE_FLAG m_StateFlag;    QPointF *pPointFofSmallRotateRect;protected:&#125;;#endif // MYGRAPHICRECTITEM_H\n\nmygraphicrectitem.cpp\n\n#include &quot;mygraphicrectitem.h&quot;#include &lt;QtMath&gt;#include &lt;QDebug&gt;myGraphicRectItem::myGraphicRectItem(QGraphicsItem *parent):    m_bResize(false),    m_oldRect(0,0,100,100),    m_bRotate(false),    m_RotateAngle(0),    m_StateFlag(DEFAULT_FLAG)&#123;    //setParent(parent);    setRectSize(m_oldRect);    setToolTip(&quot;Click and drag me!&quot;);  //提示    setCursor(Qt::ArrowCursor);   //改变光标形状,手的形状    setFlag(QGraphicsItem::ItemIsMovable);    //    setAcceptDrops(true);    pPointFofSmallRotateRect = new QPointF[4];    SetRotate(0);    setFlag(QGraphicsItem::ItemIsSelectable);//&#125;QRectF myGraphicRectItem::boundingRect() const&#123;    //return m_oldRectPolygon.boundingRect();    QRectF boundingRectF = m_oldRectPolygon.boundingRect();    return QRectF(boundingRectF.x()-40,boundingRectF.y()-40,boundingRectF.width()+80,boundingRectF.height()+80);&#125;myGraphicRectItem::~myGraphicRectItem()&#123;    delete []pPointFofSmallRotateRect;    pPointFofSmallRotateRect = nullptr;&#125;void myGraphicRectItem::setRectSize(QRectF mrect, bool bResetRotateCenter)&#123;    m_oldRect = mrect;    if(bResetRotateCenter)    &#123;        m_RotateCenter.setX(m_oldRect.x()+m_oldRect.width()/2);        m_RotateCenter.setY(m_oldRect.y()+m_oldRect.height()/2);    &#125;    m_oldRectPolygon = getRotatePolygonFromRect(m_RotateCenter,m_oldRect,m_RotateAngle);    m_insicedRectf = QRectF(m_oldRect.x()+8,m_oldRect.y()+8,m_oldRect.width()-16,m_oldRect.height()-16);    m_insicedPolygon =getRotatePolygonFromRect(m_RotateCenter,m_insicedRectf,m_RotateAngle);    m_leftRectf = QRectF(m_oldRect.x(),m_oldRect.y(),8,m_oldRect.height()-8);    m_leftPolygon = getRotatePolygonFromRect(m_RotateCenter,m_leftRectf,m_RotateAngle);    m_topRectf = QRectF(m_oldRect.x()+8,m_oldRect.y(),m_oldRect.width()-8,8);    m_topPolygon = getRotatePolygonFromRect(m_RotateCenter,m_topRectf,m_RotateAngle);    m_rightRectf = QRectF(m_oldRect.right()-8,m_oldRect.y()+8,8,m_oldRect.height()-16);    m_rightPolygon = getRotatePolygonFromRect(m_RotateCenter,m_rightRectf,m_RotateAngle);    m_bottomRectf = QRectF(m_oldRect.x(),m_oldRect.bottom()-8,m_oldRect.width()-8,8);    m_bottomPolygon = getRotatePolygonFromRect(m_RotateCenter,m_bottomRectf,m_RotateAngle);//    m_rbRectf = QRectF(m_oldRect.right()-8,m_oldRect.bottom()-8,8,8);//    m_rbPolygon = getRotatePolygonFromRect(m_RotateCenter,m_rbRectf,m_RotateAngle);    m_SmallRotateRect = getSmallRotateRect(mrect.topLeft(),mrect.topRight());//矩形正上方的旋转标记矩形    m_SmallRotatePolygon = getRotatePolygonFromRect(m_RotateCenter,m_SmallRotateRect,m_RotateAngle);&#125;void myGraphicRectItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123;    QPen mPen = QPen(Qt::yellow);    painter-&gt;setPen(mPen);    //绘制旋转后的矩形    painter-&gt;drawPolygon(m_oldRectPolygon);    //绘制旋转圆形    mPen.setWidth(2);    mPen.setColor(Qt::green);    painter-&gt;setPen(mPen);    QPointF pf = getSmallRotateRectCenter(m_oldRectPolygon[0],m_oldRectPolygon[1]);    QRectF rect = QRectF(pf.x()-10,pf.y()-10,20,20);    painter-&gt;drawEllipse(rect);//绘制圆形    painter-&gt;drawPoint(pf);//绘制点&#125;void myGraphicRectItem::mousePressEvent(QGraphicsSceneMouseEvent *event)&#123;    if(event-&gt;button()== Qt::LeftButton)    &#123;        m_startPos = event-&gt;pos();//鼠标左击时，获取当前鼠标在图片中的坐标，        if(m_SmallRotatePolygon.containsPoint(m_startPos,Qt::WindingFill))//旋转矩形        &#123;            setCursor(Qt::PointingHandCursor);            m_StateFlag = ROTATE;        &#125;        else if(m_insicedPolygon.containsPoint(m_startPos,Qt::WindingFill))//在矩形内框区域时按下鼠标，则可拖动图片        &#123;            setCursor(Qt::ClosedHandCursor);   //改变光标形状,手的形状            m_StateFlag = MOV_RECT;//标记当前为鼠标拖动图片移动状态        &#125;        else if(m_leftPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeHorCursor);            m_StateFlag = MOV_LEFT_LINE;//标记当前为用户按下矩形的左边界区域        &#125;        else if(m_rightPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeHorCursor);            m_StateFlag = MOV_RIGHT_LINE;//标记当前为用户按下矩形的右边界区域        &#125;        else if(m_topPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeVerCursor);            m_StateFlag = MOV_TOP_LINE;//标记当前为用户按下矩形的上边界区域        &#125;        else if(m_bottomPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeVerCursor);            m_StateFlag = MOV_BOTTOM_LINE;//标记当前为用户按下矩形的下边界区域        &#125;//        else if(m_rbPolygon.containsPoint(m_startPos,Qt::WindingFill))//        &#123;//            setCursor(Qt::SizeFDiagCursor);//            m_StateFlag = MOV_RIGHTBOTTOM_RECT;//标记当前为用户按下矩形的右下角//        &#125;        else        &#123;            m_StateFlag = DEFAULT_FLAG;        &#125;    &#125;    else    &#123;        QGraphicsItem::mousePressEvent(event);    &#125;&#125;void myGraphicRectItem::mouseMoveEvent(QGraphicsSceneMouseEvent *event)&#123;    if(m_StateFlag == ROTATE)    &#123;       int nRotateAngle = atan2((event-&gt;pos().x()-m_RotateCenter.x()),(event-&gt;pos().y()-m_RotateCenter.y()))*180/M_PI;       SetRotate(180-nRotateAngle);       setRectSize(m_oldRect);       //qDebug()&lt;&lt;nRotateAngle;    &#125;    else if(m_StateFlag == MOV_RECT)    &#123;        QPointF point = (event-&gt;pos() - m_startPos);        moveBy(point.x(), point.y());        setRectSize(m_oldRect);        scene()-&gt;update();    &#125;    else if(m_StateFlag == MOV_LEFT_LINE)    &#123;        QPointF pf = QPointF((m_oldRectPolygon.at(1).x()+m_oldRectPolygon.at(2).x())/2,((m_oldRectPolygon.at(1).y()+m_oldRectPolygon.at(2).y())/2));        //计算到右侧边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2RT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));        if(dis&lt;16||dis2LT&gt;dis2RT)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setLeft(m_oldRect.right()-dis);            newRect.setRight(m_oldRect.right());            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;    else if(m_StateFlag == MOV_TOP_LINE)    &#123;        //底边中点        QPointF pf = QPointF((m_oldRectPolygon.at(2).x()+m_oldRectPolygon.at(3).x())/2,((m_oldRectPolygon.at(2).y()+m_oldRectPolygon.at(3).y())/2));        //计算到底边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2LB = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));        if(dis&lt;16||dis2LT&gt;dis2LB)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setTop(m_oldRect.bottom()-dis);            newRect.setBottom(m_oldRect.bottom());            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;    else if(m_StateFlag == MOV_RIGHT_LINE)    &#123;        QPointF pf = QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(3).x())/2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(3).y())/2));        //计算到左侧边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2RT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));        if(dis&lt;16||dis2LT&lt;dis2RT)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setLeft(m_oldRect.left());            newRect.setRight(m_oldRect.left()+dis);            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;    else if(m_StateFlag == MOV_BOTTOM_LINE)    &#123;        //顶边中点        QPointF pf = QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(1).x())/2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(1).y())/2));        //计算到底边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2LB = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));        if(dis&lt;16||dis2LT&lt;dis2LB)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setTop(m_oldRect.top());            newRect.setBottom(m_oldRect.top()+dis);            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;&#125;void myGraphicRectItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)&#123;    setCursor(Qt::ArrowCursor);    if(m_StateFlag == MOV_RECT)    &#123;        m_StateFlag = DEFAULT_FLAG;    &#125;    else &#123;        QGraphicsItem::mouseReleaseEvent(event);    &#125;&#125;void myGraphicRectItem::SetRotate(qreal RotateAngle, QPointF ptCenter)&#123;    m_bRotate = true;    if(ptCenter.x()==-999 &amp;&amp; ptCenter.y()==-999)    &#123;        m_RotateCenter = QPointF(m_oldRect.x()+m_oldRect.width()/2,m_oldRect.y()+m_oldRect.height()/2);    &#125;    else    &#123;        m_RotateCenter = ptCenter;    &#125;    m_RotateAngle = RotateAngle;    this-&gt;update();&#125;QPointF myGraphicRectItem::getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle)&#123;    double dx = ptCenter.x();    double dy = ptCenter.y();    double x = ptIn.x();    double y = ptIn.y();    double xx,yy;    xx = (x-dx)*cos(angle*M_PI/180)-(y-dy)*sin(angle*M_PI/180)+dx;    yy = (x-dx)*sin(angle*M_PI/180)+(y-dy)*cos(angle*M_PI/180)+dy;    return QPointF(xx,yy);&#125;QList&lt;QPointF&gt; myGraphicRectItem::getRotatePoints(QPointF ptCenter, QList&lt;QPointF&gt; ptIns, qreal angle)&#123;    QList&lt;QPointF&gt; lstPt;    for(int i = 0;i&lt;ptIns.count();i++)    &#123;        lstPt.append(getRotatePoint(ptCenter,ptIns.at(i),angle));    &#125;    return lstPt;&#125;QPolygonF myGraphicRectItem::getRotatePolygonFromRect(QPointF ptCenter, QRectF rectIn, qreal angle)&#123;    QVector&lt;QPointF&gt; vpt;    QPointF pf = getRotatePoint(ptCenter,rectIn.topLeft(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.topRight(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.bottomRight(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.bottomLeft(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.topLeft(),angle);    vpt.append(pf);    return QPolygonF(vpt);&#125;QRectF myGraphicRectItem::getCrtPosRectToSceen()&#123;    QRectF retRect = QRectF(m_oldRect.x()+pos().x(),m_oldRect.y()+pos().y(),m_oldRect.width(),m_oldRect.height());    return retRect;&#125;QRectF myGraphicRectItem::getSmallRotateRect(QPointF ptA,QPointF ptB)&#123;    QPointF pt = getSmallRotateRectCenter(ptA,ptB);    return QRectF(pt.x()-10,pt.y()-10,20,20);&#125;QPointF myGraphicRectItem::getSmallRotateRectCenter(QPointF ptA,QPointF ptB)&#123;    QPointF ptCenter = QPointF((ptA.x()+ptB.x())/2,(ptA.y()+ptB.y())/2);//A,B点的中点C    //中垂线方程式为 y=x*k + b;    qreal x,y;//旋转图标矩形的中心    if(abs(ptB.y()-ptA.y())&lt;0.1)    &#123;        if(ptA.x()&lt;ptB.x())//矩形左上角在上方        &#123;            x = ptCenter.x();            y = ptCenter.y()-20;        &#125;        else//矩形左上角在下方        &#123;            x = ptCenter.x();            y = ptCenter.y()+20;        &#125;    &#125;    else if(ptB.y()&gt;ptA.y())//顺时针旋转0-180    &#123;        qreal k = (ptA.x()-ptB.x())/(ptB.y()-ptA.y());//中垂线斜率        qreal b = (ptA.y()+ptB.y())/2-k*(ptA.x()+ptB.x())/2;        //求AB线中垂线上离AB中点20个像素的点C的坐标        x = 20*cos(atan(k))+ptCenter.x();        y = k*x+b;    &#125;    else if(ptB.y()&lt;ptA.y())//顺时针旋转180-360    &#123;        qreal k = (ptA.x()-ptB.x())/(ptB.y()-ptA.y());//中垂线斜率        qreal b = (ptA.y()+ptB.y())/2-k*(ptA.x()+ptB.x())/2;        //求AB线中垂线上离AB中点20个像素的点C的坐标        x = -20*cos(atan(k))+ptCenter.x();        y = k*x+b;    &#125;    return QPointF(x,y);&#125;\n\n功能3：Qt中设置QGraphicsView的背景色为透明且无边框\n设置背景色为透明：在QGraphicsView上调用setStyleSheet()方法，并将背景色样式设置为透明。示例代码如下：\n\nQGraphicsView* view = new QGraphicsView;view-&gt;setStyleSheet(&quot;background-color: transparent;&quot;);\n\n\n设置边框：在QGraphicsView上调用setFrameStyle()方法，并将边框样式设置为无边框。示例代码如下：\n\nQGraphicsView* view = new QGraphicsView;view-&gt;setFrameStyle(QFrame::NoFrame);\n\n在Qt中使用一个按钮清除QGraphicsView上监控的图片QGraphicsPixmapItem上画出来不需要的矩形QGraphicsRectItem\n\n首先，在QGraphicsView上绑定一个按钮QPushButton\nQPushButton* clearBtn = new QPushButton(view);# 将按钮放置在view的左下角btn.setGeometry(0,view.geometry().height()-40,40,20);btn.setText(&quot;clear&quot;);\n\n给按钮绑定槽函数，用于清除矩形\n#在.h文件中定义槽函数private slots:\tvoid on_btn_clicked();\n\n# 在构造函数中绑定槽函数connect(clearBtn,SIGNAL(clicked()),this,SLOT(on_btn_clicked()));\n\n# 槽函数的具体实现void ImgHelper::on_btn_clicked()&#123;\trectcounts = 0;\t#设矩形个数为0\tscene-&gt;clear();\t# 清空scene\timgUpdated(cloneImage);\t# 将直接保存的监控图片重新添加进scene&#125;\n\n功能4：保存错误图片当发现监控的图片有问题时，就可以一键保存监控的图片，按日期创建文件夹，方便查看问题\nvoid ImgHelper::onSaveErrorImage()&#123;    //20230908    QString currentPath = QDir::currentPath();    QString filedir = currentPath + QDir::separator() + &quot;errorImg&quot;;    QDir dir(filedir);    if(!dir.exists())&#123;       if(dir.mkdir(filedir))&#123;       &#125;else&#123;           qDebug()&lt;&lt;&quot;创建目录失败&quot;;       &#125;    &#125;    QString nowDate = QDateTime::QDateTime::currentDateTime().toString(&quot;yyyy-MM-dd&quot;) ;    QString filedirdate = filedir + QDir::separator() + nowDate;    QDir dirdate(filedirdate);    if(!dirdate.exists())&#123;       if(dirdate.mkdir(filedirdate))&#123;       &#125;else&#123;           qDebug()&lt;&lt;&quot;创建目录失败&quot;;       &#125;    &#125;    for(int i = 1; i &lt;= 8; i++)&#123;        QString imgpath = filedirdate + QDir::separator() + &quot;tt&quot; + QString::number(i) +&quot;.bmp&quot;;        QFile file(imgpath);        //判断文件是否存在        if(file.exists())&#123;           continue;        &#125;        if(pixmapItem != NULL)&#123;            pixmapItem-&gt;pixmap().save(imgpath);        &#125;        break;    &#125;&#125;\n\n功能5：修复图片通道异常//2023926加  修复PLC查看图片出现的通道异常        for(int x = 0 ; x &lt; image.height(); x++)&#123;                    for(int y = 0 ; y &lt; image.width(); y++)&#123;                        QRgb pixel = image.pixel(x,y);                        int red = qBlue(pixel);                        int green =qRed(pixel);                        int blue = qGreen(pixel);                        QRgb newpixel = qRgb(red,green,blue);                        image.setPixel(x,y,newpixel);                    &#125;                &#125;\n\n\n\n","categories":["笔记"],"tags":["c++","Qt"]},{"title":"关键字static的使用","url":"/2023/12/20/%E5%85%B3%E9%94%AE%E5%AD%97static%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"关键字static的使用\n静态变量：在函数内部声明的静态变量具有静态生存期，即它们在整个程序执行期间都存在，并且只会初始化一次。例如：\n\nvoid foo() &#123;    static int count = 0; // 静态局部变量    count++;    cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; endl;&#125;\n\n\n静态成员变量：静态成员变量属于类本身而不是类的实例，并且在所有类对象之间共享。例如：\n\nclass MyClass &#123;public:    static int sharedVariable; // 静态成员变量声明&#125;;int MyClass::sharedVariable = 10; // 静态成员变量定义int main() &#123;    cout &lt;&lt; MyClass::sharedVariable &lt;&lt; endl; // 访问静态成员变量    return 0;&#125;\n\n\n静态成员函数：静态成员函数属于类本身而不是类的实例，可以直接通过类名来调用，而不需要创建对象实例。例如：\n\nclass MyClass &#123;public:    static void myStaticFunction() &#123;         cout &lt;&lt; &quot;This is a static member function.&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    MyClass::myStaticFunction(); // 调用静态成员函数    return 0;&#125;\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"内存对齐","url":"/2023/11/16/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/","content":"内存对齐什么是内存对齐内存对齐是指在分配内存时，数据存储在内存中的起始地址是按照一定的规则对齐的。\n假设现在CPU是按照每4个字节来访问内存，有地址0、和地址1，现在要存1个char变量（假设char变量占1字节）和1个int变量（假设int变量占4字节），那么可以有内存对齐和内存不对齐的存储方式，如下图：\n\n假如不采用内存对齐的方式存储数据，那么CPU需要访问地址0和地址1，再进行合并，才能得到最终的结果；采用内存对齐的方式进行存储数据的话，则只需访问地址1就可以得到最终的结果。因此，采用内存对齐的存储方式可以减少CPU的访问运行时间，缺点是没有充分利用存储空间。\n对齐规则数据是根据初始化的顺序存储的，先定义的先储存，存储地址需要是sizeof(数据变量)的整数倍。\n例如，假设sizeof(char) = 1，sizeof(int) = 4，sizeof(int) = 4，sizeof(double) = 8。结构的对齐规则是要先确定对齐字节数（对齐字节数&#x3D;结构体中的变量占用空间最大的那个字节数，下面的结构体t3、t4就是sizeof(double) = 8），然后再保证存储地址是sizeof(数据变量)的整数倍。\n#include &lt;iostream&gt;using namespace std;struct t1&#123;    char a;    short c;    int x;    char b;&#125;;struct t2&#123;    int x;    char b;    char c;    short a;&#125;;struct t3&#123;    short a;    double c;    int x;    char b;&#125;;struct t4&#123;    char a, b;    int x;    double c;&#125;;int main()&#123;        cout &lt;&lt; sizeof(t1) &lt;&lt; endl; //12    cout &lt;&lt; sizeof(t2) &lt;&lt; endl; //8    cout &lt;&lt; sizeof(t3) &lt;&lt; endl; //24    cout &lt;&lt; sizeof(t4) &lt;&lt; endl; //16    return 0;&#125;\n\n\n在C&#x2F;C++中，内存对齐是由编译器负责的。编译器会按照平台的要求为数据进行对齐，通常会将数据按照其自身大小对齐到特定字节的倍数。这个特定字节的倍数通常由平台决定，例如，在32位系统中可能是4字节，而在64位系统中可能是8字节。\nC&#x2F;C++中可以使用一些特殊的关键字或编译器指令来控制内存对齐，例如：alignas关键字：C++11引入了alignas关键字，用于指定对齐方式。\nalignas(16) struct MyStruct &#123;    // 结构体成员&#125;;\n\n作用\n提高访问速度：许多计算机体系结构要求数据按照特定的边界地址存储，而不是任意地址。当数据被按照这些边界对齐时，处理器能够更快地访问这些数据，提高数据存取速度。\n硬件要求：一些硬件平台对于特定类型的数据要求按照一定的对齐方式存储，不遵循这个规则可能导致硬件异常或性能下降。\n减少浪费：内存对齐可以减少内存碎片，提高内存利用率。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"内存泄漏的定义，如何检测与避免","url":"/2023/11/25/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D/","content":"内存泄漏的定义，如何检测与避免定义：内存泄漏简单的说就是申请了一块内存空间，使用完毕后没有释放掉。 它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。\n如何检测内存泄漏\n\n首先可以通过观察猜测是否可能发生内存泄漏，Linux 中使用swap 命令观察还有多少可用的交换空间，在一两分钟内键入该命令三到四次，看看可用的交换区是否在减少。\n还可以使用 其他一些 /usr/bin/stat 工具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，一个可能的解释就是有个进程出现了内存泄漏。\n当然也有用于内存调试，内存泄漏检测以及性能分析的软件开发工具 valgrind 这样的工具来进行内存泄漏的检测。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"单例模式","url":"/2023/11/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"单例模式最简单也是被问到最多的设计模式之一，保证一个类只创建一个实例，同时提供全局访问的方法。\n\n懒汉模式在使用这个实例对象时才去创建，创建对象时加锁保证有且仅有一个（有线程安全问题）\n实现方式\n\n静态局部变量\n\n互斥锁\n\n使用C++11新特性call_once\n\n\n经典的线程安全例子class single&#123;private:    //私有静态指针变量指向唯一实例    static single *p;    //静态锁，是由于静态函数只能访问静态成员    static pthread_mutex_t lock;    //私有化构造函数    single()&#123;        pthread_mutex_init(&amp;lock, NULL);    &#125;    ~single()&#123;&#125;public:    //公有静态方法获取实例    static single* getinstance();&#125;;pthread_mutex_t single::lock;single* single::p = NULL;single* single::getinstance()&#123;    if (NULL == p)&#123;        pthread_mutex_lock(&amp;lock);        if (NULL == p)&#123;            p = new single;        &#125;        pthread_mutex_unlock(&amp;lock);    &#125;    return p;&#125;\n\n为什么要用双检测，只检测一次不行吗？\n如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL &#x3D;&#x3D; p的情况，直接返回已创建好的实例。\n局部静态变量之线程安全懒汉模式class single&#123;private:    single()&#123;&#125;    ~single()&#123;&#125;public:    static single* getinstance();&#125;;single* single::getinstance()&#123;    static single obj;    return &amp;obj;&#125;\n\n这种方法不加锁会不会造成线程安全问题？\nC++0X以后，要求编译器保证内部静态变量的线程安全性。\n饿汉模式不管是否使用这个实例对象，只要类被创建出来，实例对象就被创建（无线程安全问题）\n饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。\nclass single&#123;private:    static single* p;    single()&#123;&#125;    ~single()&#123;&#125;public:    static single* getinstance();&#125;;single* single::p = new single();single* single::getinstance()&#123;    return p;&#125;//测试方法int main()&#123;    single *p1 = single::getinstance();    single *p2 = single::getinstance();    if (p1 == p2)        cout &lt;&lt; &quot;same&quot; &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;\n\n饿汉模式存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。\n","categories":["笔记"],"tags":["c++","设计模式"]},{"title":"基于epoll的web服务器(C语言版本)","url":"/2023/10/28/%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8-C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/","content":"记录学习使用epoll实现web服务器\n\n\n基于epoll的web服务器(C语言版本)1. 初始化监听套接字包括创建监听套接字，设置端口复用，绑定，设置监听等步骤\n1.1 创建监听套接字（socket函数）socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。\n#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);domain:\tAF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址\tAF_INET6 与上面类似，不过是来用IPv6的地址\tAF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用type:\tSOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。\tSOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。\tSOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。\tSOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）\tSOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序protocol:\t传0 表示使用默认协议。返回值：\t成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno\n\n\n\n1.2 设置端口复用（setsockopt函数）在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是listenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。\n在server代码的socket()和bind()调用之间插入如下代码：\nint opt = 1;setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));\n\n1.3 绑定（bind函数）服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。\n#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockfd：\tsocket文件描述符addr:\t构造出IP地址加端口号addrlen:\tsizeof(addr)长度返回值：\t成功返回0，失败返回-1, 设置errno\n\nbind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如：\nstruct sockaddr_in addr;bzero(&amp;addr, sizeof(addr));servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\t//INADDR_ANY = 0servaddr.sin_port = htons(8888);\n\n首先将整个结构体清零，然后设置地址类型为AF_INET，网络地址为INADDR_ANY**，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为8888。\n1.4 设置监听 （listen函数）#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);sockfd:\tsocket文件描述符backlog:\t排队建立3次握手队列和刚刚建立3次握手队列的链接数和(现在只表示建立链接队列的数量)\n\n查看系统默认backlog\ncat /proc/sys/net/ipv4/tcp_max_syn_backlog\n\n典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。\n1.5 初始化监听套接字（initListenFd函数）// 初始化监听套接字int initListenFd(port)&#123;    // 1. 创建监听套接字    int lfd = socket(AF_INET,SOCK_STREAM,0);    if(lfd == -1)&#123;        perror(&quot;socket error&quot;);        return -1;    &#125;    // 2. 设置端口复用    int opt = 1;    int ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt));    if(ret == -1)&#123;        perror(&quot;setsockopt error&quot;);        return -1;    &#125;    // 3. 绑定    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = 0;    int ret = bind(lfd,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ret == -1)&#123;        perror(&quot;bind error&quot;);        return -1;    &#125;    // 4.设置监听    ret = listen(lfd,128);    if(ret == -1)&#123;        perror(&quot;listen error&quot;);        return -1;    &#125;    // 5. 返回fd    return lfd;&#125;\n\n\n\n2. 启动epollepoll是Linux下IO多路复用接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。\nepoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。\n2.1 创建epoll树  (epoll_create) 创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。(参数size已经弃用，只需提供大于0的数字就行)\n#include &lt;sys/epoll.h&gt;int epoll_create(int size)\t\tsize：监听数目（内核参考值）返回值：成功：非负文件描述符；失败：-1，设置相应的errno\n\n可以使用cat命令查看一个进程可以打开的socket描述符上限。\ncat /proc/sys/fs/file-max806425\n\n如有需要，可以通过修改配置文件的方式修改该上限值。\nsudo vi /etc/security/limits.conf在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。* soft nofile 65536* hard nofile 100000\n\n\n2.2 上树（epoll_ctl函数）控制某个epoll监控的文件描述符上的事件：注册、修改、删除。\n#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)    epfd：\t为epoll_creat的句柄    op：\t\t表示动作，用3个宏来表示：    EPOLL_CTL_ADD (注册新的fd到epfd)，    EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，    EPOLL_CTL_DEL (从epfd删除一个fd)；    event：\t告诉内核需要监听的事件struct epoll_event &#123;    __uint32_t events; /* Epoll events */    epoll_data_t data; /* User data variable */&#125;;typedef union epoll_data &#123;    void *ptr;    int fd;    uint32_t u32;    uint64_t u64;&#125; epoll_data_t;EPOLLIN ：\t表示对应的文件描述符可以读（包括对端SOCKET正常关闭）EPOLLOUT：\t表示对应的文件描述符可以写EPOLLPRI：\t表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）EPOLLERR：\t表示对应的文件描述符发生错误EPOLLHUP：\t表示对应的文件描述符被挂断；EPOLLET： \t将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里返回值：成功：0；失败：-1，设置相应的errno\n\n2.3 检测（epoll_wait函数）等待所监控文件描述符上有事件的产生，类似于select()调用。\n#include &lt;sys/epoll.h&gt;\tint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)    events：\t\t用来存内核得到事件的集合，可简单看作数组。    maxevents：\t告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，    timeout：\t是超时时间    -1：\t阻塞    0：\t立即返回，非阻塞    &gt;0：\t指定毫秒    返回值：\t成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1\n\n2.4 启动epoll(epollrun函数)//启动epollvoid epollrun(int lfd)&#123;    // 1. 创建epoll树    int epfd = epoll_create(1);    if(epfd == -1)&#123;        perror(&quot;epoll_create error&quot;);        return -1;    &#125;    // 2. lfd上树    struct epoll_event ev;    ev.data.fd = lfd;    ev.events = EPOLLIN;    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    // 3. 检测(委托内核检测添加到树上的节点)    struct epoll_event evs[1024];    int size = siezof(evs) / sizeof(struct epoll_event);    while(1)&#123;        int num = epoll_wait(epfd,evs,size,-1);        if(num == -1) &#123;            perror(&quot;epoll_wait error&quot;);            return -1;        &#125;        // 遍历发生变化的节点        for(int i = 0; i &lt; num; ++i)&#123;            if(!(evs[i].events &amp; EPOLLIN)) &#123;                // 不是读事件                continue;            &#125;            int fd = evs[i].data.fd;            if(fd == lfd)&#123;                // 建立新连接 accept                acceptClient(lfd,epfd);            &#125;else&#123;                // 主要是接受对端的数据(读数据)                recvHttpRequest(fd,epfd);            &#125;        &#125;    &#125;&#125;\n\n3. 建立连接3.1 建立连接 （accept函数）三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。\n#include &lt;sys/types.h&gt; \t\t/* See NOTES */#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);sockdf:\tsocket文件描述符addr:\t传出参数，返回链接客户端地址信息，含IP地址和端口号addrlen:\t传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小返回值：\t成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno\n\n我们的服务器程序结构是这样的：\nwhile (1) &#123;\tcliaddr_len = sizeof(cliaddr);\tconnfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);\tn = read(connfd, buf, MAXLINE);\t......\tclose(connfd);&#125;\n\n整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。\n3.2 epoll事件模型EPOLL事件有两种模型：\n\nEdge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。\n\nLevel Triggered (LT) 水平触发只要有数据都会触发。\n\n\n思考如下步骤：1.\t假定我们已经把一个用来从管道中读取数据的文件描述符(rfd)添加到epoll描述符。2.\t管道的另一端写入了2KB的数据3.\t调用epoll_wait，并且它会返回rfd，说明它已经准备好读取操作4.\t读取1KB的数据5.\t调用epoll_wait……\n\nET模式 即Edge Triggered工作模式（边沿触发）\n如果我们在第1步将rfd添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。\n\n基于非阻塞文件句柄\n\n只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。\n\n\nLT模式即Level Triggered工作模式(水平触发)\n与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。\n比较\nLT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。**传统的select/poll**都是这种模型的代表。\nET(edge-triggered)：**ET是高速工作方式，只支持no-block socket**。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知**(only once)**.\n3.3 阻塞与非阻塞\n非阻塞模式可以理解为，执行此套接字的网络调用时，不管是否执行成功，都会立即返回。\n\n​\t\t如调用recv( )函数读取网络缓冲区中的数据时，不管是否读到数据都立即返回，而不会一直挂在此函数的调用上。\n\n阻塞模式为只有接收到数据后才会返回，套接字默认的会创建堵塞模式。\n\n3.4 建立连接（accpetClient函数）int accpetClient(int lfd,int epfd)&#123;    // 1. 建立连接    struct sockaddr_in cliaddr;    socklen_t len = sizeof(cliaddr);    cliaddr.sin_family = AF_INET;    int cfd = accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len);    if(cfd == -1)&#123;        perror(&quot;accept error&quot;);        return -1;    &#125;    char ip[16]=&quot;&quot;;    printf(&quot;new client ip=%s port=%d\\n&quot;,    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));        // 2. 设置非阻塞    int flag = fcntl(cfd,F_GETFL);    flag |= O_NONBLOCK;    fcntl(cfd,F_SETFL,flag);    // 3. cfd添加到epoll    struct epoll_event ev;    ev.data.fd = cfd;    ev.events = EPOLLIN | EPOLLET;      //边沿模式    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    return 0;&#125;\n\n\n\n4. 接收客户端发来的http请求4.1 接收数据 （recv函数）接收来自socket缓冲区的数据，当缓冲区没有数据可取时，recv会一直处于阻塞状态()，直到缓冲区至少又一个字节数据可读取，或者对端关闭，并读取所有数据后返回。\n#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;int recv(int sockfd, char * buf, int len, int flags);sockfd：连接的fdbuf：用于接收数据的缓冲区len：缓冲区长度flags：指定调用方式返回值：成功返回实际读到的字节数。如果recv在copy时出错，那么它返回err，err小于0；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。\n\nread\nread函数从文件描述符（包括TCP Socket）中读取数据，并将读取的数据存储到指定的缓冲区中。\nssize_t read(int fd, void *buf, size_t count);fd：要读取数据的文件描述符，可以是TCP Socket。buf：存储读取数据的缓冲区。count：要读取的字节数。返回值：成功时返回实际读取的字节数，失败时返回-1，并设置errno变量来指示错误的原因。\n\nread函数和recv函数都是阻塞调用，即在没有数据可读时会一直阻塞等待。它们的主要区别在于recv函数可以通过flags参数控制一些特殊的行为，如设置MSG_PEEK标志来预览数据而不将其从缓冲区中移除。\n4.2 EAGAIN错误以O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read或者recv操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。\n（epoll的ET模式下设置recv，对应的fd文件描述符设置为非阻塞）下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。\n\n4.3 接受http请求（recvHttpRequest函数）int recvHttpRequest(int cfd,int epfd)&#123;    char buf[4096] = &#123; 0 &#125;;    char tmp[1024] = &#123; 0 &#125;;    int len = 0;    int total = 0;    // 1. 接收数据    while((len = recv(cfd,tmp,sizeof(tmp),0)) &gt; 0)&#123;        if(total + len &lt; sizeof(buf))&#123;            memcpy(buf + total,tmp,len);        &#125;        total += len;    &#125;    // 2. 判断数据是否接受完毕    if(len == -1 &amp;&amp; errno == EAGAIN)&#123;        // 解析请求行           /*        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19        G E T   / 1 . t x t H  T  T  P  /  1  .  1  /r /n        */        char* pt = strstr(buf,&quot;\\r\\n&quot;);  //大字符串找小字符串        int reqLen = pt - buf;        buf[reqLen] = &#x27;\\0&#x27;;    &#125;    else if(len == 0)&#123;        // 客户端断开连接        epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);    &#125;    else&#123;        perror(&quot;recv error&quot;);    &#125;    return 0;&#125;\n\n5. 解析请求行5.1 格式化拆分字符串 （sscanf函数）sprintf（）是把格式化数据输出成（存储到）字符串。sscanf（）是从字符串中读取格式化的数据。\n\n// 函数原型// 将参数str的字符串根据参数format字符串来转换并格式化数据，转换后的结果存于对应的参数内。sscanf(const char *str, const char *format, ...)。具体功能如下：（1）根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。（2）取指定长度的字符串（3）取到指定字符为止的字符串（4）取仅包含指定字符集的字符串（5）取到指定字符集为止的字符串// 可以使用正则表达式进行字符串的拆分// shell脚本的时候, 会将正则表达式, 其实就是字符串的匹配规则, 用特殊字符来描述一类字符串/*正则匹配规则:\t[1-9]: 匹配一个字符, 这个字符在 1-9 范围内就满足条件\t[2-7]: 匹配一个字符, 这个字符在 2-7 范围内就满足条件\t[a-z]: 匹配一个字符, 这个字符在 a-z 范围内就满足条件\t[A,b,c,D, e, f]: 匹配一个字符, 这个字符是集合中任意一个就满足条件\t[1-9, f-x]: 匹配一个字符, 这个字符是1-9, 或者f-x 集合中的任意一个就满足条件\t[^1]: ^代表否定, 匹配一个字符,这个字符只要不是1就满足条件\t[^2-8]: 匹配一个字符,这个字符只要不在 2-8 范围内就满足条件\t[^a-f]: 匹配一个字符,这个字符只要不在 a-f 范围内就满足条件\t[^ ]: 匹配一个字符,这个字符只要不是空格就满足条件使用正则表达式如何取匹配字符串:举例: \t字符串 ==&gt; abcdefg12345AABBCCDD890\t正则表达式: [1-9][a-z], 可以匹配两个字符\t匹配方式: 从原始字符串开始位置遍历, 每遍历一个字符都需要和正则表达式进行匹配, \t\t满足条件继续向后匹配, 不满足条件, 匹配结束\t\t从新开始: 从正则表达式的第一个字符重新开始向后一次匹配\t\t\t当整个大字符串被匹配一遍, 就结束了\tabcdefg12345AABBCCDD893b\t\t- 匹配到一个子字符串: 3b\t1a2b3c4d5e6f7g12345AABBCCDD893b\t - 1a\t - 2b\t - 3c\t - 4d\t - 5e\t - 6f\t - 7g\t - 3b*/sscanf可以支持格式字符%[]：(1)-: 表示范围，如：%[1-9]表示只读取1-9这几个数字 %[a-z]表示只读取a-z小写字母，类似地 %[A-Z]只读取大写字母(2)^: 表示不取，如：%[^1]表示读取除&#x27;1&#x27;以外的所有字符 %[^/]表示除/以外的所有字符(3),: 范围可以用&quot;,&quot;相连接 如%[1-9,a-z]表示同时取1-9数字和a-z小写字母 (4)原则：从第一个在指定范围内的数字开始读取，到第一个不在范围内的数字结束%s 可以看成%[] 的一个特例 %[^ ](注意^后面有一个空格！)\n\n5.2 转码假设浏览器访问的文件名中有中文: Linux内核.jpg\t- 浏览器在给服务器发送请求的时候, 会自动将中文进制转换: Linux%E5%86%85%E6%A0%B8.jpg\t- 为什么要转换?\t\t- 在http请求的请求行中不支持中文字符, 如果有中文, 浏览器就会自动将中文进行转换\t\t- 在服务器端收到的文件名就不是原来的名字了, 因此服务器端就不能识别了\t\t- 如果服务器端想要正确的处理, 需要将特殊字符串解析成原来的汉字\t\t$ unicode 内UTF-8: e5 86 85 $ unicode 核UTF-8: e6 a0 b8\n\n5.3 获取文件信息（stat）Linux 下可以使用stat 命令查看文件的属性，其实这个命令内部就是通过调用 stat()函数来获取文件属性的，stat 函数是 Linux 中的系统调用，用于获取文件相关的信息。\n#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int stat(const char *pathname, struct stat *buf);\n\nstruct stat&#123;\t dev_t st_dev; /* 文件所在设备的 ID */\t ino_t st_ino; /* 文件对应 inode 节点编号 */\t mode_t st_mode; /* 文件对应的模式 */\t nlink_t st_nlink; /* 文件的链接数 */\t uid_t st_uid; /* 文件所有者的用户 ID */\t gid_t st_gid; /* 文件所有者的组 ID */\t dev_t st_rdev; /* 设备号（指针对设备文件） */\t off_t st_size; /* 文件大小（以字节为单位） */\t blksize_t st_blksize; /* 文件内容存储的块大小 */\t blkcnt_t st_blocks; /* 文件内容所占块数 */\t struct timespec st_atim; /* 文件最后被访问的时间 */\t struct timespec st_mtim; /* 文件内容最后被修改的时间 */\t struct timespec st_ctim; /* 文件状态最后被改变的时间 */&#125;;st_dev：该字段用于描述此文件所在的设备。不常用，可以不用理会。st_ino：文件的 inode 编号。st_mode：该字段用于描述文件的模式，譬如文件类型、文件权限都记录在该变量中。st_nlink：该字段用于记录文件的硬链接数，也就是为该文件创建了多少个硬链接文件。链接文件可以分为软链接（符号链接）文件和硬链接文件。st_uid、st_gid：此两个字段分别用于描述文件所有者的用户 ID 以及文件所有者的组 ID。st_rdev：该字段记录了设备号，设备号只针对于设备文件，包括字符设备文件和块设备文件，不用理会。st_size：该字段记录了文件的大小（逻辑大小），以字节为单位。st_atim、st_mtim、st_ctim：此三个字段分别用于记录文件最后被访问的时间、文件内容最后被修改的时间以及文件状态最后被改变的时间，都是 struct timespec 类型变量。\n\n5.3 解析请求行（parseRequestLine函数）int parseRequestLine(const char* line,int cfd)&#123;    // 1. 拆分http请求行   get /xxx/1.jpg http/1.1    char method[12];    // 方法    char path[1024];    // 路径    char protocol[12];  // 协议    sscanf(line,&quot;%[^ ] %[^ ] %[^ ]&quot;,method,path,protocol);    printf(&quot;method = %s, path = %s, protocol = %s\\n&quot;, method, path, protocol);    // 判断是否是get请求    if(strcasecmp(method,&quot;get&quot;) != 0)&#123;     //不区分大小写        return -1;    &#125;    // 转码 将不能识别的中文乱码 -&gt; 中文    // 解码 %23 %34 %5f    decode_str(path, path);    // 2. 处理客户端请求的静态资源    char* file = NULL;    // 如果没有指定访问的资源, 默认显示资源目录中的内容    if(strcmp(path,&quot;/&quot;) == 0)&#123;        // file的值, 资源目录的当前位置        file = &quot;./&quot;;    &#125;else&#123;        // 去掉path中的/ 获取访问文件名        file = path + 1;    &#125;        // 3. 获取文件属性    struct stat st;    int ret = stat(file,&amp;st);    if(ret == -1)&#123;        // 文件不存在--回复404        return 0;    &#125;    // 判断文件类型（判断是目录还是文件）    if(S_ISDIR(st.st_mode))&#123;    // 目录        // 把目录发给客户端    &#125;else&#123;        // 把文件内容发给客户端    &#125;    return 0;&#125;\n\n6. 发送响应头int sendHeadMsg(int cfd,int status,const char* desrc,const char* type,int length)&#123;    // 状态行    char buf[4096] = &#123; 0 &#125;;    sprintf(buf,&quot;http/1.1 %d %s \\r\\n&quot;,status,desrc);    // 消息报头    sprintf(buf + strlen(buf),&quot;Content-Type: %s\\r\\n&quot;,type);    sprintf(buf + strlen(buf),&quot;Content-Length: %d\\r\\n&quot;,length);    send(cfd,buf,strlen(buf),0);     // 空行    send(cfd, &quot;\\r\\n&quot;, 2, 0);    return 0;&#125;\n\n7. 通过文件名获取文件的类型// 通过文件名获取文件的类型const char *get_file_type(const char *name)&#123;    char* dot;    // 自右向左查找‘.’字符, 如不存在返回NULL    dot = strrchr(name, &#x27;.&#x27;);       if (dot == NULL)        return &quot;text/plain; charset=utf-8&quot;;    if (strcmp(dot, &quot;.html&quot;) == 0 || strcmp(dot, &quot;.htm&quot;) == 0)        return &quot;text/html; charset=utf-8&quot;;    if (strcmp(dot, &quot;.jpg&quot;) == 0 || strcmp(dot, &quot;.jpeg&quot;) == 0)        return &quot;image/jpeg&quot;;    if (strcmp(dot, &quot;.gif&quot;) == 0)        return &quot;image/gif&quot;;    if (strcmp(dot, &quot;.png&quot;) == 0)        return &quot;image/png&quot;;    if (strcmp(dot, &quot;.css&quot;) == 0)        return &quot;text/css&quot;;    if (strcmp(dot, &quot;.au&quot;) == 0)        return &quot;audio/basic&quot;;    if (strcmp( dot, &quot;.wav&quot; ) == 0)        return &quot;audio/wav&quot;;    if (strcmp(dot, &quot;.avi&quot;) == 0)        return &quot;video/x-msvideo&quot;;    if (strcmp(dot, &quot;.mov&quot;) == 0 || strcmp(dot, &quot;.qt&quot;) == 0)        return &quot;video/quicktime&quot;;    if (strcmp(dot, &quot;.mpeg&quot;) == 0 || strcmp(dot, &quot;.mpe&quot;) == 0)        return &quot;video/mpeg&quot;;    if (strcmp(dot, &quot;.vrml&quot;) == 0 || strcmp(dot, &quot;.wrl&quot;) == 0)        return &quot;model/vrml&quot;;    if (strcmp(dot, &quot;.midi&quot;) == 0 || strcmp(dot, &quot;.mid&quot;) == 0)        return &quot;audio/midi&quot;;    if (strcmp(dot, &quot;.mp3&quot;) == 0)        return &quot;audio/mpeg&quot;;    if (strcmp(dot, &quot;.ogg&quot;) == 0)        return &quot;application/ogg&quot;;    if (strcmp(dot, &quot;.pac&quot;) == 0)        return &quot;application/x-ns-proxy-autoconfig&quot;;    return &quot;text/plain; charset=utf-8&quot;;&#125;\n\n8. 发送文件8.1 断言（assert函数）编译期assert函数的目的在于当条件不满足时，阻止编译，从而防止错误的逻辑通过编辑。而运行期assert的目的在于运行时发现条件不满足时，产生一个Debug事件(DebugBreak)，从而让调试器停下来方便用户检查原因。assert 是一个宏，不是函数。\n//表达式可以是任何有效的 C 语言表达式，很多时候它是一个条件。void assert(int expression or variable);\n\n8.2 光标函数（lseek函数）#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;off_t lseek(int handle, off_t offset, int fromwhere);1) 欲将读写位置移到文件开头时:lseek（int fildes,0,SEEK_SET）；2) 欲将读写位置移到文件尾时:lseek（int fildes，0,SEEK_END）；3) 想要取得目前文件位置时:lseek（int fildes，0,SEEK_CUR）；\n\n8.3 发送文件（sendFile函数）int sendFile(const char* filename,int cfd)&#123;    // 1. 打开文件    int fd = open(filename,O_RDONLY);    assert(fd &gt; 0);     // 断言    // if(fd == -1)&#123;    //     perror(&quot;open error&quot;);    // &#125;    // 2. 循环读文件#if 1    char buf[4096] = &#123; 0 &#125;;    int len = 0, ret = 0;    while((len = read(fd,buf,sizeof(buf))) &gt; 0)&#123;        // 发送读出的数据        ret = send(cfd,buf,len,0);        if(ret == -1)&#123;            if(errno = EAGAIN)&#123;                perror(&quot;send error:&quot;);                continue;            &#125;else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;    &#125;#else    off_t offset = 0;    int size = lseek(fd,0,SEEK_END);    lseek(fd,0,SEEK_SET);    while(offset &lt; size)&#123;        int ret = sendfile(cfd,fd,&amp;offset,size);        printf(&quot;ret value: %d\\n&quot;,ret);        if(ret == -1 &amp;&amp; errno == EAGAIN)&#123;            printf(&quot;没数据。。。\\n&quot;);            perror(&quot;snedfile&quot;);                    &#125;    &#125;#endif    close(fd);    return 0;&#125;\n\n9. 发送目录9.1 目录扫描函数（scandir函数）scandir()会扫描参数dir指定的目录文件，经由参数select指定的函数来挑选目录结构至参数namelist数组中，最后再调用参数compar指定的函数来排序namelist数组中的目录数据。每次从目录文件中读取一个目录结构后便将此结构传给参数select所指的函数，select函数若不想要将此目录结构复制到namelist数组就返回0，若select为空指针则代表选择所有的目录结构。scandir()会调用qsort()来排序数据，参数compar则为qsort()的参数，若是要排列目录名称字母则可使用alphasort()。\n#include &lt;dirent.h&gt;int scandir(const char *dir, \t\t\tstruct dirent ***namelist,\t\t\tint (*select)(const struct dirent *),\t\t\tint (*compar)(const struct dirent **, \t\t\tconst struct dirent **));dir:指定扫描的目录namelist:struct dirent结构体类型的三级指针，用于获取该函数内部为存放返回结果的分配的动态内存select:函数指针，指向过滤模式函数,当selectr指针设置为NULL时，扫描dir目录下的所有顶层文件.该函数有一个参数const struct dirent *是指在遍历过程中所遍历到的每一个子目录dirent，select可以根据dirent的类型、名称等信息来判定当前的dirent是否为合法的子目录，合法则函数返回0，则该子目录的名称会被存储在namelist中；否则返回非0，则该子目录被过滤掉。compar:函数指针，指向对遍历结果进行排序函数，alphasort函数和versionsort是经常用到的函数\n\n9.2 发送目录（sendDir函数）// 发送目录内容int sendDir(const char* dirname, int cfd)&#123;      // 拼接一个html页面&lt;table&gt;&lt;/table&gt;   char buf[4096] = &#123; 0 &#125;;      sprintf(buf,&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;,dirname);   //sprintf(buf + strlen(buf),&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;,dirname);    // 目录项二级指针    struct dirent** ptr;    int num = scandir(dirname,&amp;ptr,NULL,alphasort);    // 遍历目录    for(int i = 0; i &lt; num; i++)&#123;        // 取出文件名 namelist 指向的是一个指针数组 struct dirent* tmp[]        char* name = ptr[i]-&gt;d_name;        char subPath[1024] = &#123; 0 &#125;;        // 拼接文件袋完整路径        sprintf(subPath,&quot;%s/%s&quot;,dirname,name);                struct stat st;        stat(subPath,&amp;st);        char enstr[1024] = &#123;0&#125;;        // 编码生成 %E5 %A7 之类的东西        encode_str(enstr, sizeof(enstr), name);        // 如果是文件        if(S_ISREG(st.st_mode)) &#123;                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\\&quot;%s\\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125; else if(S_ISDIR(st.st_mode)) &#123;\t\t// 如果是目录                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\\&quot;%s/\\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125;        int ret = send(cfd, buf, strlen(buf), 0);        if (ret == -1) &#123;            if (errno == EAGAIN) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;        memset(buf, 0, sizeof(buf));        // 字符串拼接        free(ptr[i]);    &#125;          // 字符串拼接    //memset(buf, 0, sizeof(buf));    sprintf(buf, &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);    send(cfd, buf, strlen(buf), 0);    printf(&quot;dir message send OK!!!!\\n&quot;); #if 0    // 打开目录    DIR* dir = opendir(dirname);    if(dir == NULL)    &#123;        perror(&quot;opendir error&quot;);        exit(1);    &#125;    // 读目录    struct dirent* ptr = NULL;    while( (ptr = readdir(dir)) != NULL )    &#123;        char* name = ptr-&gt;d_name;    &#125;    closedir(dir);#endif    free(ptr);    return 0;&#125;\n\n10. 完整代码整体框架\n/*客户端: 浏览器\t- 通过浏览器访问服务器:\t\t- 访问方式: 服务器的IP地址:端口\t- 应用层协议使用: http, 数据需要在浏览器端使用该协议进行包装\t- 响应消息的处理也是浏览器完成的 =&gt; 程序猿不需要管\t- 客户端通过url访问服务器资源\t\t- 客户端访问的路径:\t\t1. http://192.168.1.100:8989/  或者  http://192.168.1.100:8989\t\t\t- 访问服务器提供的资源目录的根目录\t\t\t\t- 并不是服务器上的 / 目录  \t\t\t\t- 这个目录根据服务器端的描述应该是: /home/robin/luffy 目录\t\t\t- 请求行:\t\t\t\tGET / HTTP/1.1\t\t2. http://192.168.1.100:8989/a.txt\t\t\t- 端口后边的/代表服务器的资源根目录\t\t\t\t- 在服务器端路径: /home/robin/luffy 目录\t\t\t- 客户端要访问服务器上的a.txt的文件\t\t\t- a.txt 这个文件在服务器提供的资源目录中\t\t\t\t- 服务器上的路径: /home/robin/luffy/a.txt\t\t\t- 请求行:\t\t\t\tGET /a.txt HTTP/1.1\t\t3. http://192.168.1.100:8989/hello/a.txt\t\t\t- http://192.168.1.100:8989: 服务器地址\t\t\t- /hello/a.txt\t\t\t\t- /: 服务器端提供的资源根目录\t\t\t\t- hello: 资源根目录的子目录\t\t\t\t- a.txt: 在hello目录中\t\t\t- 请求行:\t\t\t\tGET /hello/a.txt HTTP/1.1\t\t4. http://192.168.1.100:8989/hello/wrold/\t\t\t- http://192.168.1.100:8989: 服务器地址\t\t\t- /hello/world/\t\t\t\t- /: 服务器端提供的资源根目录\t\t\t\t- hello: 资源根目录的子目录\t\t\t\t- world/: 如果world后边有/代表这是一个目录, 这个目录在hello目录中\t\t\t- 请求行:\t\t\t\tGET /hello/world/ HTTP/1.1*//*服务器端: 提供服务器, 让客户端访问\t- 支持多客户端访问\t\t- 使用IO多路转接 =&gt; epoll\t- 客户端发送给的请求消息是基于http的\t\t- 需要能够解析http请求\t- 服务器回复客户端数据, 使用http协议封装回复的数据 ==&gt; http响应\t- 服务器端需要提供一个资源目录, 目录中的文件可以供客户端访问\t\t- 客户端访问的文件没有在资源目录中, 就不能访问了\t\t\t- 假设服务器提供个资源目录: /home/robin/luffy 目录*/\n\n// 服务器端处理的伪代码int main()&#123;    // 1. 创建监听的fd    socket();    // 2. 绑定    bind();    // 3. 设置监听    listen();        // 4. 创建epoll模型    epoll_create();    epoll_ctl();    // 5. 检测    while(1)    &#123;        epoll_wait();        // 监听的文件描述符        accept();        // 通信的        // 接收数据-&gt;http请求消息        recvAndParseHttp();    &#125;    return 0;&#125;// 基于边沿非阻塞模型接收数据int recvAndParseHttp()&#123;    // 循环接收数据    // 解析http请求消息    // http请求由两种:get / post    // 只处理get请求, 浏览器向服务器请求访问的文件都是静态资源, 因此使用get就可以    // 判断是不是get请求  ==&gt; 在请求行中 ==&gt; 请求行的第一部分    // 客户端向服务器请求的静态资源是什么? =&gt; 请求行的第二部分    // 找到服务器上的静态资源    \t- 文件 -&gt; 读文件内容        - 目录 -&gt; 遍历目录    // 将文件内容或者目录内容打包到http响应协议中    // 将整条协议发送回给客户端即可&#125;\n\nepoll_web.c\n#include &quot;epoll_web.h&quot;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;#include &lt;assert.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;dirent.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#include &lt;sys/types.h&gt;// 初始化监听套接字int initListenFd(unsigned int port)&#123;    // 1. 创建监听套接字    int lfd = socket(AF_INET,SOCK_STREAM,0);    if(lfd == -1)&#123;        perror(&quot;socket error&quot;);        return -1;    &#125;    // 2. 设置端口复用    int opt = 1;    int ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt));    if(ret == -1)&#123;        perror(&quot;setsockopt error&quot;);        return -1;    &#125;    // 3. 绑定    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = 0;    ret = bind(lfd,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ret == -1)&#123;        perror(&quot;bind error&quot;);        return -1;    &#125;    // 4.设置监听    ret = listen(lfd,128);    if(ret == -1)&#123;        perror(&quot;listen error&quot;);        return -1;    &#125;    // 5. 返回fd    return lfd;&#125;//启动epollint epollrun(int lfd)&#123;    // 1. 创建epoll树    int epfd = epoll_create(1);    if(epfd == -1)&#123;        perror(&quot;epoll_create error&quot;);        return -1;    &#125;    // 2. lfd上树    struct epoll_event ev;    ev.data.fd = lfd;    ev.events = EPOLLIN;    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    // 3. 检测(委托内核检测添加到树上的节点)    struct epoll_event evs[1024];    int size = sizeof(evs) / sizeof(struct epoll_event);    while(1)&#123;        int num = epoll_wait(epfd,evs,size,-1);        if(num == -1) &#123;            perror(&quot;epoll_wait error&quot;);            return -1;        &#125;        // 遍历发生变化的节点        for(int i = 0; i &lt; num; ++i)&#123;            if(!(evs[i].events &amp; EPOLLIN)) &#123;                // 不是读事件                continue;            &#125;            int fd = evs[i].data.fd;            if(fd == lfd)&#123;                //建立新连接accept                accpetClient(lfd,epfd);            &#125;else&#123;                // 读数据                printf(&quot;=============before recvHttpRequest=============\\n&quot;);                recvHttpRequest(fd,epfd);                printf(&quot;=============after recvHttpRequest=============\\n&quot;);            &#125;        &#125;    &#125;    return 0;&#125;int accpetClient(int lfd,int epfd)&#123;    // 1. 建立连接    struct sockaddr_in cliaddr;    socklen_t len = sizeof(cliaddr);    cliaddr.sin_family = AF_INET;    int cfd = accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len);    if(cfd == -1)&#123;        perror(&quot;accept error&quot;);        return -1;    &#125;    char ip[16]=&quot;&quot;;    printf(&quot;new client ip=%s port=%d\\n&quot;,    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));        // 2. 设置cfd为非阻塞    int flag = fcntl(cfd,F_GETFL);    flag |= O_NONBLOCK;    fcntl(cfd,F_SETFL,flag);    // 3. cfd添加到epoll    struct epoll_event ev;    ev.data.fd = cfd;    // 边沿非阻塞模式    ev.events = EPOLLIN | EPOLLET;      //边沿模式    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    return 0;&#125;int recvHttpRequest(int cfd,int epfd)&#123;    char buf[4096] = &#123; 0 &#125;;    char tmp[1024] = &#123; 0 &#125;;    int len = 0;    int total = 0;    // 1. 接收数据    while((len = recv(cfd,tmp,sizeof(tmp),0)) &gt; 0)&#123;        if(total + len &lt; sizeof(buf))&#123;            memcpy(buf + total,tmp,len);        &#125;        total += len;    &#125;    // 2. 判断数据是否接受完毕    if(len == -1 &amp;&amp; errno == EAGAIN)&#123;        // 解析请求行           /*        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19        G E T   / 1 . t x t H  T  T  P  /  1  .  1  /r /n        */        char* pt = strstr(buf,&quot;\\r\\n&quot;);  //大字符串找小字符串        int reqLen = pt - buf;        buf[reqLen] = &#x27;\\0&#x27;;        parseRequestLine(buf,cfd);    &#125;    else if(len == 0)&#123;        // 客户端断开连接        epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);        close(cfd);    &#125;    else&#123;        perror(&quot;recv error&quot;);    &#125;    return 0;&#125;int parseRequestLine(const char* line,int cfd)&#123;    // 1. 拆分http请求行   get /xxx/1.jpg http/1.1    char method[12];    // 方法    char path[1024];    // 路径    char protocol[12];  // 协议    sscanf(line,&quot;%[^ ] %[^ ] %[^ ]&quot;,method,path,protocol);    printf(&quot;method = %s, path = %s, protocol = %s\\n&quot;, method, path, protocol);    // 判断是否是get请求    if(strcasecmp(method,&quot;get&quot;) != 0)&#123;     //不区分大小写        return -1;    &#125;    // 转码 将不能识别的中文乱码 -&gt; 中文    // 解码 %23 %34 %5f    decode_str(path, path);    // 2. 处理客户端请求的静态资源    char* file = NULL;    // 如果没有指定访问的资源, 默认显示资源目录中的内容    if(strcmp(path,&quot;/&quot;) == 0)&#123;        // file的值, 资源目录的当前位置        file = &quot;./&quot;;    &#125;else&#123;        // 去掉path中的/ 获取访问文件名        file = path + 1;    &#125;        // 3. 获取文件属性    struct stat st;    int ret = stat(file,&amp;st);    if(ret == -1)&#123;        // 文件不存在--回复404        sendHeadMsg(cfd,404,&quot;Not Found&quot;,get_file_type(&quot;.html&quot;),-1);        sendFile(&quot;404.html&quot;,cfd);        return 0;    &#125;    // 判断文件类型（判断是目录还是文件）    if(S_ISDIR(st.st_mode))&#123;    // 目录        // 把目录发给客户端         sendHeadMsg(cfd,200,&quot;OK&quot;,get_file_type(&quot;.html&quot;),-1);         sendDir(file,cfd);    &#125;else&#123;        // 把文件内容发给客户端        sendHeadMsg(cfd,200,&quot;OK&quot;,get_file_type(file),st.st_size);        sendFile(file,cfd);    &#125;    return 0;&#125;int sendHeadMsg(int cfd,int status,const char* desrc,const char* type,int length)&#123;    // 状态行    char buf[4096] = &#123; 0 &#125;;    sprintf(buf,&quot;http/1.1 %d %s \\r\\n&quot;,status,desrc);    // 消息报头    sprintf(buf + strlen(buf),&quot;Content-Type: %s\\r\\n&quot;,type);    sprintf(buf + strlen(buf),&quot;Content-Length: %d\\r\\n&quot;,length);    send(cfd,buf,strlen(buf),0);     // 空行    send(cfd, &quot;\\r\\n&quot;, 2, 0);    return 0;&#125;int sendFile(const char* filename,int cfd)&#123;    // 1. 打开文件    int fd = open(filename,O_RDONLY);    assert(fd &gt; 0);     // 断言    // if(fd == -1)&#123;    //     perror(&quot;open error&quot;);    // &#125;    // 2. 循环读文件#if 1    char buf[4096] = &#123; 0 &#125;;    int len = 0, ret = 0;    while((len = read(fd,buf,sizeof(buf))) &gt; 0)&#123;        // 发送读出的数据        ret = send(cfd,buf,len,0);        if(ret == -1)&#123;            if(errno = EAGAIN)&#123;                perror(&quot;send error:&quot;);                continue;            &#125;else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;    &#125;#else    off_t offset = 0;    int size = lseek(fd,0,SEEK_END);    lseek(fd,0,SEEK_SET);    while(offset &lt; size)&#123;        int ret = sendfile(cfd,fd,&amp;offset,size);        printf(&quot;ret value: %d\\n&quot;,ret);        if(ret == -1 &amp;&amp; errno == EAGAIN)&#123;            printf(&quot;没数据。。。\\n&quot;);            perror(&quot;snedfile&quot;);                    &#125;    &#125;#endif    close(fd);    return 0;&#125;// 发送目录内容int sendDir(const char* dirname, int cfd)&#123;      // 拼接一个html页面&lt;table&gt;&lt;/table&gt;   char buf[4096] = &#123; 0 &#125;;      sprintf(buf,&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;,dirname);   //sprintf(buf + strlen(buf),&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;,dirname);    // 目录项二级指针    struct dirent** ptr;    int num = scandir(dirname,&amp;ptr,NULL,alphasort);    // 遍历目录    for(int i = 0; i &lt; num; i++)&#123;        // 取出文件名 namelist 指向的是一个指针数组 struct dirent* tmp[]        char* name = ptr[i]-&gt;d_name;        char subPath[1024] = &#123; 0 &#125;;        // 拼接文件袋完整路径        sprintf(subPath,&quot;%s/%s&quot;,dirname,name);                struct stat st;        stat(subPath,&amp;st);        char enstr[1024] = &#123;0&#125;;        // 编码生成 %E5 %A7 之类的东西        encode_str(enstr, sizeof(enstr), name);        // 如果是文件        if(S_ISREG(st.st_mode)) &#123;                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\\&quot;%s\\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125; else if(S_ISDIR(st.st_mode)) &#123;\t\t// 如果是目录                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\\&quot;%s/\\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125;        int ret = send(cfd, buf, strlen(buf), 0);        if (ret == -1) &#123;            if (errno == EAGAIN) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;        memset(buf, 0, sizeof(buf));        // 字符串拼接        free(ptr[i]);    &#125;          // 字符串拼接    //memset(buf, 0, sizeof(buf));    sprintf(buf, &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);    send(cfd, buf, strlen(buf), 0);    printf(&quot;dir message send OK!!!!\\n&quot;); #if 0    // 打开目录    DIR* dir = opendir(dirname);    if(dir == NULL)    &#123;        perror(&quot;opendir error&quot;);        exit(1);    &#125;    // 读目录    struct dirent* ptr = NULL;    while( (ptr = readdir(dir)) != NULL )    &#123;        char* name = ptr-&gt;d_name;    &#125;    closedir(dir);#endif    free(ptr);    return 0;&#125;/* *  这里的内容是处理%20之类的东西！是&quot;解码&quot;过程。 *  %20 URL编码中的‘ ’(space) *  %21 &#x27;!&#x27; %22 &#x27;&quot;&#x27; %23 &#x27;#&#x27; %24 &#x27;$&#x27; *  %25 &#x27;%&#x27; %26 &#x27;&amp;&#x27; %27 &#x27;&#x27;&#x27; %28 &#x27;(&#x27;...... *  相关知识html中的‘ ’(space)是&amp;nbsp */// 16进制数转化为10进制int hexit(char c)&#123;    if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)        return c - &#x27;0&#x27;;    if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;)        return c - &#x27;a&#x27; + 10;    if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;F&#x27;)        return c - &#x27;A&#x27; + 10;    return 0;&#125;void encode_str(char* to, int tosize, const char* from)&#123;    int tolen;    for (tolen = 0; *from != &#x27;\\0&#x27; &amp;&amp; tolen + 4 &lt; tosize; ++from) &#123;            if (isalnum(*from) || strchr(&quot;/_.-~&quot;, *from) != (char*)0) &#123;                  *to = *from;            ++to;            ++tolen;        &#125; else &#123;            sprintf(to, &quot;%%%02x&quot;, (int) *from &amp; 0xff);            to += 3;            tolen += 3;        &#125;    &#125;    *to = &#x27;\\0&#x27;;&#125;void decode_str(char *to, char *from)&#123;    for ( ; *from != &#x27;\\0&#x27;; ++to, ++from  ) &#123;             if (from[0] == &#x27;%&#x27; &amp;&amp; isxdigit(from[1]) &amp;&amp; isxdigit(from[2])) &#123;                   *to = hexit(from[1])*16 + hexit(from[2]);            from += 2;                              &#125; else &#123;            *to = *from;        &#125;    &#125;    *to = &#x27;\\0&#x27;;&#125;// 通过文件名获取文件的类型const char *get_file_type(const char *name)&#123;    char* dot;    // 自右向左查找‘.’字符, 如不存在返回NULL    dot = strrchr(name, &#x27;.&#x27;);       if (dot == NULL)        return &quot;text/plain; charset=utf-8&quot;;    if (strcmp(dot, &quot;.html&quot;) == 0 || strcmp(dot, &quot;.htm&quot;) == 0)        return &quot;text/html; charset=utf-8&quot;;    if (strcmp(dot, &quot;.jpg&quot;) == 0 || strcmp(dot, &quot;.jpeg&quot;) == 0)        return &quot;image/jpeg&quot;;    if (strcmp(dot, &quot;.gif&quot;) == 0)        return &quot;image/gif&quot;;    if (strcmp(dot, &quot;.png&quot;) == 0)        return &quot;image/png&quot;;    if (strcmp(dot, &quot;.css&quot;) == 0)        return &quot;text/css&quot;;    if (strcmp(dot, &quot;.au&quot;) == 0)        return &quot;audio/basic&quot;;    if (strcmp( dot, &quot;.wav&quot; ) == 0)        return &quot;audio/wav&quot;;    if (strcmp(dot, &quot;.avi&quot;) == 0)        return &quot;video/x-msvideo&quot;;    if (strcmp(dot, &quot;.mov&quot;) == 0 || strcmp(dot, &quot;.qt&quot;) == 0)        return &quot;video/quicktime&quot;;    if (strcmp(dot, &quot;.mpeg&quot;) == 0 || strcmp(dot, &quot;.mpe&quot;) == 0)        return &quot;video/mpeg&quot;;    if (strcmp(dot, &quot;.vrml&quot;) == 0 || strcmp(dot, &quot;.wrl&quot;) == 0)        return &quot;model/vrml&quot;;    if (strcmp(dot, &quot;.midi&quot;) == 0 || strcmp(dot, &quot;.mid&quot;) == 0)        return &quot;audio/midi&quot;;    if (strcmp(dot, &quot;.mp3&quot;) == 0)        return &quot;audio/mpeg&quot;;    if (strcmp(dot, &quot;.ogg&quot;) == 0)        return &quot;application/ogg&quot;;    if (strcmp(dot, &quot;.pac&quot;) == 0)        return &quot;application/x-ns-proxy-autoconfig&quot;;    return &quot;text/plain; charset=utf-8&quot;;&#125;\n\nepoll_web.h#ifndef _EPOLL_SEVER_H#define _EPOLL_SEVER_H// 初始化监听的套接字int initListenFd(unsigned int port);//启动epollint epollrun(int lfd);// 建立新连接int accpetClient(int lfd,int epfd);// 读数据int recvHttpRequest(int fd,int epfd);// 解析请求行int parseRequestLine(const char* line,int cfd);// 发送响应头（状态行+响应头）int sendHeadMsg(int cfd,int status,const char* desrc,const char* type,int length);// 发送文件int sendFile(const char* filename,int cfd);// 发送目录int sendDir(const char* dirName,int cfd);// 通过文件名获取文件的类型const char *get_file_type(const char *name);int hexit(char c);void encode_str(char* to, int tosize, const char* from);void decode_str(char *to, char *from);#endif\n\nmain.c#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include &quot;epoll_web.h&quot;int main(int argc, char* argv[])&#123;    if(argc &lt; 3)&#123;        printf(&quot;./a.out port path\\n&quot;);        exit(1);    &#125;    // 采用指定端口    unsigned int port = atoi(argv[1]);    // 修改进程工作目录，方便后续操作    int ret = chdir(argv[2]);    if(ret == -1)&#123;        perror(&quot;chdir error&quot;);    &#125;    // 初始化监听套接字    int lfd = initListenFd(port);    // 启动epoll模型    epollrun(lfd);    return 0;&#125;\n\n","categories":["笔记"],"tags":["linux","c","网络编程"]},{"title":"定时器之时间堆","url":"/2024/01/04/%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B9%8B%E6%97%B6%E9%97%B4%E5%A0%86/","content":"定时器之时间堆除了以固定频率调用心搏函数 tick() 的定时方案，另一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数 tick() 被调用，超时时间最小的定时器必然到期， 我们就可以在 tick() 函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。\n客户端结构体这段程序的目的是为了在一个系统中管理客户端的数据，使用了堆定时器来进行与客户端相关的定时操作。\nclass heap_timer;// 用户数据结构struct client_data&#123;    sockaddr_in address;    int sockfd;    char buf[BUFFER_SIZE];  // 存储数据缓冲区    heap_timer* timer;&#125;;\n\n这是一个名为 client_data 的结构体，用于存储与客户端相关的数据。结构体的成员包括：\n\naddress：一个 sockaddr_in 类型的成员，用于存储客户端的地址信息。\nsockfd：一个整数，用于存储与客户端关联的套接字描述符。\nbuf：一个字符数组，用于存储数据缓冲区，大小为 BUFFER_SIZE。\ntimer：一个指向 heap_timer 类的指针，用于关联客户端数据与堆定时器。\n\n基于堆的定时器类定义了一个名为 heap_timer 的类，用于表示堆定时器。这个类包含了一个过期时间 expire，一个回调函数指针 cb_func，以及一个指向 client_data 结构体的指针 user_data。\nclass heap_timer &#123;public:    // 构造函数，接受一个延时参数 delay，计算过期时间    heap_timer(int delay) &#123;        expire = time(NULL) + delay;    &#125;public:    time_t expire;               // 定时器的过期时间    void (*cb_func)(client_data*);  // 回调函数指针，用于定时器到期时执行某个操作    client_data* user_data;      // 指向用户数据结构的指针&#125;;\n\n这个类的实例在构造时计算了过期时间，过期时间的计算基于当前时间加上传入的延时参数。这样，你可以通过创建 heap_timer 的实例来表示一个堆定时器，并设置回调函数和用户数据。\n注意，这个类中使用了 time_t 类型，它是一个表示时间的数据类型。time(NULL) 返回当前时间的秒数，因此 expire 表示的是定时器的过期时刻。在实际使用中，你可以创建一个 heap_timer 实例，设置回调函数和用户数据，然后使用这个实例来管理定时器。\n时间堆类timer_heap 类：\n\ntimer_heap 类表示一个基于最小堆的时间堆定时器，包含以下成员变量和方法：\narray：堆数组，存储堆定时器。\ncapacity：堆数组的容量。\ncur_size：当前堆数组中包含的元素个数。\n\n\n构造函数：\n构造函数1：初始化一个大小为 cap 的空堆。\n构造函数2：用已有的数组 init_array 来初始化堆，同时指定堆的大小和容量。\n\n\n析构函数：释放堆数组中的定时器内存。\nadd_timer 方法：向堆中添加目标定时器，如果堆数组容量不够，则扩大一倍容量，并执行上虑操作。\ndel_timer 方法：将目标定时器的回调函数设置为空，实现延迟销毁。\ntop 方法：获取堆顶部的定时器。\npop_timer 方法：删除堆顶部的定时器，同时执行下虑操作。\ntick 方法：心跳函数，处理堆数组中到期的定时器，执行定时器的回调函数。\nempty 方法：判断堆数组是否为空。\npercolate_down 方法：最小堆的下虑操作，确保堆数组中以指定节点作为根的子树拥有最小堆的性质。\nresize 方法：将堆数组容量扩大一倍。\n\n构造函数 timer_heap(int cap)目的是在堆上动态分配一个数组，用于存储堆定时器的指针，并将数组中的每个元素初始化为 nullptr，表示初始时堆为空。这是 time_heap 类中的一个构造函数，用于创建一个指定容量的空堆。\n// 构造函数之一：初始化一个大小为cap的空堆timer_heap(int cap) throw(exception) : capacity(cap), cur_size(0) &#123;    // 创建堆数组    array = new heap_timer*[capacity];    if(array == nullptr)&#123;        throw exception();    &#125;    for(int i = 0; i &lt; capacity; ++i)&#123;        array[i] = nullptr;    &#125;&#125;\n\n\ntimer_heap(int cap) throw(exception)：构造函数的声明，接受一个整数参数 cap，表示初始化堆的容量。\n: capacity(cap), cur_size(0)：成员初始化列表，用于对类成员进行初始化。capacity 被初始化为 cap，表示堆的容量；cur_size 被初始化为 0，表示当前堆中元素的个数。\narray = new heap_timer*[capacity]：在堆上分配一个 heap_timer* 类型的数组，用于存储堆定时器的指针。capacity 决定了数组的大小。\nif(array == nullptr)：检查数组是否成功分配。如果分配失败，即 new 操作返回 nullptr，则抛出异常。\nfor(int i = 0; i &lt; capacity; ++i)：遍历数组，将每个元素初始化为 nullptr，确保数组中的指针都初始化为 nullptr，表示初始时堆中没有定时器。\n\n最小堆的下沉操作 percolate_down这段代码实现了保持最小堆性质的下沉操作，确保以指定节点为根的子树拥有最小堆性质。在堆的插入和删除操作中，通过不断执行下沉操作，可以维护整个堆的最小堆性质。\n// 最小堆的下沉操作，它确保数组中以第hole个节点为根的子树拥有最小堆性质void percolate_down(int hole) &#123;    heap_timer* tmp = array[hole];    int child = 0;    for (; (hole * 2 + 1) &lt;= (cur_size - 1); hole = child) &#123;        child = hole * 2 + 1;        // 找到hole子节点中最小的节点child        if ((child &lt; (cur_size - 1)) &amp;&amp; (array[child + 1]-&gt;expire &lt; array[child]-&gt;expire)) &#123;            ++child;        &#125;        // 如果子节点的过期时间小于当前节点的过期时间，则交换它们的位置        if (array[child]-&gt;expire &lt; tmp-&gt;expire) &#123;            array[hole] = array[child];        &#125; else &#123;            // 否则，直接跳出循环，因为子树中不会存在不满足最小堆性质的节点了            break;        &#125;    &#125;    // 找到hole最终位置，并赋值    array[hole] = tmp;&#125;\n\n\nheap_timer* tmp = array[hole];：保存当前节点的指针，准备进行下沉操作。\nint child = 0;：初始化子节点的索引。\nfor (; (hole * 2 + 1) &lt;= (cur_size - 1); hole = child)：循环进行下沉操作，直到当前节点没有子节点或者满足最小堆性质。\nchild = hole * 2 + 1;：计算左子节点的索引。\nif ((child &lt; (cur_size - 1)) &amp;&amp; (array[child + 1]-&gt;expire &lt; array[child]-&gt;expire))：如果右子节点存在且比左子节点的过期时间小，就选择右子节点作为最小的子节点。\nif (array[child]-&gt;expire &lt; tmp-&gt;expire)：如果最小的子节点的过期时间小于当前节点的过期时间，则交换它们的位置。\nelse &#123; break; &#125;：如果当前节点的过期时间已经小于等于最小的子节点，说明已经满足最小堆性质，直接跳出循环。\narray[hole] = tmp;：将当前节点移动到最终位置，保持最小堆性质。\n\n构造函数 timer_heap(heap_timer** init_array, int size, int capacity)这段代码的目的是在堆上动态分配一个数组，用于存储堆定时器的指针，并根据传入的初始化数组进行初始化。初始化完成后，通过执行下滤操作，确保整个数组满足最小堆性质。这是 time_heap 类中的另一个构造函数，用于创建一个包含初始元素的堆。\n// 构造函数之二：用已有的数组来初始化堆timer_heap(heap_timer** init_array, int size, int capacity) throw(exception) : capacity(capacity), cur_size(size) &#123;    if (capacity &lt; size) &#123;        throw exception();    &#125;    // 创建堆数组    array = new heap_timer*[capacity];    if (array == nullptr) &#123;        throw exception();    &#125;    for (int i = 0; i &lt; capacity; ++i) &#123;        array[i] = nullptr;    &#125;    if (size != 0) &#123;        // 初始化堆数组        for (int i = 0; i &lt; size; ++i) &#123;            array[i] = init_array[i];        &#125;        for (int i = (cur_size - 1) / 2; i &gt;= 0; i--) &#123;            // 对数组中的第[(cur_size - 1) / 2] ~ 0个元素进行下坠操作            percolate_down(i);        &#125;    &#125;&#125;\n\n\ntimer_heap(heap_timer** init_array, int size, int capacity) throw(exception)：构造函数的声明，接受一个指向 heap_timer* 数组的指针 init_array，以及数组的大小 size 和堆的容量 capacity。\n在这里，: throw(exception) 意味着该构造函数声明或定义时声明了一个异常规范（exception specification）。这个异常规范表示该构造函数可能抛出任何异常，但是如果它抛出异常，它将是 std::exception 类型的异常。在现代 C++ 中，异常规范已经被认为是过时的，通常不建议使用。\n: capacity(capacity), cur_size(size)：成员初始化列表，用于对类成员进行初始化。capacity 被初始化为传入的 capacity，表示堆的容量；cur_size 被初始化为传入的 size，表示当前堆中元素的个数。\nif (capacity &lt; size)：检查传入的容量是否小于数组的大小，如果是则抛出异常。\narray = new heap_timer*[capacity];：在堆上分配一个 heap_timer* 类型的数组，用于存储堆定时器的指针。capacity 决定了数组的大小。\nif (array == nullptr)：检查数组是否成功分配。如果分配失败，即 new 操作返回 nullptr，则抛出异常。\nfor (int i = 0; i &lt; capacity; ++i)：遍历数组，将每个元素初始化为 nullptr，确保数组中的指针都初始化为 nullptr，表示初始时堆为空。\nif (size != 0)：如果传入的数组大小不为零，说明有初始化的元素，进行以下操作：\n遍历初始化数组，将其中的元素拷贝到堆数组中。\n对数组中的前半部分元素（即从最后一个非叶子节点开始）执行下滤操作，确保整个数组满足最小堆性质。\n\n\n\n析构函数 ~timer_heap这段代码的目的是确保在销毁 timer_heap 对象时，释放它所管理的所有 heap_timer 对象的内存，以及释放堆数组本身的内存。这是一种良好的实践，以防止内存泄漏。\n// 销毁时间堆~timer_heap() &#123;    for (int i = 0; i &lt; cur_size; ++i) &#123;        delete array[i];    &#125;    delete[] array;&#125;\n\n\n~timer_heap(): 析构函数的声明，表示当对象被销毁时会执行这段代码。\nfor (int i = 0; i &lt; cur_size; ++i): 循环遍历堆数组中的每个元素。\ndelete array[i]: 删除堆数组中每个元素指向的 heap_timer 对象。这个操作会调用相应对象的析构函数。\ndelete[] array: 删除堆数组本身，释放数组占用的内存。\n\n堆数组容量 resize这段代码的目的是在堆数组容量不足时，动态地将其扩大一倍。这是一种动态管理内存的策略，以适应动态变化的堆大小需求。\n// 将堆数组容量扩大1倍void resize() throw(exception) &#123;    heap_timer** temp = new heap_timer*[2 * capacity];    for (int i = 0; i &lt; 2 * capacity; ++i) &#123;        temp[i] = nullptr;    &#125;    if (temp == nullptr) &#123;        throw exception();    &#125;    capacity = 2 * capacity;    for (int i = 0; i &lt; cur_size; i++) &#123;        temp[i] = array[i];    &#125;    delete[] array;    array = temp;&#125;\n\n\nvoid resize() throw(exception): resize 是一个成员函数，用于将堆数组容量扩大一倍。throw(exception) 表示该函数可能抛出 std::exception 类型的异常。\nheap_timer** temp = new heap_timer*[2 * capacity];: 在堆上动态分配一个新的数组 temp，其大小是原来数组容量的两倍。\nfor (int i = 0; i &lt; 2 * capacity; ++i): 初始化新数组中的每个元素为 nullptr。\nif (temp == nullptr): 检查新数组是否成功分配。如果分配失败，即 new 操作返回 nullptr，则抛出异常。\ncapacity = 2 * capacity;: 更新堆数组的容量。\nfor (int i = 0; i &lt; cur_size; i++): 将原数组中的元素拷贝到新数组中。\ndelete[] array;: 删除原来的堆数组，释放原数组占用的内存。\narray = temp;: 将类成员 array 指向新的数组，完成扩容。\n\n添加目标定时器 add_timer这段代码的目的是将一个新的定时器插入到时间堆中，并确保时间堆的最小堆性质仍然得以保持。\n// 添加目标定时器void add_timer(heap_timer* timer) throw(exception) &#123;    if (timer == nullptr) &#123;        throw exception();    &#125;    // 如果当前堆数组容量不够，扩大一倍容量    if (cur_size &gt;= capacity) &#123;        resize();    &#125;    // 新插入了一个元素，当前堆的大小加1，hole是新建空节点的位置    int hole = cur_size++;    int parent = 0;    // 对从空节点到根节点的路径上的所有节点执行上浮操作    for (; hole &gt; 0; hole = parent) &#123;        // 计算父节点的位置        parent = (hole - 1) / 2;        if (array[parent]-&gt;expire &lt;= timer-&gt;expire) &#123;            break;        &#125;        array[hole] = array[parent];    &#125;    array[hole] = timer;&#125;\n\n\nvoid add_timer(heap_timer* timer) throw(exception): add_timer 是一个成员函数，用于向时间堆中添加目标定时器。throw(exception) 表示该函数可能抛出 std::exception 类型的异常。\nif (timer == nullptr): 检查传入的定时器指针是否为 nullptr。如果是，抛出异常。\nif (cur_size &gt;= capacity): 检查当前堆数组容量是否不足。如果不足，调用 resize() 函数进行扩容。\nint hole = cur_size++;: hole 表示新插入的元素的位置，同时递增 cur_size 表示当前堆的大小。\nint parent = 0;: 初始化父节点的位置为根节点。\nfor (; hole &gt; 0; hole = parent): 循环执行上浮操作，直到新插入的元素找到合适的位置。\nparent = (hole - 1) / 2;: 计算当前节点的父节点的位置。\nif (array[parent]-&gt;expire &lt;= timer-&gt;expire): 检查父节点的定时器是否小于等于新插入的定时器。如果是，说明已经找到了合适的位置，跳出循环。\narray[hole] = array[parent];: 将父节点的定时器下移到当前节点的位置。\narray[hole] = timer;: 将新插入的定时器放置到当前节点的位置。\n\n删除目标定时器 del_timer这段代码的目的是通过将目标定时器的回调函数设置为空，实现对定时器的“延迟销毁”。\n// 删除目标定时器void del_timer(heap_timer* timer) &#123;    if (timer == nullptr) &#123;        return;    &#125;    /* 仅仅将目标定时器的回调函数设置为空, 即所谓的延迟销毁.     * 将节省真正删除该定时器造成的开销, 但这样容易使堆数组膨胀 */    // FIXME: 删除定时器, 为何不重新调整堆?    timer-&gt;cb_func = nullptr;&#125;\n\n\nvoid del_timer(heap_timer* timer): del_timer 是一个成员函数，用于删除目标定时器。\nif (timer == nullptr): 检查传入的定时器指针是否为 nullptr。如果是，直接返回，不执行删除操作。\ntimer-&gt;cb_func = nullptr;: 将目标定时器的回调函数指针设置为空，即延迟销毁。这种操作确实可以避免直接删除定时器对象造成的开销，但是作者在注释中提到这样容易使堆数组膨胀。注释中还提到了一个 FIXME（修复），暗示这里的处理方式可能不是最理想的。在实际使用中，如果要删除定时器并避免膨胀，可能需要对时间堆的底层数据结构进行更多的调整。\n\n优化 删除目标定时器 del_timer这个修改中，添加了 percolate_up 和 percolate_down 函数，用于分别执行上浮和下沉操作，以保持最小堆的性质。需要根据具体实现，调整这两个函数的实现以适应代码。这样，删除定时器时就会真正地从堆中去除节点。\n// 删除目标定时器void del_timer(heap_timer* timer) &#123;    if (timer == nullptr) &#123;        return;    &#125;    // 找到目标定时器在堆数组中的位置    for (int i = 0; i &lt; cur_size; ++i) &#123;        if (array[i] == timer) &#123;            // 将目标定时器的位置上的元素替换为堆数组中最后一个元素            array[i] = array[cur_size - 1];            cur_size--;            // 调整堆，保持最小堆的性质            if (i != 0 &amp;&amp; array[(i - 1) / 2]-&gt;expire &gt; array[i]-&gt;expire) &#123;                percolate_up(i);            &#125; else &#123;                percolate_down(i);            &#125;            break;        &#125;    &#125;&#125;\n\n获得堆顶部的定时器 top这段代码的目的是提供一种获取堆顶部定时器的方式，同时考虑了堆为空的情况，以防止访问空数组。\n// 获得堆顶部的定时器heap_timer* top() const &#123;    if (empty()) &#123;        return nullptr;    &#125;    return array[0];&#125;\n\n\nheap_timer* top() const: top 是一个成员函数，用于获取堆顶部的定时器。const 表示该函数不会修改成员变量。\nif (empty()): 调用 empty() 函数来检查堆是否为空。\nreturn array[0];: 如果堆不为空，则返回堆数组中的第一个元素，即堆顶部的定时器。\nreturn nullptr;: 如果堆为空，则返回 nullptr 表示没有定时器。\n\n删除堆顶部的定时器 pop_timer这段代码的目的是删除堆顶部的定时器，并通过将堆顶元素替换为堆数组中最后一个元素，并执行下坠操作，以保持最小堆的性质。\n// 删除堆顶部的定时器void pop_timer()&#123;    if(empty())&#123;        return ;    &#125;    if(array[0] != nullptr)&#123;        delete array[0];        // 将原来堆顶元素替换为堆数组中最后一个元素        array[0] = array[--cur_size];        percolate_down(0);  // 对新的堆顶元素执行下坠操作    &#125;&#125;\n\n\nvoid pop_timer(): pop_timer 是一个成员函数，用于删除堆顶部的定时器。\nif (empty()): 调用 empty() 函数来检查堆是否为空。\nif (array[0] != nullptr): 检查堆顶部的定时器是否为空。\ndelete array[0];: 删除堆顶部的定时器。\narray[0] = array[--cur_size];: 将原来堆顶元素替换为堆数组中最后一个元素，并减小堆的大小。\npercolate_down(0);: 对新的堆顶元素执行下坠操作，以保持最小堆的性质。\n\n心搏函数 tick这段代码的目的是在循环中处理堆中到期的定时器，执行其任务，并将其删除，直到堆中没有到期的定时器或者堆为空。\n// 心搏函数void tick()&#123;    heap_timer *tmp = array[0];    time_t cur = time(NULL);    /* 循环处理堆中到期的定时器 */    while(!empty())&#123;        if(tmp == nullptr)&#123;            break;        &#125;        // 如果堆顶定时器没到期，则退出循环        if(tmp-&gt;expire &gt; cur)&#123;            break;        &#125;        // 否则执行堆顶定时器任务        if(array[0]-&gt;cb_func)&#123;            array[0]-&gt;cb_func(array[0]-&gt;user_data);        &#125;        // 将堆顶元素删除，同时生成新的堆顶定时器        pop_timer();        tmp = array[0];    &#125;&#125;\n\n\nvoid tick(): tick 是一个成员函数，用于处理到期的定时器。\nheap_timer* tmp = array[0];: 获取堆顶部的定时器。\ntime_t cur = time(NULL);: 获取当前时间。\nwhile (!empty()): 进入循环，处理堆中到期的定时器。\nif (tmp == nullptr): 检查堆顶定时器是否为空，如果是，则退出循环。\nif (tmp-&gt;expire &gt; cur): 如果堆顶定时器的到期时间大于当前时间，说明后面的定时器都还没有到期，退出循环。\nif (array[0]-&gt;cb_func): 如果堆顶定时器的回调函数不为空，执行回调函数，即执行定时器任务。\npop_timer(): 将堆顶元素删除，同时生成新的堆顶定时器，继续循环。\n\n单元测试#include &quot;heap_timer.h&quot;#include &lt;unistd.h&gt;void callback_func(client_data* user_data) &#123;    // 在这里进行定时器到期时的操作，这里只是简单打印一条消息    printf(&quot;Timer expired! sockfd: %d\\n&quot;, user_data-&gt;sockfd);&#125;int main() &#123;    // 创建时间堆对象    timer_heap ht(10);    // 添加一些定时器    heap_timer* timer1 = new heap_timer(5);  // 5秒后触发    timer1-&gt;cb_func = callback_func;    client_data data1;    data1.sockfd = 1;    data1.timer = timer1;    timer1-&gt;user_data = &amp;data1;    ht.add_timer(timer1);    // 添加一些定时器     heap_timer* timer2 = new heap_timer(10);  // 10秒后触发    timer2-&gt;cb_func = callback_func;    client_data data2;    data2.sockfd = 2;    data2.timer = timer2;    timer2-&gt;user_data = &amp;data2;    ht.add_timer(timer2);    // 添加一些定时器     heap_timer* timer3 = new heap_timer(15);  // 15秒后触发    timer3-&gt;cb_func = callback_func;    client_data data3;    data3.sockfd = 3;    data3.timer = timer3;    timer3-&gt;user_data = &amp;data3;    ht.add_timer(timer3);    // 添加一些定时器     heap_timer* timer4 = new heap_timer(8);  // 15秒后触发    timer4-&gt;cb_func = callback_func;    client_data data4;    data4.sockfd = 4;    data4.timer = timer4;    timer4-&gt;user_data = &amp;data4;    ht.add_timer(timer4);    // 模拟时间流逝，每秒调用一次时间轮的 tick 函数    for (int i = 0; i &lt; 76; ++i) &#123;        printf( &quot;current i = %d\\n&quot;,i);        sleep(1);        ht.tick();    &#125;    return 0;&#125;\n\nadd timer 1 top 1add timer 2 top 1add timer 3 top 1add timer 4 top 1current i = 0current i = 1current i = 2current i = 3current i = 4Timer expired! sockfd: 1current top is 4current i = 5current i = 6current i = 7Timer expired! sockfd: 4current top is 2current i = 8current i = 9Timer expired! sockfd: 2current top is 3current i = 10current i = 11current i = 12current i = 13current i = 14Timer expired! sockfd: 3current top is 3current i = 15current i = 16current i = 17current i = 18current i = 19...current i = 71current i = 72current i = 73current i = 74current i = 75\n\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"定时器之时间轮","url":"/2024/01/04/%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B9%8B%E6%97%B6%E9%97%B4%E8%BD%AE/","content":"定时器之时间轮基于排序链表的定时器存在一个问题：添加定时器的效率偏低。一种简单的时间轮如图所示：\n\n在这个时间轮中，实线指针指向轮子上的一个槽（slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽（slot）。每次转动称为一个滴答（tick）。一个tick时间间隔为时间轮的si（slot interval）。该时间轮共有N个槽，因此它转动一周的时间是N*si。每个槽指向一条定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间相差N*si的整数倍。时间轮正是利用这个关系将定时器散列到不同的链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时器，则该定时器将被插入槽ts（timer slot）对应的链表中：这个公式用于计算在时间轮中插入定时器时，定时器应该插入的槽（slot）位置。\ncs：当前指针指向的槽的位置\nti/si：定时器的定时时间\nsi：槽间隔，即每个槽代表的时间\nN：时间轮的槽数。\n具体解释如下：\n\n计算定时器应该插入的槽相对于当前指针指向的槽的偏移量：ti/si。这个偏移量表示定时器的定时时间需要经过多少个槽间隔。\n将偏移量加上当前指针指向的槽的位置 cs，得到插入槽的绝对位置。\n使用模运算 N，确保插入的槽位置在时间轮的范围内。这是因为时间轮是循环的，超过最大槽数时需要回到起点。\n\n因此，公式的含义是，根据当前指针指向的槽位置和定时器的定时时间，计算出定时器应该插入的槽位置。\n基于排序链表的定时器使用唯一的一条链表来管理所有的定时器，所以插入操作的效率随着定时器的数目增多而降低。而时间轮使用了哈希表处理冲突的思想，将定时器散列到不同的链表上。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。很显然，对于时间轮而言，要提高精度，就要使si的值足够小; 要提高执行效率，则要求N值足够大，使定时器尽可能的分布在不同的槽。\n客户端结构体这样的结构体通常用于存储与网络编程相关的客户端数据，其中 tw_timer 类型的 timer 成员可能用于实现定时器功能，用于跟踪特定客户端的超时或其他时间相关事件。\n// 前向声明class tw_timer;// 用户数据结构struct client_data{    sockaddr_in address;    int sockfd;    char buf[BUFFER_SIZE];  // 存储数据缓冲区    tw_timer* timer;}\n\n定义了一个名为 client_data 的结构体，其中包含以下成员：\n\naddress: 一个 sockaddr_in 类型的成员，用于存储网络地址信息。\nsockfd: 一个整数类型的成员，用于存储套接字描述符。\nbuf: 一个字符数组，大小为 BUFFER_SIZE，用于存储数据缓冲区。\ntimer: 一个指向 tw_timer 类型对象的指针。这个指针用于关联一个计时器对象到用户数据结构中。\n\n基于时间轮的定时器类构造函数使用成员初始化列表来初始化类的成员变量，而在类中的两个 public: 标记之间，有一个 public 访问修饰符，表示以下成员（rotation、time_slot等）都是公有的，可以在类外部访问。\n// 基于时间轮的定时器类class tw_timer{public:    tw_timer(int rot, int ts)    :next(nullptr),prev(nullptr),rotation(rot),time_slot(ts){}public:    int rotation;                   // 记录定时器在时间轮转多少圈后生效    int time_slot;                  // 记录定时器属于哪一个槽    void (*cb_func)(client_data*);  // 回调函数    client_data *user_data;         // 指向用户的指针    tw_timer* next;                 //指向上一个定时器    tw_timer* prev;                 //指向下一个定时器};\n\n\nrotation 和 time_slot 是用于记录定时器在时间轮中的位置的整数成员变量。\ncb_func 是一个函数指针，指向一个回调函数，该函数接受一个 client_data* 参数，用于在定时器触发时执行特定的操作。\nuser_data 是一个指向 client_data 结构体的指针，用于存储与定时器相关联的用户数据。\nnext 和 prev 是指向下一个和上一个定时器节点的指针，用于在时间轮上组织定时器节点的链表结构。\n\n\n在C++中，类的构造函数体中的成员初始化列表是在花括号之后定义的，并且这个列表的最后不需要分号。这是因为成员初始化列表的目的是初始化类的成员变量，而不是执行语句块。分号通常用于终结语句，而成员初始化列表不是一个语句块，而是一个在构造函数体之前执行的特殊部分。\n\n\n\n时间轮类// 时间轮类：管理定时器class timer_wheel{public:private:    static const int N = 60;    // 时间轮的槽数    static const int TI = 1;    // 时间轮的槽间隔    tw_timer* slots[N];         // 每个槽的头指针，指向定时器链表的头节点    int cur_slot;               // 当前时间轮指向的槽};\n\n构造函数 timer_wheel这段代码的目的是在创建时间轮对象时，将类的成员变量初始化为合适的初始值。初始化列表用于初始化 cur_slot，而循环语句用于将每个槽的头指针初始化为空指针。\ntimer_wheel() : cur_slot(0) {    for (int i = 0; i &lt; N; ++i) {        slots[i] = nullptr;     // 每个槽点头节点初始化为空    }}\n\n\ntimer_wheel(): 这是构造函数的定义，表示创建 timer_wheel 类的对象时将执行的初始化操作。\n: cur_slot(0): 成员初始化列表的一部分，用于将 cur_slot 成员变量初始化为0。这表示时间轮创建时，当前指针指向槽0。\nfor (int i = 0; i &lt; N; ++i): 这是一个循环语句，用于遍历时间轮的每个槽。\nslots[i] = nullptr;: 在循环中，每次迭代都将 slots[i] 初始化为 nullptr，表示每个槽的头指针初始为空。这是因为在时间轮创建时，还没有任何定时器加入。\n\n析构函数 ~timer_wheel这段代码的目的是在销毁时间轮对象时，遍历每个槽中的定时器链表，并释放每个定时器节点占用的内存，确保没有内存泄漏。\n~timer_wheel(){    for(int i = 0; i &lt; N; i++){        tw_timer* tmp = slots[i];        while(tmp != nullptr){            slots[i] = tmp-&gt;next;            delete tmp; // 遍历每个槽销毁new分配在堆中的定时器            tmp = slots[i];        }    }}\n\n\n~timer_wheel(): 这是析构函数的定义，表示当 timer_wheel 类的对象被销毁时将执行的清理操作。\nfor (int i = 0; i &lt; N; i++): 这是一个循环语句，用于遍历时间轮的每个槽。\ntw_timer* tmp = slots[i];: 在循环中，首先声明一个指针 tmp 并将其初始化为当前槽的头指针 slots[i]。\nwhile (tmp != nullptr) {: 这是一个 while 循环，用于遍历当前槽中的定时器链表。\nslots[i] = tmp-&gt;next;: 将当前槽的头指针指向下一个定时器节点，以准备下一次循环。\ndelete tmp;: 删除当前定时器节点，释放其在堆上分配的内存。\ntmp = slots[i];: 更新 tmp 指针，指向当前槽的头指针，以便继续下一次循环。\n\n添加新的定时器 add_timer这个函数的目的是根据给定的超时时间，在时间轮中创建并插入一个定时器，并返回指向该定时器的指针。\n// 根据 timeout 创建一个定时器, 并插入时间轮,     // 返回创建的定时器指针, 用户拿到指针后再加入对应的用户数据    tw_timer* add_timer(int timeout){   // 添加新的定时器，插入到合适的槽中        if(timeout &lt; 0){    // 时间错误            return nullptr;        }        // 计算定时器在多少个 SI 时间后触发        int ticks = 0;        if(timeout &lt; TI){   // 小于每个槽点间隔时间，则为1            ticks = 1;        }else{            ticks = timeout / TI;   // 相对当前位置的槽数        }        int rotation = ticks / N;   // 记录多少圈后生效        int ts = (cur_slot + (ticks % N)) % N;  // 确定插入槽点位置        tw_timer* timer = new tw_timer(rotation,ts);    // 根据位置和圈数，插入对应的槽中        if(slots[ts] == nullptr){ // 所在槽头节点为空，直接插入            printf( \"add timer, rotation is %d, ts is %d, cur_slot is %d\\n\", rotation, ts, cur_slot );            slots[ts] = timer;        }else{  // 头插法            timer-&gt;next = slots[ts];            slots[ts]-&gt;prev = timer;            slots[ts] = timer;        }        return timer;   // 返回含有时间信息和所在槽位置的定时器    }\n\n\nif (timeout &lt; 0): 如果超时时间小于0，表示时间错误，返回空指针。\nint ticks = (timeout &lt; TI) ? 1 : (timeout / TI);: 计算定时器在多少个槽间隔时间后触发。\nint rotation = ticks / N;: 记录多少圈后定时器生效。\nint ts = (cur_slot + (ticks % N)) % N;: 确定插入槽点位置。\ntw_timer* timer = new tw_timer(rotation, ts);: 根据位置和圈数创建一个新的 tw_timer 对象。\nif (slots[ts] == nullptr) { ... } else { ... }: 根据槽中是否已经有定时器节点，采用直接插入或头插法插入新的定时器节点。\nreturn timer;: 返回含有时间信息和所在槽位置的定时器指针。\n\n删除目标定时器 del_timer// 删除目标定时器, 当轮子的槽较多时, 复杂度接近 O(n)void del_timer(tw_timer* timer){    // 从时间轮上删除定时器    if(timer == nullptr){        return ;    }    int ts = timer-&gt;time_slot;  // 找到所在槽索引    // 删除操作    if(timer == slots[ts]){     // 头节点特殊处理        slots[ts] = slots[ts]-&gt;next;        if(slots[ts] != nullptr){            slots[ts]-&gt;prev = nullptr;        }        delete timer;    }else{      // 其他节点, 双链表的删除操作        timer-&gt;prev-&gt;next = timer-&gt;next;        if(timer-&gt;next != nullptr){            timer-&gt;next-&gt;prev = timer-&gt;prev;        }        delete timer;    }}\n\n这个函数的目的是从时间轮中删除指定的定时器。\n\nif (timer == nullptr) { return; }: 如果传入的定时器指针为空，直接返回，不执行删除操作。\nint ts = timer-&gt;time_slot;: 获取定时器所在槽的索引。\nif (timer == slots[ts]) { ... } else { ... }: 如果目标定时器是头节点，则特殊处理，否则执行双链表的删除操作。\nslots[ts] = slots[ts]-&gt;next;: 更新槽的头节点指针。\nif (slots[ts] != nullptr) { slots[ts]-&gt;prev = nullptr; }: 如果新的头节点不为空，更新其前驱指针为 nullptr。\ndelete timer;: 删除目标定时器。\n如果目标定时器不是头节点，执行双链表的删除操作：\ntimer-&gt;prev-&gt;next = timer-&gt;next;: 更新前一个节点的后继指针。\nif (timer-&gt;next != nullptr) { timer-&gt;next-&gt;prev = timer-&gt;prev; }: 如果目标定时器的后继节点不为空，更新其前驱指针。\ndelete timer;: 删除目标定时器。\n\n\n\n\n\n心跳函数 tick// 心跳函数，每次跳完之后轮子向前走一个槽void tick(){    tw_timer *tmp = slots[cur_slot];    printf( \"current slot is %d\\n\", cur_slot );    // 遍历当前槽所指向的链表    while (tmp != nullptr)    {        printf( \"tick the timer once\\n\" );        if(tmp-&gt;rotation &gt; 0){            tmp-&gt;rotation--;            tmp = tmp-&gt;next;        }else{  // 处理到期的定时器            // 回调            tmp-&gt;cb_func(tmp-&gt;user_data);            if(tmp == slots[cur_slot]){                printf( \"delete header in cur_slot\\n\" );                slots[cur_slot] = tmp-&gt;next;                delete tmp;                if(slots[cur_slot] != nullptr){                    slots[cur_slot]-&gt;prev = nullptr;                }                tmp = slots[cur_slot];            }else{                tmp-&gt;prev-&gt;next = tmp-&gt;next;                if(tmp-&gt;next != nullptr){                    tmp-&gt;next-&gt;prev = tmp-&gt;prev;                }                tw_timer* tmp2 = tmp-&gt;next;                delete tmp;                tmp = tmp2;            }        }    }    cur_slot = ++cur_slot % N;  // 轮子往后走一个槽}\n\n这个函数是时间轮的心跳函数，用于处理定时器的到期事件。函数逻辑如下：\n\ntw_timer* tmp = slots[cur_slot];: 获取当前槽头节点指针。\nprintf(\"current slot is %d\\n\", cur_slot);: 打印当前槽的索引。\nwhile (tmp != nullptr) { ... }: 遍历当前槽所指向的链表。\nif (tmp-&gt;rotation &gt; 0) { ... } else { ... }: 如果定时器的剩余轮数大于0，减少轮数并移动到下一个定时器。\n如果定时器剩余轮数为0，表示定时器到期，执行以下操作：\ntmp-&gt;cb_func(tmp-&gt;user_data);: 调用定时器的回调函数。\n判断是否是头节点：\n如果是头节点：\nprintf(\"delete header in cur_slot\\n\");: 打印删除头节点的消息。\nslots[cur_slot] = tmp-&gt;next;: 更新头节点指针。\ndelete tmp;: 删除当前定时器。\n如果新的头节点不为空，更新其前驱指针。\ntmp = slots[cur_slot];: 更新 tmp 指针。\n\n\n如果不是头节点：\ntmp-&gt;prev-&gt;next = tmp-&gt;next;: 更新前一个节点的后继指针。\n如果定时器的后继节点不为空，更新其前驱指针。\ntw_timer* tmp2 = tmp-&gt;next;: 保存下一个定时器节点的指针。\ndelete tmp;: 删除当前定时器。\ntmp = tmp2;: 更新 tmp 指针。\n\n\n\n\n\n\n\n\ncur_slot = ++cur_slot % N;: 轮子往后走一个槽，更新当前槽的索引。\n\ntmp = slots[cur_slot]; 这行代码的目的是将 tmp 指针重新指向当前槽的头节点，以便在下一轮循环中继续遍历当前槽所指向的定时器链表。\n在心跳函数中，tmp 指针用于遍历当前槽的定时器链表，处理每个定时器的情况。当一个定时器到期并被处理后，可能会影响当前槽的链表结构（例如删除头节点），所以在处理完一个定时器后，需要重新将 tmp 指针指向当前槽的新的头节点，以确保下一次循环可以正确遍历整个链表。\n\n\n单元测试#include \"timer_wheel.h\"#include &lt;unistd.h&gt;void callback_func(client_data* user_data) {    // 在这里进行定时器到期时的操作，这里只是简单打印一条消息    printf(\"Timer expired! sockfd: %d\\n\", user_data-&gt;sockfd);}int main() {    // 创建时间轮对象    timer_wheel tw;    // 添加一些定时器    tw_timer* timer1 = tw.add_timer(5);  // 5秒后触发    timer1-&gt;cb_func = callback_func;    client_data data1;    data1.sockfd = 1;    data1.timer = timer1;    timer1-&gt;user_data = &amp;data1;    tw_timer* timer2 = tw.add_timer(10);  // 10秒后触发    timer2-&gt;cb_func = callback_func;    client_data data2;    data2.sockfd = 2;    data2.timer = timer2;    timer2-&gt;user_data = &amp;data2;    tw_timer* timer3 = tw.add_timer(15);  // 15秒后触发    timer3-&gt;cb_func = callback_func;    client_data data3;    data3.sockfd = 3;    data3.timer = timer3;    timer3-&gt;user_data = &amp;data3;    tw_timer* timer4 = tw.add_timer(65);  // 15秒后触发    timer4-&gt;cb_func = callback_func;    client_data data4;    data4.sockfd = 4;    data4.timer = timer4;    timer4-&gt;user_data = &amp;data4;    tw_timer* timer5 = tw.add_timer(75);  // 15秒后触发    timer5-&gt;cb_func = callback_func;    client_data data5;    data5.sockfd = 5;    data5.timer = timer5;    timer5-&gt;user_data = &amp;data5;    // 模拟时间流逝，每秒调用一次时间轮的 tick 函数    for (int i = 0; i &lt; 76; ++i) {        sleep(1);        tw.tick();    }    return 0;}\n\nadd timer, rotation is 0, ts is 5, cur_slot is 0add timer, rotation is 0, ts is 10, cur_slot is 0add timer, rotation is 0, ts is 15, cur_slot is 0add timer, rotation is 1, ts is 5, cur_slot is 0add timer, rotation is 1, ts is 15, cur_slot is 0current slot is 0current slot is 1current slot is 2current slot is 3current slot is 4current slot is 5tick the timer oncetick the timer onceTimer expired! sockfd: 1delete ordinary node in cur_slotcurrent slot is 6current slot is 7current slot is 8current slot is 9current slot is 10tick the timer onceTimer expired! sockfd: 2delete header in cur_slotcurrent slot is 11current slot is 12current slot is 13current slot is 14current slot is 15tick the timer oncetick the timer onceTimer expired! sockfd: 3delete ordinary node in cur_slotcurrent slot is 16...current slot is 59current slot is 0current slot is 1current slot is 2current slot is 3current slot is 4current slot is 5tick the timer onceTimer expired! sockfd: 4delete header in cur_slotcurrent slot is 6current slot is 7current slot is 8current slot is 9current slot is 10current slot is 11current slot is 12current slot is 13current slot is 14current slot is 15tick the timer onceTimer expired! sockfd: 5delete header in cur_slot\n\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"实现多态的方法","url":"/2023/11/27/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%96%B9%E6%B3%95/","content":"实现多态的方法多态其实一般就是指继承加虚函数实现的多态，对于重载来说，实际上基于的原理是，编译器为函数生成符号表时的不同规则，重载只是一种语言特性，与多态无关，与面向对象也无关，但这又是 C++中增加的新规则，所以也算属于 C++，所以如果非要说重载算是多态的一种，那就可以说：多态可以分为静态多态和动态多态。\n静态多态其实就是重载，因为静态多态是指在编译时期就决定了调用哪个函数，根据参数列表来决定；\n动态多态是指通过子类重写父类的虚函数来实现的，因为是在运行期间决定调用的函数，所以称为动态多态，\n一般情况下我们不区分这两个时所说的多态就是指动态多态。\n动态多态的实现与虚函数表，虚函数指针相关。\n子类是否要重写父类的虚函数？\n子类继承父类时， 父类的纯虚函数必须重写，否则子类也是一个虚类不可实例化。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。\n","categories":["每日一题"],"tags":["c++"]},{"title":"手写线程池","url":"/2023/11/08/%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"手写线程池线程池原理线程池的组成主要分为3个部分，这三部分配合工作就可以得到一个完整的线程池：\n\n任务队列，存储需要处理的任务，由工作的线程来处理这些任务通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除已处理的任务会被从任务队列中删除线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程\n工作的线程（任务队列任务的消费者） ，N个线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理工作的线程相当于是任务队列的消费者角色，如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量&#x2F;信号量阻塞)如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作\n管理者线程（不处理任务队列中的任务），1个它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测当任务过多的时候, 可以适当的创建一些新的工作线程当任务过少的时候, 可以适当的销毁一些工作的线程\n\n\n1. c语言版main.c#include&lt;stdio.h&gt;#include &quot;threadpool.h&quot;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void taskFunc(void* arg)&#123;    int num = *(int*)arg;    printf(&quot;thread is working, number = %d, tid = %ld\\n&quot;,num,pthread_self());    usleep(1000);&#125;int main()&#123;    // 创建线程池    ThreadPool* pool = threadPoolCreate(3,10,100);    for(int i = 0; i &lt; 100; i++)&#123;                // threadPoolAdd(pool,taskFunc,&amp;i);        int* num = (int*)malloc(sizeof(int));        *num = i + 100;        threadPoolAdd(pool, taskFunc, num);    &#125;    sleep(30);    threadPoolDestory(pool);       return 0;&#125;\n\nthreadpool.c#include &quot;threadpool.h&quot;const int NUMBER = 2;//  任务结构体typedef struct  Task&#123;    void (*function)(void* arg);    //函数指针    void* arg;&#125;Task;//线程池结构体struct ThreadPool&#123;    //任务队列    Task* taskQ;    int queueCapacity;  // 容量     int queueSize;      //当前任务个数    int queueFront;     //队头  -&gt;取数据    int queueRear;      //队尾  &lt;-存数据    //管理者线程    pthread_t   managerID;  //管理者线程ID    //工作线程    pthread_t   *threadIDs; //工作的线程ID        int minNum;     //最小线程数量    int maxNum;     //最大线程数量    int busyNum;    //忙的线程个数    int liveNum;    //存活的线程个数    int exitNum;    //要销毁的线程个数    //互斥锁    pthread_mutex_t mutexPool;  //锁整个的线程池    pthread_mutex_t mutexBusy;  //锁busyNum变量    //条件变量    pthread_cond_t notFull;     //任务队列是不是满了    pthread_cond_t notEmpty;    //任务队列是不是空了    int shutdown;   //是不是要销毁线程池，销毁为1，不销毁为0&#125;;ThreadPool* threadPoolCreate(int min, int max, int queueSize)&#123;    ThreadPool* pool = (ThreadPool*)malloc(sizeof(ThreadPool));    do&#123;        if(pool == NULL)&#123;            printf(&quot;malloc threadpool fail...\\n&quot;);            break;        &#125;        pool-&gt;threadIDs = (pthread_t*)malloc(sizeof(pthread_t) * max);        if(pool-&gt;threadIDs == NULL)&#123;            printf(&quot;malloc threadIDS fail...\\n&quot;);            break;        &#125;        memset(pool-&gt;threadIDs,0,sizeof(pthread_t) * max);        //bzero(&amp;pool-&gt;threadIDs,sizeof(pthread_t) * max);    //清0        pool-&gt;minNum = min;        pool-&gt;maxNum = max;        pool-&gt;busyNum = 0;        pool-&gt;liveNum = min;    //与最小个数相等        pool-&gt;exitNum = 0;        if(pthread_mutex_init(&amp;pool-&gt;mutexBusy,NULL) != 0 ||        pthread_mutex_init(&amp;pool-&gt;mutexPool,NULL) != 0 ||        pthread_cond_init(&amp;pool-&gt;notEmpty,NULL)  != 0 ||        pthread_cond_init(&amp;pool-&gt;notFull,NULL) != 0)&#123;            printf(&quot;mutex or condition init fail...\\n&quot;);            break;        &#125;        //任务队列        pool-&gt;taskQ = (Task*)malloc(sizeof(Task) * queueSize);        pool-&gt;queueCapacity = queueSize;        pool-&gt;queueSize = 0;        pool-&gt;queueFront = 0;        pool-&gt;queueRear = 0;        pool-&gt;shutdown = 0;        //创建线程        pthread_create(&amp;pool-&gt;managerID,NULL,manager,pool);        for(int i = 0; i &lt; min; i++)&#123;            pthread_create(&amp;pool-&gt;threadIDs[i],NULL,worker,pool);        &#125;        return pool;    &#125;while(0);    //释放资源    if(pool &amp;&amp; pool-&gt;threadIDs)&#123;        free(pool-&gt;threadIDs);    &#125;    if(pool &amp;&amp; pool-&gt;taskQ)&#123;        free(pool-&gt;taskQ);    &#125;        if(pool)&#123;        free(pool);    &#125;    return NULL;&#125;void threadPoolAdd(ThreadPool* pool, void(*func)(void*),void* arg)&#123;    pthread_mutex_lock(&amp;pool-&gt;mutexPool);    while (pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)    &#123;        //阻塞生产者线程（阻塞生产者）        pthread_cond_wait(&amp;pool-&gt;notFull,&amp;pool-&gt;mutexPool);    &#125;    if(pool-&gt;shutdown)&#123;        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);        return ;    &#125;    // 添加任务    pool-&gt;taskQ[pool-&gt;queueRear].function = func;    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;    pool-&gt;queueRear = (pool-&gt;queueRear + 1) % pool-&gt;queueCapacity;    pool-&gt;queueSize++;    pthread_cond_signal(&amp;pool-&gt;notEmpty);   //唤醒消费者           pthread_mutex_unlock(&amp;pool-&gt;mutexPool);&#125;int  threadPoolBusyNum(ThreadPool* pool)&#123;    pthread_mutex_lock(&amp;pool-&gt;mutexBusy);    int busyNum = pool-&gt;busyNum;    pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);    return busyNum;&#125;int threadPoolAliveNum(ThreadPool* pool)&#123;    pthread_mutex_lock(&amp;pool-&gt;mutexPool);    int liveNum = pool-&gt;liveNum;    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);    return liveNum;&#125;int threadPoolDestory(ThreadPool* pool)&#123;    if(pool == NULL)&#123;        return -1;    &#125;    // 关闭线程池    pool-&gt;shutdown = 1;    // 阻塞回收管理者线程    pthread_join(pool-&gt;managerID,NULL);    // 唤醒阻塞的消费者线程    for(int i = 0; i &lt; pool-&gt;liveNum; i++)&#123;        pthread_cond_signal(&amp;pool-&gt;notEmpty);    &#125;    if(pool-&gt;taskQ)&#123;        free(pool-&gt;taskQ);    &#125;    if(pool-&gt;threadIDs)&#123;        free(pool-&gt;threadIDs);    &#125;    // 销毁锁和条件变量    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);    pthread_cond_destroy(&amp;pool-&gt;notEmpty);    pthread_cond_destroy(&amp;pool-&gt;notFull);    free(pool);    pool = NULL;    return 0;&#125;// 消费者线程void* worker(void* arg)&#123;    ThreadPool* pool = (ThreadPool*)arg;    while(1)&#123;        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        // 当前任务队列是否为空        while (pool-&gt;queueSize == 0 &amp;&amp; !pool-&gt;shutdown)        &#123;            // 阻塞工作线程（阻塞消费者）            pthread_cond_wait(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool);                    // 判断是不是要销毁线程            if(pool-&gt;exitNum &gt; 0)&#123;                pool-&gt;exitNum--;                if(pool-&gt;liveNum &gt; pool-&gt;minNum)&#123;                    pool-&gt;liveNum--;                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);    // 销毁前，先解锁，防止死锁                    threadExit(pool);                &#125;                                //pthread_exit(NULL);            &#125;        &#125;                // 判断线程池是否被关闭        if(pool-&gt;shutdown)&#123;            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);     //防止死锁            threadExit(pool);            //pthread_exit(NULL);        &#125;        // 从队列中取出一个任务        Task task;        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;        // 移动头节点        pool-&gt;queueFront = (pool-&gt;queueFront + 1) % pool-&gt;queueCapacity;        pool-&gt;queueSize--;        //解锁        pthread_cond_signal(&amp;pool-&gt;notFull);    //唤醒生产者           pthread_mutex_unlock(&amp;pool-&gt;mutexPool);        //开始工作        printf(&quot;thread %ld  start working...\\n&quot;,pthread_self());        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        pool-&gt;busyNum++;        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);        //调用任务里的函数        task.function(task.arg);        //参数建议传堆内存        //(*task.function)(task.arg);   //另一种写法        free(task.arg);        task.arg = NULL;        printf(&quot;thread %ld  end working...\\n&quot;,pthread_self());        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        pool-&gt;busyNum--;        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);    &#125;    return NULL;&#125;void* manager(void* arg)&#123;    ThreadPool* pool = (ThreadPool*)arg;    while(!pool-&gt;shutdown)&#123;        // 每3s检测一次        sleep(3);        // 取出线程池中日任务的数量和当前线程的数量        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        int queueSize = pool-&gt;queueSize;        int liveNum = pool-&gt;liveNum;        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);                // 取出忙的线程的数量        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        int busyNum = pool-&gt;busyNum;        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);                //添加线程        //自定义规则：任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程个数 &lt; 线程的最大个数        if(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)&#123;            pthread_mutex_lock(&amp;pool-&gt;mutexPool);            int count = 0;            for(int i = 0; i &lt; pool-&gt;maxNum &amp;&amp; count &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)&#123;                if(pool-&gt;threadIDs[i] == 0)&#123;                    pthread_create(&amp;pool-&gt;threadIDs[i],NULL,worker,pool);                    count++;                    pool-&gt;liveNum++;                &#125;            &#125;             pthread_mutex_unlock(&amp;pool-&gt;mutexPool);        &#125;        //销毁线程        //自定义规则：忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程 &gt; 最小线程数        if(busyNum * 2 &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)&#123;            pthread_mutex_lock(&amp;pool-&gt;mutexPool);            pool-&gt;exitNum = NUMBER;            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);            // 让工作的线程自杀            for(int i = 0; i &lt; NUMBER; ++i)&#123;                // 唤醒工作线程                pthread_cond_signal(&amp;pool-&gt;notEmpty);            &#125;                &#125;    &#125;    return NULL;&#125;void threadExit(ThreadPool* pool)&#123;    pthread_t tid = pthread_self();    for(int i = 0; i &lt; pool-&gt;maxNum; ++i)&#123;        if(pool-&gt;threadIDs[i] == tid)&#123;            pool-&gt;threadIDs[i] = 0;            printf(&quot;threadExit() called, %ld exiting...\\n&quot;,tid);            break;        &#125;    &#125;    pthread_exit(NULL);&#125;\n\nthreadpool.h#ifndef _THREADPOOL_H#define _THREADPOOL_H#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;typedef struct ThreadPool ThreadPool;//  创建线程池并初始化ThreadPool* threadPoolCreate(int min,int max,int queueSize);//  销毁线程池int threadPoolDestory(ThreadPool* pool);//int threadPoolDestroy(ThreadPool* pool);//  给线程池添加任务void threadPoolAdd(ThreadPool* pool, void(*func)(void*),void* arg);//  获取线程池中工作的线程的个数int  threadPoolBusyNum(ThreadPool* pool);//  获取线程池中活着的线程的个数int threadPoolAliveNum(ThreadPool* pool);//////void* worker(void* arg);void* manager(void* arg);void threadExit(ThreadPool* pool);//////#endif\n\n2. c++版main.cpp#include&lt;iostream&gt;#include&lt;unistd.h&gt;#include &quot;ThreadPool.h&quot;#include &quot;ThreadPool.cpp&quot;using namespace std;void taskFunc(void* arg)&#123;    int num = *(int*)arg;    printf(&quot;thread is working, number = %d, tid = %ld\\n&quot;,num,pthread_self());    usleep(1000);&#125;int main()&#123;     // 创建线程池    ThreadPool&lt;int&gt; pool(3,10);    for(int i = 0; i &lt; 100; i++)&#123;                // threadPoolAdd(pool,taskFunc,&amp;i);        int* num = new int(i + 100);        pool.threadPoolAddTask(Task&lt;int&gt;(taskFunc,num));            &#125;    sleep(30);        return 0;&#125;\n\nTaskQueue.cpp#include &quot;TaskQueue.h&quot;template &lt;typename T&gt;TaskQueue&lt;T&gt;::TaskQueue()&#123;    pthread_mutex_init(&amp;m_mutex,NULL);&#125;template &lt;typename T&gt;TaskQueue&lt;T&gt;::~TaskQueue()&#123;    pthread_mutex_destroy(&amp;m_mutex);&#125;template &lt;typename T&gt;void TaskQueue&lt;T&gt;::addTask(Task&lt;T&gt;&amp; task)&#123;    pthread_mutex_lock(&amp;m_mutex);    m_taskQ.push(task);    pthread_mutex_unlock(&amp;m_mutex);&#125;template &lt;typename T&gt;void TaskQueue&lt;T&gt;::addTask(callback f, void* arg)&#123;    pthread_mutex_lock(&amp;m_mutex);    m_taskQ.push(Task&lt;T&gt;(f,arg));    pthread_mutex_unlock(&amp;m_mutex);&#125;template &lt;typename T&gt;Task&lt;T&gt; TaskQueue&lt;T&gt;::getTask()&#123;     Task&lt;T&gt; task;    pthread_mutex_lock(&amp;m_mutex);    if(m_taskQ.empty())&#123;        return task;    &#125;        task = m_taskQ.front();    m_taskQ.pop();    pthread_mutex_unlock(&amp;m_mutex);    return task;&#125;\n\nTaskQueue.h#pragma once#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;using callback = void (*)(void*);//  任务结构体template &lt;typename T&gt;struct  Task&#123;    Task&lt;T&gt;()&#123;        function = nullptr;        arg = nullptr;    &#125;    Task&lt;T&gt;(callback f, void* arg)&#123;        function = f;        this-&gt;arg = (T*)arg;    &#125;    callback function;    T* arg;&#125;;template &lt;typename T&gt;class TaskQueue&#123;public:    TaskQueue();    ~TaskQueue();    // 取出一个任务    Task&lt;T&gt; getTask();    // 添加一个任务    void addTask(Task&lt;T&gt;&amp; task);    void addTask(callback f, void* arg);    //重载    inline int taskNumber()&#123;        return m_taskQ.size();    &#125;private:    pthread_mutex_t m_mutex;    queue&lt;Task&lt;T&gt;&gt; m_taskQ; &#125;;\n\nThreadPool.cpp#include &quot;ThreadPool.h&quot;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;using namespace std;template &lt;typename T&gt;ThreadPool&lt;T&gt;::ThreadPool(int min, int max)&#123;       do&#123;        // 实例化任务对列        taskQ = new TaskQueue&lt;T&gt;;        if(taskQ == nullptr)&#123;            cout&lt;&lt;&quot;malloc taskQ fail...&quot;&lt;&lt;endl;            break;        &#125;        minNum = min;        maxNum = max;        busyNum = 0;        liveNum = min;    //与最小个数相等        exitNum = 0;        threadIDs = new pthread_t[max];        if(threadIDs == nullptr)&#123;            cout&lt;&lt;&quot;malloc threadIDS  fail...&quot;&lt;&lt;endl;            break;        &#125;        if(pthread_mutex_init(&amp;mutexPool,NULL) != 0 || pthread_cond_init(&amp;notEmpty,NULL)  != 0)&#123;            printf(&quot;mutex or condition init fail...\\n&quot;);            break;        &#125;        shutdown = false;         //创建线程        pthread_create(&amp;managerID,NULL,manager,this);        for(int i = 0; i &lt; min; i++)&#123;            pthread_create(&amp;threadIDs[i],NULL,worker,this);        &#125;    &#125;while(0);&#125;template &lt;typename T&gt;ThreadPool&lt;T&gt;::~ThreadPool()&#123;    // 关闭线程池    shutdown = 1;    // 阻塞回收管理者线程(销毁管理者线程)    pthread_join(managerID,NULL);    // 唤醒阻塞的消费者线程    for(int i = 0; i &lt; liveNum; i++)&#123;        pthread_cond_signal(&amp;notEmpty);    &#125;    if(taskQ)&#123;        delete taskQ;    &#125;    if(threadIDs)&#123;        delete[] threadIDs;    &#125;    // 销毁锁和条件变量    pthread_mutex_destroy(&amp;mutexPool);    pthread_cond_destroy(&amp;notEmpty);      &#125;template &lt;typename T&gt;void ThreadPool&lt;T&gt;::threadPoolAddTask(Task&lt;T&gt; task)&#123;    if(shutdown)&#123;        //pthread_mutex_unlock(&amp;mutexPool);        return ;    &#125;    // 添加任务    taskQ-&gt;addTask(task);    // 唤醒工作的线程    pthread_cond_signal(&amp;notEmpty);    &#125;template &lt;typename T&gt;int ThreadPool&lt;T&gt;::getBusyNum()&#123;    pthread_mutex_lock(&amp;mutexPool);    int busyNum = this-&gt;busyNum;    pthread_mutex_unlock(&amp;mutexPool);    return busyNum;&#125;template &lt;typename T&gt;int ThreadPool&lt;T&gt;::getAliveNum()&#123;    pthread_mutex_lock(&amp;mutexPool);    int liveNum = this-&gt;liveNum;    pthread_mutex_unlock(&amp;mutexPool);    return liveNum;&#125;template &lt;typename T&gt;// 消费者线程void* ThreadPool&lt;T&gt;::worker(void* arg)&#123;    ThreadPool* pool = (ThreadPool*)arg;    while(1)&#123;        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        // 当前任务队列是否为空        while (pool-&gt;taskQ-&gt;taskNumber() == 0 &amp;&amp; !pool-&gt;shutdown)        &#123;            // 阻塞工作线程（阻塞消费者）            pthread_cond_wait(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool);                    // 判断是不是要销毁线程            if(pool-&gt;exitNum &gt; 0)&#123;                pool-&gt;exitNum--;                if(pool-&gt;liveNum &gt; pool-&gt;minNum)&#123;                    pool-&gt;liveNum--;                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);    // 销毁前，先解锁，防止死锁                    pool-&gt;threadExit();                &#125;                                //pthread_exit(NULL);            &#125;        &#125;                // 判断线程池是否被关闭        if(pool-&gt;shutdown)&#123;            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);     //防止死锁            pool-&gt;threadExit();            //pthread_exit(NULL);        &#125;        // 从队列中取出一个任务        Task&lt;T&gt; task = pool-&gt;taskQ-&gt;getTask();                //解锁       // pthread_cond_signal(&amp;pool-&gt;notFull);    //唤醒生产者       //开始工作        printf(&quot;thread %ld  start working...\\n&quot;,pthread_self());       // pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        pool-&gt;busyNum++;       // pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);                //调用任务里的函数        task.function(task.arg);        //参数建议传堆内存        //(*task.function)(task.arg);   //另一种写法        delete task.arg;        task.arg = nullptr;        printf(&quot;thread %ld  end working...\\n&quot;,pthread_self());        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        pool-&gt;busyNum--;        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);    &#125;    return NULL;&#125;template &lt;typename T&gt;void* ThreadPool&lt;T&gt;::manager(void* arg)&#123;    ThreadPool* pool = (ThreadPool*)arg;    while(!pool-&gt;shutdown)&#123;        // 每3s检测一次        sleep(3);        // 取出线程池中日任务的数量和当前线程的数量        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        int queueSize = pool-&gt;taskQ-&gt;taskNumber();        int liveNum = pool-&gt;liveNum;        // 取出忙的线程的数量        // pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        int busyNum = pool-&gt;busyNum;        // pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);                               //添加线程        //自定义规则：任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程个数 &lt; 线程的最大个数        if(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)&#123;            pthread_mutex_lock(&amp;pool-&gt;mutexPool);            int count = 0;            for(int i = 0; i &lt; pool-&gt;maxNum &amp;&amp; count &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)&#123;                if(pool-&gt;threadIDs[i] == 0)&#123;                    pthread_create(&amp;pool-&gt;threadIDs[i],NULL,worker,pool);                    count++;                    pool-&gt;liveNum++;                &#125;            &#125;             pthread_mutex_unlock(&amp;pool-&gt;mutexPool);        &#125;        //销毁线程        //自定义规则：忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程 &gt; 最小线程数        if(busyNum * 2 &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)&#123;            pthread_mutex_lock(&amp;pool-&gt;mutexPool);            pool-&gt;exitNum = NUMBER;            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);            // 让工作的线程自杀            for(int i = 0; i &lt; NUMBER; ++i)&#123;                // 唤醒工作线程                pthread_cond_signal(&amp;pool-&gt;notEmpty);            &#125;                &#125;    &#125;    return NULL;&#125;template &lt;typename T&gt;// 线程退出void ThreadPool&lt;T&gt;::threadExit()&#123;    pthread_t tid = pthread_self();    for (int i = 0; i &lt; maxNum; ++i)    &#123;        if (threadIDs[i] == tid)        &#123;            cout &lt;&lt; &quot;threadExit() function: thread &quot;                 &lt;&lt; to_string(pthread_self()) &lt;&lt; &quot; exiting...&quot; &lt;&lt; endl;            threadIDs[i] = 0;            break;        &#125;    &#125;    pthread_exit(NULL);&#125;\n\nThreadPool.h#pragma once#include &quot;TaskQueue.h&quot;#include &quot;TaskQueue.cpp&quot;template &lt;typename T&gt;class ThreadPool&#123;   public:           //  创建线程池并初始化     ThreadPool(int min, int max);    //  销毁线程池    ~ThreadPool();    //  给线程池添加任务    void threadPoolAddTask(Task&lt;T&gt; task);    //  获取线程池中工作的线程的个数    int  getBusyNum();    //  获取线程池中活着的线程的个数    int getAliveNum();    //////private:    static void* worker(void* arg);    static void* manager(void* arg);    void threadExit();    //////private:    //任务队列    TaskQueue&lt;T&gt; *taskQ;    //管理者线程    pthread_t   managerID;  //管理者线程ID    //工作线程    pthread_t   *threadIDs; //工作的线程ID    int minNum;     //最小线程数量    int maxNum;     //最大线程数量    int busyNum;    //忙的线程个数    int liveNum;    //存活的线程个数    int exitNum;    //要销毁的线程个数    //互斥锁    pthread_mutex_t mutexPool;  //锁整个的线程池    //条件变量    pthread_cond_t notEmpty;    //任务队列是不是空了    bool shutdown = false;   //是不是要销毁线程池，销毁为1，不销毁为0    static const int NUMBER = 2;&#125;;\n\n","categories":["笔记"],"tags":["c++","linux","c","网络编程","线程池"]},{"title":"每日一题（汇总版）","url":"/2023/11/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E6%B1%87%E6%80%BB%E7%89%88%EF%BC%89/","content":"每日一题1. 虚函数1.1 什么是虚函数虚函数是在基类中声明的，而在派生类中进行重写的函数。通过使用virtual关键字声明一个函数为虚函数，它使得在运行时能够动态地确定调用的是哪个版本的函数。\nclass Base &#123;public:    virtual void show() &#123;        std::cout &lt;&lt; &quot;Base class\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    void show() override &#123;        std::cout &lt;&lt; &quot;Derived class\\n&quot;;    &#125;&#125;;\n\n1.2 虚函数的作用\n实现多态性（Polymorphism）：允许通过基类指针或引用调用派生类对象的函数，根据实际对象的类型选择相应的函数实现。\n运行时绑定（Runtime Binding）：虚函数通过表格（虚函数表）的方式实现，使得在运行时动态地绑定函数调用。\n\n1.3 虚函数表（vtable）每个含有虚函数的类都有一个虚函数表，其中存储了虚函数的地址。对象的内存布局中包含一个指向虚函数表的指针。派生类的虚函数表包含基类的虚函数表，并在适当的位置添加或替换新的虚函数地址。\n1.4 纯虚函数纯虚函数是一个在基类中声明但没有提供实现的虚函数，它通过在声明中使用 &#x3D; 0 来标识。类含有纯虚函数的类被称为抽象类，不能被实例化。派生类必须实现纯虚函数，否则也会变为抽象类。\nclass AbstractBase &#123;public:    virtual void pureVirtualFunction() = 0;&#125;;\n\n1.5 虚析构函数如果基类的析构函数是虚函数，当通过基类指针删除派生类对象时，会调用派生类的析构函数。这是为了确保正确的对象销毁。\nclass Base &#123;public:    virtual ~Base() &#123;        std::cout &lt;&lt; &quot;Base destructor\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    ~Derived() override &#123;        std::cout &lt;&lt; &quot;Derived destructor\\n&quot;;    &#125;&#125;;\n\n内存对齐什么是内存对齐内存对齐是指在分配内存时，数据存储在内存中的起始地址是按照一定的规则对齐的。\n假设现在CPU是按照每4个字节来访问内存，有地址0、和地址1，现在要存1个char变量（假设char变量占1字节）和1个int变量（假设int变量占4字节），那么可以有内存对齐和内存不对齐的存储方式，如下图：\n\n假如不采用内存对齐的方式存储数据，那么CPU需要访问地址0和地址1，再进行合并，才能得到最终的结果；采用内存对齐的方式进行存储数据的话，则只需访问地址1就可以得到最终的结果。因此，采用内存对齐的存储方式可以减少CPU的访问运行时间，缺点是没有充分利用存储空间。\n对齐规则数据是根据初始化的顺序存储的，先定义的先储存，存储地址需要是sizeof(数据变量)的整数倍。\n例如，假设sizeof(char) = 1，sizeof(int) = 4，sizeof(int) = 4，sizeof(double) = 8。结构的对齐规则是要先确定对齐字节数（对齐字节数&#x3D;结构体中的变量占用空间最大的那个字节数，下面的结构体t3、t4就是sizeof(double) = 8），然后再保证存储地址是sizeof(数据变量)的整数倍。\n#include &lt;iostream&gt;using namespace std;struct t1&#123;    char a;    short c;    int x;    char b;&#125;;struct t2&#123;    int x;    char b;    char c;    short a;&#125;;struct t3&#123;    short a;    double c;    int x;    char b;&#125;;struct t4&#123;    char a, b;    int x;    double c;&#125;;int main()&#123;        cout &lt;&lt; sizeof(t1) &lt;&lt; endl; //12    cout &lt;&lt; sizeof(t2) &lt;&lt; endl; //8    cout &lt;&lt; sizeof(t3) &lt;&lt; endl; //24    cout &lt;&lt; sizeof(t4) &lt;&lt; endl; //16    return 0;&#125;\n\n\n在C&#x2F;C++中，内存对齐是由编译器负责的。编译器会按照平台的要求为数据进行对齐，通常会将数据按照其自身大小对齐到特定字节的倍数。这个特定字节的倍数通常由平台决定，例如，在32位系统中可能是4字节，而在64位系统中可能是8字节。\nC&#x2F;C++中可以使用一些特殊的关键字或编译器指令来控制内存对齐，例如：alignas关键字：C++11引入了alignas关键字，用于指定对齐方式。\nalignas(16) struct MyStruct &#123;    // 结构体成员&#125;;\n\n作用\n提高访问速度：许多计算机体系结构要求数据按照特定的边界地址存储，而不是任意地址。当数据被按照这些边界对齐时，处理器能够更快地访问这些数据，提高数据存取速度。\n硬件要求：一些硬件平台对于特定类型的数据要求按照一定的对齐方式存储，不遵循这个规则可能导致硬件异常或性能下降。\n减少浪费：内存对齐可以减少内存碎片，提高内存利用率。\n\nstrlen 和 sizeof的区别sizeof是C语言中的一个单目运算符，用来计算数据类型所占空间的大小，单位为字节；而strlen是一个函数，用来计算字符串长度。简单来说，就是sizeof不包含\\0,而strlen包含\\0。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar arr1[]=&quot;abcd&quot;;//d的后面自动补上\\0;\tchar arr2[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;//以单个元素赋值，没有\\0的结束符\tprintf(&quot;strlen1=%d\\n&quot;,strlen(arr1));//strlen()计算\\0之前的字符长度\tprintf(&quot;strlen2=%d\\n&quot;,strlen(arr2));//该处计算结果应为随机值，因为arr2[]没定义元素个数，就无法知道在哪能遇到\\0;\tprintf(&quot;sizeof1=%d\\n&quot;,sizeof(arr1));//计算了包含\\0的数据空间大小\tprintf(&quot;sizeof2=%d\\n&quot;,sizeof(arr2));\treturn 0; &#125; \n\nstrlen1=4strlen2=8sizeof1=5sizeof2=4\n\nLinux中kill 、kill -15、kill -9 的区别kill（不加 -* 默认kill -15）命令\n系统会发送一个SIGTERM信号给对应的程序。当程序接收到该signal信号后，将会发生以下事情：\n\n程序立刻停止\n当程序释放相应资源后再停止\n程序可能仍然继续运行\n\n大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应），也就是说，**SIGTERM有可能是会被阻塞的**。\nkill -9命令\n系统给对应程序发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。\n\n在使用kill -9 前，应该先使用 kill -15，给目标进程一个清理善后工作的机会。如果没有，可能会留下一些不完整的文件或状态，从而影响服务的再次启动。\n\nkill -9这个信号可以捕获吗kill -9命令用于发送SIGKILL信号给指定的进程，强制终止该进程。SIGKILL是一个无法捕获或阻止的信号，它会立即终止目标进程，不给进程做清理或善后工作的机会。\nLinux中最大socket数量linux系统默认ulimit为1024个访问，用户最多可开启的程序数目。一般一个端口的最高连接为2的16次方65535。\n查看全局文件句柄数限制(系统支持的最大值)\ncat /proc/sys/fs/file-max\n\n查看每个进程文件句柄数限制\nulimit -n\n\n如何修改最大连接数量870-Linux下解决高并发socket最大连接数限制_socket 连接数_林林林ZEYU的博客-CSDN博客\nC++迭代器和指针的区别？\n范围：指针属于迭代器的一种（指针可以用来遍历容器[数组]），迭代器使用后就释放了，不能再继续使用，指针能；指针能指向函数，迭代器不行，只能指向容器\n功能：迭代器有着比指针更细的划分并对应能力不同的功能（重载不同的运算符）\n行为：迭代器比指针更统一和良好的用法（更轻易使用begin()和end()，不用担心越界）。\n\n为什么需要迭代器？\n抽象层次： 迭代器提供了对容器元素的高层次抽象，允许使用一致的方式遍历不同类型的容器，而不用关心底层实现。\n安全性： 使用迭代器可以减少指针错误的可能性，因为迭代器受到容器的保护，不容易越界访问或访问非法内存。\n容器封装： 迭代器为容器提供了一种封装，允许容器实现者更灵活地改变底层数据结构，而不会对使用容器的代码产生影响。\n\nsprintf与snprintf区别int sprintf(char *str, const char &amp;format, ...);\n\nsprintf是字符串格式化命令，主要功能是把格式化的数据写入字符串str中，返回值为写入str的字节数，结束字符\\0不计入内。其中， str是指要写入的缓冲区，format控制要写入str中数据的格式，例如%s、%d、%x等。\nint snprintf(char *str, size_t size, const char *format, ...);\n\nsnprintf是字符串格式化命令，主要功能是把格式化的数据写入字符串str中，最多写size个字节，包括自动添加在字符串末尾处的结束字符\\0;返回值为写入str的字节数，**包括结束字符\\0**。\nsprintf函数返回的是实际输出到字符串缓冲中的字符个数,而snprintf函数返回的是应该输出到字符串缓冲的字符个数\n#define snprintf_nowarn(...) (snprintf(__VA_ARGS__) &lt; 0 ? abort() : (void)0)\n\n该宏用于调用 snprintf 函数，并检查其返回值是否小于 0。snprintf 函数是一个安全的字符串格式化函数，用于将格式化的数据写入字符串。这里的目的是在调用 snprintf 时，如果返回值小于 0，就调用 abort() 函数，中止程序运行，以防止潜在的错误。\nC语言中”#”和”##”的用法#把宏参数变为一个字符串\n##把两个宏参数贴合在一起\n#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;#define STR(s)     #s#define CONS(a,b)  int(a##e##b)int main()&#123;   printf(STR(abc));           // 输出字符串&quot;abc&quot;   printf(&quot;\\n&quot;);   printf(&quot;%d\\n&quot;, CONS(2,3));  // 2e3 输出:2000   return 0;&#125;\n\nabc2000\n\n当宏参数是另一个宏的时候，需要注意的是凡宏定义里有用#或##的地方宏参数是不会再展开。 只有当前宏生效, 参数里的宏不会生效 ！！！\n\n\n当宏参数是另一个宏的时候，需要注意的是凡宏定义里有用`#`或`##`的地方宏参数是不会再展开。 只有当前宏生效, 参数里的宏不会生效 ！！！\n\n举例\n#define A          (2)#define STR(s)     #s#define CONS(a,b)  int(a##e##b)printf(&quot;int max: %s\\n&quot;,  STR(INT_MAX));    // INT_MAX ＃include&lt;climits&gt;printf(&quot;%s\\n&quot;, CONS(A, A));                // compile error --- int(AeA)\n\n两句printf会被展开为：\nprintf(&quot;int max: %s\\n&quot;,&quot;INT_MAX&quot;);printf(&quot;%s\\n&quot;, int(AeA));\n\n分析\n由于A和INT_MAX均是宏，且作为宏CONS和STR的参数，并且宏CONS和STR中均含有#或者##符号，所以A和INT_MAX均不能被解引用。导致不符合预期的情况出现。\n\n\n解决这个问题的方法很简单。 加多一层中间转换宏。 加这层宏的用意是把所有宏的参数在这层里全部展开,\n那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数。\n\n\n#define A           (2)#define _STR(s)     #s#define STR(s)      _STR(s)          // 转换宏#define _CONS(a,b)  int(a##e##b)#define CONS(a,b)   _CONS(a,b)       // 转换宏\n\n#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;#define A           2#define _STR(s)     #s#define STR(s)      _STR(s)          // 转换宏#define _CONS(a,b)  int(a##e##b)#define CONS(a,b)   _CONS(a,b)       // 转换宏int main()&#123;   printf(STR(INT_MAX));           // 输出字符串&quot;abc&quot;   printf(&quot;\\n&quot;);   printf(&quot;%d\\n&quot;, CONS(A,A));  // 2e3 输出:2000   return 0;&#125;\n\n0x7fffffff200\n\nvector怎么扩容在 C++ 的标准库中，std::vector 是一个动态数组，其扩容是通过重新分配内存来实现的。当 std::vector 的元素数量达到当前分配的内存大小时，系统会为std::vector分配一块更大的内存，并将原来的元素复制到新的内存中。这个过程中原来的内存会被释放。\nstd::vector 扩容的基本步骤：\n\n分配新的内存：当 std::vector 中的元素个数达到当前分配的内存大小时，需要分配一块新的内存。新的内存大小通常是当前内存大小的两倍(Linux端），(Windows是1.5倍），这样做是为了保证std::vector的操作复杂度为平摊 O(1)。\n将元素复制到新内存：将原来的元素逐个复制到新分配的内存中。\n释放旧内存：释放原来的内存空间。\n\n信号量和互斥锁有什么区别信号量用于线程的同步，互斥锁用于线程的互斥。\n信号量值可以为非负整数，互斥锁值只能为0&#x2F;1。\n信号量可以由一个线程释放，另一个线程得到，互斥锁的加锁和解锁必须由同一线程分别对应使用。\n信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这个资源。\n\n\ndefine 和 const 区别对于 define 来说， 宏定义实际上是在预编译阶段进行处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进行字符串的展开，遇到多少次就展开多少次，而且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为define宏定义仅仅是展开，因此运行时系统并不为宏定义分配内存，（但是从汇编的角度来讲，define却以立即数的方式保留了多份数据的拷贝）。\n对于 const 来说， const 是在编译期间进行处理的，const 有类型，也有类型检查，程序运行时系统会为 const 常量分配内存，而且从汇编的角度讲，const 常量在出现的地方保留的是真正数据的内存地址，只保留了一份数据的拷贝，省去了不必要的内存空间。而且，有时编译器不会为普通的const常量分配内存，而是直接将const常量添加到符号表中，省去了读取和写入内存的操作，效率更高。\n野(wild)指针与悬空(dangling)指针有什么区别？如何避免？野指针(wild pointer)：就是没有被初始化过的指针。用 gcc -Wall 编译, 会出现 used uninitialized警告。\n悬空指针：是指针最初指向的内存已经被释放了的一种指针。\n无论是野指针还是悬空指针，都是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针。 访问”不安全可控”(invalid)的内存区域将导致”Undefined Behavior”。\n如何避免使用野指针？\n在平时的编码中，养成在定义指针后且在使用之前完成初始化的习惯或者使用智能指针。\n实现多态的方法多态其实一般就是指继承加虚函数实现的多态，对于重载来说，实际上基于的原理是，编译器为函数生成符号表时的不同规则，重载只是一种语言特性，与多态无关，与面向对象也无关，但这又是 C++中增加的新规则，所以也算属于 C++，所以如果非要说重载算是多态的一种，那就可以说：多态可以分为静态多态和动态多态。\n静态多态其实就是重载，因为静态多态是指在编译时期就决定了调用哪个函数，根据参数列表来决定；\n动态多态是指通过子类重写父类的虚函数来实现的，因为是在运行期间决定调用的函数，所以称为动态多态，\n一般情况下我们不区分这两个时所说的多态就是指动态多态。\n动态多态的实现与虚函数表，虚函数指针相关。\n子类是否要重写父类的虚函数？\n子类继承父类时， 父类的纯虚函数必须重写，否则子类也是一个虚类不可实例化。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。\n\n\nnew &#x2F; delete malloc &#x2F; free 区别都可以用来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。\n执行 new 实际上执行两个过程：\n\n分配未初始化的内存空间（malloc）；\n\n使用对象的构造函数对空间进行初始化；返回空间的首地址。\n\n\n如果在第一步分配空间中出现问题，则抛出std::bad_alloc异常，或被某个设定的异常处理函数捕获处理；如果在第二步构造对象时出现异常，则自动调用delete释放内存。\n\n\n执行 delete 实际上也有两个过程：\n\n使用析构函数对对象进行析构；\n回收内存空间（free）。\n\n以上也可以看出new和 malloc 的区别，new 得到的是经过初始化的空间，而malloc得到的是未初始化的空间。所以 new 是 new 一个类型，而 malloc 则是malloc一个字节长度的空间。delete 和 free同理，delete不仅释放空间还析构对象，delete 一个类型，free 一个字节长度的空间。\n\n\n为什么有了 malloc／free ,还需要 new／delete？ \n因为对于非内部数据类型而言，光用 malloc／free 无法满足动态对象的要求。对象在创建的同时需要自动执行构造函数，对象在消亡以前要自动执行析构函数。由于 mallo／free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于 malloc／free，所以有了new／delete操作符。\n内存泄漏的定义，如何检测与避免定义：内存泄漏简单的说就是申请了一块内存空间，使用完毕后没有释放掉。 它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。\n如何检测内存泄漏\n\n首先可以通过观察猜测是否可能发生内存泄漏，Linux 中使用swap 命令观察还有多少可用的交换空间，在一两分钟内键入该命令三到四次，看看可用的交换区是否在减少。\n还可以使用 其他一些 /usr/bin/stat 工具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，一个可能的解释就是有个进程出现了内存泄漏。\n当然也有用于内存调试，内存泄漏检测以及性能分析的软件开发工具 valgrind 这样的工具来进行内存泄漏的检测。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"虚函数","url":"/2023/11/15/%E8%99%9A%E5%87%BD%E6%95%B0/","content":"1. 虚函数1.1 什么是虚函数虚函数是在基类中声明的，而在派生类中进行重写的函数。通过使用virtual关键字声明一个函数为虚函数，它使得在运行时能够动态地确定调用的是哪个版本的函数。\nclass Base &#123;public:    virtual void show() &#123;        std::cout &lt;&lt; &quot;Base class\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    void show() override &#123;        std::cout &lt;&lt; &quot;Derived class\\n&quot;;    &#125;&#125;;\n\n1.2 虚函数的作用\n实现多态性（Polymorphism）：允许通过基类指针或引用调用派生类对象的函数，根据实际对象的类型选择相应的函数实现。\n运行时绑定（Runtime Binding）：虚函数通过表格（虚函数表）的方式实现，使得在运行时动态地绑定函数调用。\n\n1.3 虚函数表（vtable）每个含有虚函数的类都有一个虚函数表，其中存储了虚函数的地址。对象的内存布局中包含一个指向虚函数表的指针。派生类的虚函数表包含基类的虚函数表，并在适当的位置添加或替换新的虚函数地址。\n1.4 纯虚函数纯虚函数是一个在基类中声明但没有提供实现的虚函数，它通过在声明中使用 &#x3D; 0 来标识。类含有纯虚函数的类被称为抽象类，不能被实例化。派生类必须实现纯虚函数，否则也会变为抽象类。\nclass AbstractBase &#123;public:    virtual void pureVirtualFunction() = 0;&#125;;\n\n1.5 虚析构函数如果基类的析构函数是虚函数，当通过基类指针删除派生类对象时，会调用派生类的析构函数。这是为了确保正确的对象销毁。\nclass Base &#123;public:    virtual ~Base() &#123;        std::cout &lt;&lt; &quot;Base destructor\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    ~Derived() override &#123;        std::cout &lt;&lt; &quot;Derived destructor\\n&quot;;    &#125;&#125;;\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"解析Http协议","url":"/2023/10/20/%E8%A7%A3%E6%9E%90Http%E5%8D%8F%E8%AE%AE/","content":"在写webSever时了解了一点关于http协议的内容，更方便后面的学习\n\nHTTP(hypertext transport protocol 超文本传输协议）：一种无状态的，以请求&#x2F;应答方式运行的协议，它使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。\n1. http请求http请求消息分为四部分1. 请求行\t不管是get请求还是post请求，请求行分为三部分2. 请求头3. 空行4. 客户端想服务器提交的数据\n\nGET /doing HTTP/1.1Host: 10.1.18.4User-Agent: Mozilla/5.0 (Windows NT 6.2; rv:40.0) Gecko/20100101 Firefox/40.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://10.1.18.4/Connection: keep-alive\n\n1. 请求行\tGET /doing HTTP/1.1三部分：请求方式\t请求的资源（/不代表服务器根目录，是服务器给客户端提供的资源目录）\t        HTTP协议版本\t还有看不见的\\r\\n2. 请求头\t若干个键值对Host: 10.1.18.4User-Agent: Mozilla/5.0 (Windows NT 6.2; rv:40.0) Gecko/20100101 Firefox/40.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://10.1.18.4/Connection: keep-alive\n\n\nget\n\n提交的数据,不安全,提交的数据会显示到地址栏中，被别人看到之后，数据就泄露了\n图中的 userid和roomid 就是浏览器向服务器提交的数据地址栏中的数据会放到某块缓冲中，地址栏对应的缓存是有上限的,在几k左右\n\n\npost\n\n提交的数据并不会显示到地址栏中,完全不可见的，因此更安全\n\n\n\n\n请求行，用来说明请求类型，要访问的资源以及所使用的http版本。get说明请求类型为get，该行的最后一部分说明使用的是http 1.1版本\n\n请求头，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。从第二行起为请求头部，host将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它，它是客户端类型检测逻辑的重要基础。该信息由你的客户端来定义，并且在每个请求中自动发送等。\n\n空行，请求头部后面的空行是必须的。即使第四部分的请求数据为空，也必须有空行。\n\n请求数据也叫主体，可以添加任意的其他数据，上面的请求数据为空。\n\n\n1.2 http响应\n状态行，由http协议版本号， 状态码， 状态消息三部分组成。上面http版本号为http/1.1，状态码为200，状态消息为”OK”。\n消息报头，用来说明客户端要使用的一些附加信息。Date：生成响应的日期和时间；Content-Type：指定了MIME类型的html(text/html)，编码类型是UTF-8。\n空行，消息报头后面的空行是必须的。\n响应正文，服务器返回给客户端的文本信息，空行后面的html部分为响应正文。\n\n1.3 http状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:\n1xx:指示信息--表示请求已接收，继续处理2xx:成功--表示请求已被成功接收、理解、接受3xx:重定向--要完成请求必须进行更进—步的操作(网络地址的重新访问)4xx:客户端错误--请求有语法错误或请求无法实现5xx:服务器端错误--服务器未能实现合法的请求\n\n常见状态码\n200 OK\t客户端请求成功400 Bad Request客户端请求有语法错误，不能被服务器所理解401 Unauthorized请求未经授权，这个状态代码必须和Www-Authenticate报头域一起使用403 Forbidden 服务器收到请求，但是拒绝提供服务404 Not Found 请求资源不存在，eg:输入了错误的URL500 Internal Server Error服务器发生不可预期的错误503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常\n","categories":["笔记"],"tags":["http"]},{"title":"野(wild)指针与悬空(dangling)指针有什么区别？如何避免？","url":"/2023/11/24/%E9%87%8E-wild-%E6%8C%87%E9%92%88%E4%B8%8E%E6%82%AC%E7%A9%BA-dangling-%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F/","content":"野(wild)指针与悬空(dangling)指针有什么区别？如何避免？野指针(wild pointer)：就是没有被初始化过的指针。用 gcc -Wall 编译, 会出现 used uninitialized警告。\n悬空指针：是指针最初指向的内存已经被释放了的一种指针。\n无论是野指针还是悬空指针，都是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针。 访问”不安全可控”(invalid)的内存区域将导致”Undefined Behavior”。\n如何避免使用野指针？\n在平时的编码中，养成在定义指针后且在使用之前完成初始化的习惯或者使用智能指针。\n","categories":["每日一题"],"tags":["c++"]},{"title":"长连接和短连接的区别","url":"/2023/12/21/%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"长连接和短连接的区别长连接：客户端与服务端先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。\n短连接：客户端与服务端每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。\n短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接长连接的操作步骤是：建立连接——数据传输…（保持连接）…数据传输——关闭连接\n长连接多⽤于操作频繁，点对点的通讯，⽽且连接数不能太多情况。每个 TCP 连接都需要三步握⼿，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多， 所以每个操作完后都不断开，下次处理时直接发送数据包就 OK 了，不⽤建⽴ TCP 连接。\n例如： 数据库的连接⽤长连接， 如果⽤短连接频繁的通信会造成 socket 错误，⽽且频繁的 socket创建也是对资源的浪费。\n⽽像 WEB ⽹站的 http 服务⼀般都⽤短链接，因为长连接对于服务端来说会耗费⼀定的 资源，⽽像 WEB ⽹站这么频繁的成千上万甚⾄上亿客户端的连接⽤短连接会更省⼀些资源， 如果⽤长连接，⽽且同时有成千上万的⽤户，如果每个⽤户都占⽤⼀个连接的话，那可想⽽知吧。所以并发量⼤，但每个⽤户⽆需频繁操作情况下需⽤短连接。\n","categories":["每日一题"],"tags":["c++"]},{"title":"指针和引用的区别","url":"/2023/12/20/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"指针和引用的区别指针和引用是C++中的两个重要概念，它们都可以用于间接访问对象或变量。下面是它们的区别：\n\n定义和使用方式：指针使用*来声明和解引用，而引用使用&amp;来声明，不需要解引用。\n空值：指针可以为空（nullptr），表示没有指向任何对象或变量，而引用必须始终引用有效的对象。\n可变性：指针本身可以重新赋值为另一个地址，即改变所指向的对象或变量；而引用一旦初始化后就不能再改变所引用的对象。\n对象关系：指针可以指向多个不同类型的对象，并且可以通过运算符修改所指向对象的值；而引用始终与特定类型的对象相关联，并且无法更改为引用其他类型的对象。\n空间占用：通常情况下，指针需要占据内存空间来存储地址信息；而引用本质上只是原对象的一个别名，并不需要额外的空间。\n\n","categories":["每日一题"],"tags":["c++"]}]