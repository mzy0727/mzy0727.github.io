[{"title":"C++11新特性（II)","url":"/2023/11/10/C-11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88II%EF%BC%89/","content":"C++11新特性（II）lambda表达式auto func = [capture] (params) opt -&gt; ret &#123; func_body; &#125;;\n\n其中func是可以当作lambda表达式的名字，作为一个函数使用，capture是捕获列表，params是参数表，opt是函数选项(mutable之类)， ret是返回值类型，func_body是函数体。\nauto func1 = [](int a) -&gt; int &#123; return a + 1; &#125;;auto func2 = [](int a) &#123; return a + 2; &#125;;cout &lt;&lt; func1(1) &lt;&lt; &quot; &quot; &lt;&lt; func2(2) &lt;&lt; endl;\n\nlambda表达式允许捕获一定范围内的变量：\n\n[]不捕获任何变量\n[&amp;]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用\n[=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用\n[=, &amp;a]值捕获外部作用域所有变量，按引用捕获a变量\n[a]只值捕获a变量，不捕获其它变量\n[this]捕获当前类中的this指针\n\n智能指针shared_ptrshared_ptr使用了引用计数，每一个shared_ptr的拷贝都指向相同的内存，每次拷贝都会触发引用计数+1，每次生命周期结束析构的时候引用计数-1，在最后一个shared_ptr析构的时候，内存才会释放。\n关于shared_ptr有几点需要注意：\n• 不要用一个裸指针初始化多个shared_ptr，会出现double_free导致程序崩溃\n• 通过shared_from_this()返回this指针，不要把this指针作为shared_ptr返回出来，因为this指针本质就是裸指针，通过this返回可能会导致重复析构，不能把this指针交给智能指针管理。\nclass A &#123;    shared_ptr&lt;A&gt; GetSelf() &#123;        return shared_from_this();        // return shared_ptr&lt;A&gt;(this); 错误，会导致double free    &#125;  &#125;;\n\n\n尽量使用make_shared，少用new。\n不要delete get()返回来的裸指针。\n不是new出来的空间要自定义删除器。\n要避免循环引用，循环引用导致内存永远不会被释放，造成内存泄漏。\n\nweak_ptrweak_ptr是用来监视shared_ptr的生命周期，它不管理shared_ptr内部的指针，它的拷贝的析构都不会影响引用计数，纯粹是作为一个旁观者监视shared_ptr中管理的资源是否存在，可以用来返回this指针和解决循环引用问题。\n\n作用1：返回this指针，上面介绍的shared_from_this()其实就是通过weak_ptr返回的this指针。\n作用2：解决循环引用问题。\n\nunique_ptrstd::unique_ptr是一个独占型的智能指针，它不允许其它智能指针共享其内部指针，也不允许unique_ptr的拷贝和赋值。使用方法和shared_ptr类似，区别是不可以拷贝\nstd::arraystd::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。\nstd::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可：\nstd::array&lt;int, 4&gt; arr= &#123;1,2,3,4&#125;;int len = 4;std::array&lt;int, len&gt; arr = &#123;1,2,3,4&#125;; // 非法, 数组大小参数必须是常量表达式","categories":["笔记"],"tags":["c++"]},{"title":"C++使用MYSQL API 操作数据库","url":"/2023/11/14/C-%E4%BD%BF%E7%94%A8MYSQL-API-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"C++使用MYSQL API 操作数据库在程序中连接数据库服务器，主要包含以下步骤：\n\n初始化连接环境\n连接mysql的服务器需要提供：\n服务器IP\n服务器监听的端口（默认3306）\n服务器的用户名（默认root）和对应的密码\n服务器要操作的具体数据库名\n\n\n对数据库中的数据进行增删改查\n事物处理\n成功：提交事务\n失败：数据回滚\n\n\n数据库的读数据操作-&gt;查询-&gt;得到结果集\n遍历结果集-&gt;获得自己需要的数据\n释放资源\n\nAPI介绍初始化连接环境// 返回值: 该函数将分配、初始化、并返回新对象// 通过返回的这个对象去连接MySQL的服务器MYSQL *mysql_init(MYSQL *mysql) ;\n\n连接mysql服务器/*返回值:     成功: 返回MYSQL*连接句柄, 对于成功的连接，返回值与第1个参数的值相同。返回值指向的内存和第一个参数指针指向的内存一样    失败，返回NULL。    句柄: 是windows中的一个概念, 句柄可以理解为一个实例(或者对象)*/ MYSQL *mysql_real_connect(    MYSQL *mysql,           // mysql_init() 函数的返回值    const char *host,       // mysql服务器的主机地址, 写IP地址即可                            // localhost, null -&gt; 代表本地连接    const char *user,       // 连接mysql服务器的用户名, 默认: root     const char *passwd,     // 连接mysql服务器用户对应的密码, root用户的密码    const char *db,         // 要使用的数据库的名字    unsigned int port,      // 连接的mysql服务器监听的端口                            // 如果==0, 使用mysql的默认端口3306, !=0, 使用指定的这个端口    const char *unix_socket,// 本地套接字, 不使用指定为 NULL    unsigned long client_flag); // 通常指定为0\n\n执行sql语句// 执行一个sql语句, 添删查改的sql语句都可以int mysql_query(MYSQL *mysql, const char *query);参数:    - mysql: mysql_real_connect() 的返回值    - query: 一个可以执行的sql语句, 结尾的位置不需要加 ;返回值:     - 如果查询成功，返回0。如果是查询, 结果集在mysql 对象中    - 如果出现错误，返回非0值。 \n\n获得结果集// 将结果集从 mysql(参数) 对象中取出// MYSQL_RES 对应一块内存, 里边保存着这个查询之后得到的结果集// 如何将行和列的数据从结果集中取出, 需要使用其他函数// 返回值: 具有多个结果的MYSQL_RES结果集合。如果出现错误，返回NULL。 MYSQL_RES *mysql_store_result(MYSQL *mysql);\n\n得到结果集的列数// 从结果集中列的个数// 参数: 调用 mysql_store_result() 得到的返回值// 返回值: 结果集中的列数unsigned int mysql_num_fields(MYSQL_RES *result)\n\n获取表头 -&gt; 字段名// 参数: 调用 mysql_store_result() 得到的返回值// 返回值: MYSQL_FIELD* 指向一个结构体// 通过查询官方文档, 返回是一个结构体的数组// 通过这个函数得到结果集中所有列的名字MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result);\n\n返回值 MYSQL_FIELD 对应的是一个结构体，在 mysql.h 中定义如下:\n// mysql.h// 结果集中的每一个列对应一个 MYSQL_FIELDtypedef struct st_mysql_field &#123;  char *name;                 /* 列名-&gt; 字段的名字 */  char *org_name;             /* Original column name, if an alias */  char *table;                /* Table of column if column was a field */  char *org_table;            /* Org table name, if table was an alias */  char *db;                   /* Database for table */  char *catalog;              /* Catalog for table */  char *def;                  /* Default value (set by mysql_list_fields) */  unsigned long length;       /* Width of column (create length) */  unsigned long max_length;   /* Max width for selected set */  unsigned int name_length;  unsigned int org_name_length;                                                                                          unsigned int table_length;  unsigned int org_table_length;  unsigned int db_length;  unsigned int catalog_length;  unsigned int def_length;  unsigned int flags;         /* Div flags */  unsigned int decimals;      /* Number of decimals in field */  unsigned int charsetnr;     /* Character set */  enum enum_field_types type; /* Type of field. See mysql_com.h for types */  void *extension;&#125; MYSQL_FIELD;\n\n使用示例\n// 得到存储头信息的数组的地址MYSQL_FIELD* fields = mysql_fetch_fields(res);// 得到列数int num = mysql_num_fields(res);// 遍历得到每一列的列名for(int i=0; i&lt;num; ++i)&#123;    printf(&quot;当前列的名字: %s\\n&quot;, fields[i].name);&#125;\n\n得到结果集中字段的长度/* 返回结果集内当前行的列的长度:    1. 如果打算复制字段值，使用该函数能避免调用strlen()。    2. 如果结果集包含二进制数据，必须使用该函数来确定数据的大小，原因在于，对于包含Null字符的任何字段，strlen()将返回错误的结果。*/unsigned long *mysql_fetch_lengths(MYSQL_RES *result);参数:     - result: 通过查询得到的结果集返回值:    - 无符号长整数的数组表示各列的大小。如果出现错误，返回NULL。\n\n遍历结果集typedef char** MYSQL_ROW;// 遍历结果集的下一行 // 如果想遍历整个结果集, 需要对该函数进行循环调用// 返回值是二级指针, char** 指向一个什么类型的内存呢?//    -- 指向一个指针数组, 类型是数组,里边的每个元素都是指针, char* 类型//    -- char* []; 数组中的字符串对应的一列数据// 需要对 MYSQL_ROW 遍历就可以得到每一列的值// 如果要遍历整个结果集, 需要循环调用这个函数MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);参数:     - result: 通过查询得到的结果集返回值:     - 成功: 得到了当前记录中每个字段的值    - 失败: NULL, 说明数据已经读完了\n\n资源回收// 释放结果集void mysql_free_result(MYSQL_RES *result);// 关闭mysql实例void mysql_close(MYSQL *mysql);\n\n事物操作// mysql中默认会进行事务的提交// 因为自动提交事务, 会对我们的操作造成影响// 如果我们操作的步骤比较多, 集合的开始和结束需要用户自己去设置, //需要改为手动方式提交事务my_bool mysql_autocommit(MYSQL *mysql, my_bool mode) /*参数:    如果模式为“1”，启用autocommit模式；如果模式为“0”，禁止autocommit模式。返回值   如果成功，返回0，如果出现错误，返回非0值。 事务提交 */my_bool mysql_commit(MYSQL *mysql);//返回值: 成功: 0, 失败: 非0    // 数据回滚my_bool mysql_rollback(MYSQL *mysql) //返回值: 成功: 0, 失败: 非0\n\n打印错误日志// 返回错误的描述const char *mysql_error(MYSQL *mysql);// 返回错误的编号unsigned int mysql_errno(MYSQL *mysql);\n\n","categories":["笔记"],"tags":["c++","mysql"]},{"title":"C++11新特性（I）","url":"/2023/10/31/C-11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88I%EF%BC%89/","content":"C++11新特性1. auto 自动推导类型auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型\nint a = 10;auto b = a;//自动推断类型，b为 int类型auto c = 1.9;//自动推断类型，c为double类型auto d = 1.2e12L;//自动推断类型，d 是 long double\n\n2. using 定义别名之前在 C++中可以通过 typedef 重定义一个类型，语法格式如下：\ntypedef 旧的类型名 新的类型名;// 使用举例typedef unsigned int uint_t;\n\n关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。\nusing 新的类型 = 旧的类型;// 使用举例using uint_t = int;\n\n定义函数指针\n// 使用typedef定义函数指针typedef int(*func_ptr)(int, double);// 使用using定义函数指针using func_ptr1 = int(*)(int, double);\n\n在C++11中，新增了一个特性就是可以通过使用using来为一个模板定义别名，但是typedef不行\ntemplate &lt;typename T&gt;using mymap = map&lt;int, T&gt;;\n\nusing语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。\n3. &amp;&amp; 右值引用\n左值是指存储在内存中、有明确存储地址（可取地址）的数据；\n右值是指可以提供数据值的数据（不可取地址）；\n\n右值分两种：\n\n纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等\n将亡值：与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值、 std::move 的返回值等。\n\n\n右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高C++应用程序的性能。\n\n移动构造中使用了右值引用，会将临时对象中的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。\n\n\n\n左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。\n编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。\nauto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。\n通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。\n\n4. nullptr 标识空指针在C++中NULL和0是等价的，C++11 标准并没有对 NULL 的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字nullptr。nullptr 专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化。\nint*    ptr1 = nullptr;char*   ptr2 = nullptr;double* ptr3 = nullptr;\n\nNULL底层源码\n#ifndef NULL    #ifdef __cplusplus        #define NULL 0    #else        #define NULL ((void *)0)    #endif#endif\n\nC++ 中，void * 类型无法隐式转换为其他类型的指针，此时使用 0 代替 (void *)0)，用于解决空指针的问题。\nnullptr 无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮\n5. decltype 类型推导decltype类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 \nint getSize();int main(void)&#123;    int tempA = 2;        /*1.dclTempA为int*/    decltype(tempA) dclTempA;    /*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize，*/    decltype(getSize()) dclTempB;    return 0;&#125;\n\n decltype和auto都可以用来推断类型，但是二者有几处明显的差异： \n\nauto忽略顶层const，decltype保留顶层const；\n\n对引用操作，auto推断出原有类型，decltype推断出引用； \n\n对解引用操作，auto推断出原有类型，decltype推断出引用； \n\nauto 推断时会实际执行，ecltype不会执行，只做分析。 总之在使用中过程中和const、引用和指针结合时需要特别小心。\n\n\n6. 委托构造C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的\nclass Base &#123;public:    int value1;    int value2;    Base() &#123;        value1 = 1;    &#125;    Base(int value) : Base() &#123;  // 委托 Base() 构造函数        value2 = 2;    &#125;&#125;;\n\n","categories":["笔记"],"tags":["c++"]},{"title":"C++迭代器和指针的区别","url":"/2023/11/17/C-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"C++迭代器和指针的区别\n范围：指针属于迭代器的一种（指针可以用来遍历容器[数组]），迭代器使用后就释放了，不能再继续使用，指针能；指针能指向函数，迭代器不行，只能指向容器\n功能：迭代器有着比指针更细的划分并对应能力不同的功能（重载不同的运算符）\n行为：迭代器比指针更统一和良好的用法（更轻易使用begin()和end()，不用担心越界）。\n\n为什么需要迭代器\n抽象层次： 迭代器提供了对容器元素的高层次抽象，允许使用一致的方式遍历不同类型的容器，而不用关心底层实现。\n安全性： 使用迭代器可以减少指针错误的可能性，因为迭代器受到容器的保护，不容易越界访问或访问非法内存。\n容器封装： 迭代器为容器提供了一种封装，允许容器实现者更灵活地改变底层数据结构，而不会对使用容器的代码产生影响。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"C++核心编程I","url":"/2023/09/18/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8BI/","content":"今天的内容包括内存分区模型、内联函数和拷贝构造函数。\n\n\nC++核心编程1. 内存分区模型\n代码区：存放函数的二进制代码，由操作系统进行管理\n全局区：存放全局变量和静态变量以及常量\n栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n堆区：由程序员分配和释放，若程序员不释放，程序结束由操作系统释放\n\n2. 内联函数在C++中，使用关键字 inline 可以将函数定义为内联函数。内联函数的特点是它们的定义必须在每个调用它们的源文件中可见，通常这意味着函数的定义通常会写在头文件（.h）中。\n目的：在编译时将函数的代码嵌入到调用它们的地方，而不是像普通函数一样在链接时进行函数调用。因此，如果函数定义不在可见范围内，编译器无法将其内联到调用点。\n在头文件中声明内联函数的原型（函数声明），并在同一头文件中定义函数的具体实现。\n#构造函数可以直接赋初值，构造函数特性complex (double r = 0, double i = 0) : re(r),im(i)&#123;&#125;\n\n1. 不带指针的构造函数多半不需要写析构函数\t     \t如果class里面带指针，就必须有拷贝构造和拷贝复制\n2. 写在class里面的方法是内联函数（建议编译器内联，最后还是看编译器）\n3. 数据一定要放在private里面，构造函数可以放在private里面，详情见后\n以下的常成员函数在常量对象调用时起作用，若没加 const常量对象调用时会报错 ,所以该加const的地方一定要加\ndouble real() const &#123; return re; &#125;  #常成员函数\n\n\n参数传递尽量用引用，返回也是\n\n同一个class的不同object之间互为友元（firend)\n\n临时对象  typename ()\n\n如果class里面带指针，就必须有拷贝构造和拷贝复制\n\n\n\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t浅拷贝：只拷贝指针\nb &#x3D; a,如果使用编译器默认的函数，是浅拷贝，有可能导致内存泄漏\n3. 拷贝构造函数\n                                                深拷贝:复制内存\n\n拷贝赋值函数：把左边拷贝的右边分三步：1. 先把右边清空，2. 重新分配右边跟左边一样大的内存，3. 拷贝\n\n\n\n变量可以声明多次，但只能定义一次\nextern int a;\t\t#声明extern int a = 0;   #定义\n\n静态函数属于类，而不属于对象\n模板类在编译时要把.h文件和.cpp文件都要添加\n","categories":["笔记"],"tags":["c++"]},{"title":"Linux下git使用","url":"/2023/10/09/Linux%E4%B8%8Bgit%E4%BD%BF%E7%94%A8/","content":"简单介绍git的基本命令\n\nLinux下Git使用1. git的安装sudo apt install git\n\n安装完，使用git --version查看git版本\n2. 配置gitgit config --global user.name &quot;Your Name“\t##配置用户 git config --global user.email email@example.com\t##配置邮箱git config --global --list\t\t\t##查看配置信息## --global 全局配置，所有仓库生效，不加就只对当前用户有效## --system 系统配置，对所有用户生效\n\n3. 新建版本库git init\n\n4. 工作区域与文件状态\n\n5. 添加和提交文件git init\t\t##创建仓库git status\t\t##查看仓库的状态git add\t\t\t##添加到暂存库git commit \t\t##提交git rm --cached &lt;file&gt;...\t\t##将文件从暂存区中去除git log\t\t\t##查看提交记录git ls-files\t##查看暂存区的文件git commit -a -m &quot; &quot; #实现添加和提交两个步骤\n\n3. 回退版本git reset --softgit reset --hardgit reset --mixed\t\n\n\ngit reset HEAD^\t\t##默认为mixed,回退一个版本\n\nHEAD 表示当前版本HEAD^ 上一个版本HEAD^^ 上上一个版本HEAD^^^ 上上上一个版本HEAD~0 表示当前版本HEAD~1 上一个版本HEAD^2 上上一个版本HEAD^3 上上上一个版本执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存\n\n误操作之后\ngit reflog\t\t##回溯日志git reset --hard 版本号\t##回退\n\n6. 查看差异\ngit diff\t\t\t\t#默认比较工作区和暂存区之间的差异git diff HEAD\t\t\t#比较工作区和版本库之间的差异git diff --cached\t\t#比较暂存区和版本库之间的区别git diff 版本号\t版本号\t#比较两个版本之间的差异git diff HEAD~ HEAD\t\t#如回退版本\n\n\n7. 删除文件方法1：先删除本地文件，再提交\nrm -rf 3.txt\t##删除本地中的文件git add .\t\t##删除暂存区中的文件git commit -m &#x27;deleted 3.txt&#x27;\t##删除工作区文件\n\n方法2\ngit rm 2.txt\t##删除本地和暂存区中文件git commit -m &#x27;deleted 2.txt&#x27;\t##删除工作区文件\n\n\n8. 忽略文件\necho &quot;*.log&quot; &gt; .gitignore\t\t##表示忽略所有日志文件\n\n\n9. 远程仓库github注册github账号，创建仓库\n10. ssh配置和克隆仓库创建ssh密钥\ncd ~cd .ssh\t\t#如果显示文件不存在，就之间执行以下命令ssh-keygen -t rsa -b 4096 -C &quot;xxx@email.com&quot;\t#直接enter,如果是第二次执行，记得更改文件名，不然会覆盖之前的id_rsa文件，且不可逆\n\n\n执行之前的命令会生成以下两个文件，有.pub的是公钥文件，没有的是私钥文件，复制公钥文件到github的Settings里的ssh配置\n如果是第一次配置就配置完了，如果是第二次，更改了文件名的，就需要新建一个config文件，内容为\n\n意思是：当我们在访问github.com这个网站的时候。使用的是test这个文件里的密钥\ngit clone git@github.com:xxx.git\t\t##克隆新建的远程仓库\n\n\ngit push\t##将本地文件推送到远程仓库\n\n11. 关联本地仓库和远程仓库\n本地无仓库\n\necho &quot;# fist-repo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin git@github.com:xxx.gitgit push -u origin main\n\n\n本地已经有仓库\n\ngit remote add origin git@github.com:xxx.git\t\t##添加一个远程仓库git branch -M main\t\t\t\t\t\t\t\t\t##指定分支的名称为maingit push -u origin main\t\t\t\t\t\t\t\t##把本地的main分支与远程的orgin main分支关联\n\n\n\ngit remote -v\t\t##查看本地仓库对应的远程仓库别名\n\n\n\n12. 分支git branch\t\t\t#查看分支git branch\tdev\t\t#新建分支devgit checkout dev\t#切换到分支dev(有风险，有时会用来恢复文件)git switch main\t\t#切换到分支maingit merge dev\t\t#将要被合并的分支(dev)合并到当前分支(main)git log --graph --oneline --decorate --all\t##查看分支情况git branch -d dev\t#删除分支(已经合并)git branch -D dev\t#删除分支(未合并，强行删除)\n\n\n13. 回退和rebase\n\n\n14. 分支管理和工作流模型\ngit flow模型\n\n\n\n\n\ngithub flow模型\n\n\n\n","categories":["教程"],"tags":["git","linux"]},{"title":"How to be a leader","url":"/2023/11/09/How-to-be-a-leader/","content":"1.  大事情变小事情，要分的细2.  不要分配任务，要分配作业3.  要详细不要模糊","categories":["语录"],"tags":["语录"]},{"title":"C语言中\"#\"和\"##\"的用法","url":"/2023/11/21/C%E8%AF%AD%E8%A8%80%E4%B8%AD-%E5%92%8C-%E7%9A%84%E7%94%A8%E6%B3%95/","content":"C语言中”#”和”##”的用法#把宏参数变为一个字符串\n##把两个宏参数贴合在一起\n#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;#define STR(s)     #s#define CONS(a,b)  int(a##e##b)int main()&#123;   printf(STR(abc));           // 输出字符串&quot;abc&quot;   printf(&quot;\\n&quot;);   printf(&quot;%d\\n&quot;, CONS(2,3));  // 2e3 输出:2000   return 0;&#125;\n\nabc2000\n\n当宏参数是另一个宏的时候，需要注意的是凡宏定义里有用#或##的地方宏参数是不会再展开。 只有当前宏生效, 参数里的宏不会生效 ！！！\n\n\n\n举例\n#define A          (2)#define STR(s)     #s#define CONS(a,b)  int(a##e##b)printf(&quot;int max: %s\\n&quot;,  STR(INT_MAX));    // INT_MAX ＃include&lt;climits&gt;printf(&quot;%s\\n&quot;, CONS(A, A));                // compile error --- int(AeA)\n\n两句printf会被展开为：\nprintf(&quot;int max: %s\\n&quot;,&quot;INT_MAX&quot;);printf(&quot;%s\\n&quot;, int(AeA));\n\n分析\n由于A和INT_MAX均是宏，且作为宏CONS和STR的参数，并且宏CONS和STR中均含有#或者##符号，所以A和INT_MAX均不能被解引用。导致不符合预期的情况出现。\n\n\n解决这个问题的方法很简单。 加多一层中间转换宏。 加这层宏的用意是把所有宏的参数在这层里全部展开,\n那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数。\n\n#define A           (2)#define _STR(s)     #s#define STR(s)      _STR(s)          // 转换宏#define _CONS(a,b)  int(a##e##b)#define CONS(a,b)   _CONS(a,b)       // 转换宏\n\n#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;#define A           2#define _STR(s)     #s#define STR(s)      _STR(s)          // 转换宏#define _CONS(a,b)  int(a##e##b)#define CONS(a,b)   _CONS(a,b)       // 转换宏int main()&#123;   printf(STR(INT_MAX));           // 输出字符串&quot;abc&quot;   printf(&quot;\\n&quot;);   printf(&quot;%d\\n&quot;, CONS(A,A));  // 2e3 输出:2000   return 0;&#125;\n\n0x7fffffff200","categories":["每日一题"],"tags":["c++"]},{"title":"Linux中kill、kill -15、kill -9的区别","url":"/2023/11/19/Linux%E4%B8%ADkill%E3%80%81kill-15%E3%80%81kill-9%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"Linux中kill 、kill -15、kill -9 的区别kill（不加 -* 默认kill -15）命令\n系统会发送一个SIGTERM信号给对应的程序。当程序接收到该signal信号后，将会发生以下事情：\n\n程序立刻停止\n当程序释放相应资源后再停止\n程序可能仍然继续运行\n\n大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应），也就是说，**SIGTERM有可能是会被阻塞的**。\nkill -9命令\n系统给对应程序发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。\n\n在使用kill -9 前，应该先使用 kill -15，给目标进程一个清理善后工作的机会。如果没有，可能会留下一些不完整的文件或状态，从而影响服务的再次启动。\n\nkill -9这个信号可以捕获吗kill -9命令用于发送SIGKILL信号给指定的进程，强制终止该进程。SIGKILL是一个无法捕获或阻止的信号，它会立即终止目标进程，不给进程做清理或善后工作的机会。\n","categories":["每日一题"],"tags":["c++"]},{"title":"Linux高性能服务器编程I","url":"/2023/09/25/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8BI/","content":"今天的内容包括一些linux网络编程基本api和实现了TCP协议的服务端以及客户端。\n\n\n\nLinux高性能服务器编程笔记主机字节序和网络字节序大端字节序（网络字节序，数据传输，JAVA虚拟机）：高位字节存储在内存的低地址处\n小端字节序（主机字节序，现代PC机）：低位字节存储在内存的低地址处\n\n地址族类型通常与协议族类型相对应\n\n\n#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;int main(int argc ,char *argv[])&#123;    char buf[4] = &#123;192,168,1,2&#125;;    int num = *(int *)buf;    int sum = htonl(num);    unsigned char *p = &amp;sum;    printf(&quot;%d %d %d %d\\n&quot;,*p,*(p+1),*(p+2),*(p+3));    return 0;&#125;\n\n#include &lt;iostream&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char *argv[]) &#123;   \t//unsigned char buf[4] = &#123;192, 168, 1, 2&#125;;    char buf[4] = &#123;static_cast&lt;char&gt;(192), static_cast&lt;char&gt;(168), static_cast&lt;char&gt;(1), static_cast&lt;char&gt;(2)&#125;;        int num = *(int *)buf;    int sum = htonl(num);    unsigned char *p = reinterpret_cast&lt;unsigned char *&gt;(&amp;sum);    std::cout &lt;&lt; static_cast&lt;int&gt;(*p) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(*(p + 1)) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(*(p + 2)) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(*(p + 3)) &lt;&lt; std::endl;    return 0;&#125;\n\n2 1 168 192\n\nc语言代码转c++时，在初始化buf数组时，对于大于一个字节的整数，需要将其强制转换为char类型，使用static_cast&lt;char&gt;(value)进行转换即可。这样做可以避免narrowing conversion错误。\n网络里面的数据类型定义都应该用无符号，更加保险\n点分十进制转换// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1int inet_pton(int af, const char * src, void* dst);// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)const char* inet_ntop(int af, const void*  src, char* dst, socklen_t cnt);\n\n// 创建 命名 监听 socket# include &lt;sys/types.h&gt;# include &lt;sys/socket.h&gt;// domain指定使用那个协议族 PF_INET PF_INET6// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)// protocol设置为默认的0// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1int socket(int domain, int type, int protocol);// socket为socket文件描述符// my_addr 为地址信息// addrlen为socket地址长度// 成功返回0 失败返回 -1int bind(int socket, const struct sockaddr* my_addr, socklen_t addrlen);// backlog表示队列最大的长度int listen(int socket, int backlog);// 接受连接 失败返回-1 成功时返回socketint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)\n\n在Linux内核2.2之后，socket backlog参数的形为改变了，现在它指等待accept的完全建立的套接字的队列长度，而不是不完全连接请求的数量。 不完全连接的长度可以使用/proc/sys/net/ipv4/tcp_max_syn_backlog设置。这意味着当前Linux版本使用上面第二种说法，有两个队列：具有由系统范围设置指定的大小的SYN队列 和 应用程序（也就是backlog参数）指定的accept队列。\ncat /proc/sys/net/ipv4/tcp_max_syn_backlog512\n\nTCP协议\n\nTCP三次握手\n客户端#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123;    // 1. 创建套接字    int socket_fd;    socket_fd = socket(AF_INET,SOCK_STREAM,0);    // 2. 连接服务器    struct  sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(8080);    inet_pton(AF_INET,&quot;172.18.192.1&quot;,&amp;addr.sin_addr.s_addr);        connect(socket_fd,(struct sockaddr*)&amp;addr,sizeof(addr));    // 3. 读写数据    char buf[1024] = &quot;&quot;;    while(1)&#123;        int n = read(STDIN_FILENO,buf,sizeof(buf));        write(socket_fd,buf,n);     //发送数据给服务器        n = read(socket_fd,buf,sizeof(buf));        write(STDOUT_FILENO,buf,sizeof(buf));    &#125;    // 4. 关闭链接    close(socket_fd);    return 0;&#125;\n\n服务器#include&lt;iostream&gt;#include&lt;sys/socket.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123;    // 1. 创建套接字    int socket_fd;    socket_fd = socket(AF_INET,SOCK_STREAM,0);    cout&lt;&lt;socket_fd&lt;&lt;endl;    // 2. 绑定 bind    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(8010);    addr.sin_addr.s_addr = 0;   //如果是0，绑定的是通配地址   // inet_pton(AF_INET,&quot;192.168.0.102&quot;,&amp;addr.sin_addr.s_addr);    int ret = bind(socket_fd,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ret &lt; 0)&#123;        perror(&quot;&quot;);        exit(0);    &#125;    // 3. 监听 listen    listen(socket_fd,128);  //参数128是等待监听队列和已连接监听队列之和的最大值（linux2.2后，只表示已连接队列）    // 4. 提取 accept    struct sockaddr_in cliaddr; //已建立连接    socklen_t len = sizeof(cliaddr);    int Con_fd = accept(socket_fd,(struct sockaddr *)&amp;cliaddr,&amp;len);  //已连接套接字    char ip[16]=&quot;&quot;;    printf(&quot;new client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));    // 5. 读写    char buf[1024] = &quot;&quot;;    while(1)&#123;        bzero(buf,sizeof(buf));     //清空buff        int n = read(STDIN_FILENO,buf,sizeof(buf));        write(Con_fd,buf,n);        n = read(Con_fd,buf,sizeof(buf));        printf(&quot;%s\\n&quot;,buf);            &#125;    // 6. 关闭    close(socket_fd);    close(Con_fd);    return 0;&#125;\n\n可以使用命令 nc 127.0.0.1 8008连接服务器\nnew client ip=127.0.0.1 port=56918\n\n出错处理封装函数warp.c#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;void perr_exit(const char *s)&#123;\tperror(s);\texit(1);&#125;int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)&#123;\tint n;\tagain:\tif ( (n = accept(fd, sa, salenptr)) &lt; 0) &#123;\t\tif ((errno == ECONNABORTED) || (errno == EINTR))\t\t\tgoto again;\t\telse\t\t\tperr_exit(&quot;accept error&quot;);\t&#125;\treturn n;&#125;int Bind(int fd, const struct sockaddr *sa, socklen_t salen)&#123;\tint n;\tif ((n = bind(fd, sa, salen)) &lt; 0)\t\tperr_exit(&quot;bind error&quot;);\treturn n;&#125;int Connect(int fd, const struct sockaddr *sa, socklen_t salen)&#123;\tint n;\tif ((n = connect(fd, sa, salen)) &lt; 0)\t\tperr_exit(&quot;connect error&quot;);\treturn n;&#125;int Listen(int fd, int backlog)&#123;\tint n;\tif ((n = listen(fd, backlog)) &lt; 0)\t\tperr_exit(&quot;listen error&quot;);\treturn n;&#125;int Socket(int family, int type, int protocol)&#123;\tint n;\tif ( (n = socket(family, type, protocol)) &lt; 0)\t\tperr_exit(&quot;socket error&quot;);\treturn n;&#125;ssize_t Read(int fd, void *ptr, size_t nbytes)&#123;\tssize_t n;again:\tif ( (n = read(fd, ptr, nbytes)) == -1) &#123;\t\tif (errno == EINTR)\t\t\tgoto again;\t\telse\t\t\treturn -1;\t&#125;\treturn n;&#125;ssize_t Write(int fd, const void *ptr, size_t nbytes)&#123;\tssize_t n;again:\tif ( (n = write(fd, ptr, nbytes)) == -1) &#123;\t\tif (errno == EINTR)\t\t\tgoto again;\t\telse\t\t\treturn -1;\t&#125;\treturn n;&#125;int Close(int fd)&#123;\tint n;\tif ((n = close(fd)) == -1)\t\tperr_exit(&quot;close error&quot;);\treturn n;&#125;ssize_t Readn(int fd, void *vptr, size_t n)&#123;\tsize_t nleft;\tssize_t nread;\tchar *ptr;\tptr = vptr;\tnleft = n;\twhile (nleft &gt; 0) &#123;\t\tif ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123;\t\t\tif (errno == EINTR)\t\t\t\tnread = 0;\t\t\telse\t\t\t\treturn -1;\t\t&#125; else if (nread == 0)\t\t\tbreak;\t\tnleft -= nread;\t\tptr += nread;\t&#125;\treturn n - nleft;&#125;ssize_t Writen(int fd, const void *vptr, size_t n)&#123;\tsize_t nleft;\tssize_t nwritten;\tconst char *ptr;\tptr = vptr;\tnleft = n;\twhile (nleft &gt; 0) &#123;\t\tif ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123;\t\t\tif (nwritten &lt; 0 &amp;&amp; errno == EINTR)\t\t\t\tnwritten = 0;\t\t\telse\t\t\t\treturn -1;\t\t&#125;\t\tnleft -= nwritten;\t\tptr += nwritten;\t&#125;\treturn n;&#125;static ssize_t my_read(int fd, char *ptr)&#123;\tstatic int read_cnt;\tstatic char *read_ptr;\tstatic char read_buf[100];\tif (read_cnt &lt;= 0) &#123;again:\t\tif ((read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) &#123;\t\t\tif (errno == EINTR)\t\t\t\tgoto again;\t\t\treturn -1;\t\t\t&#125; else if (read_cnt == 0)\t\t\treturn 0;\t\tread_ptr = read_buf;\t&#125;\tread_cnt--;\t*ptr = *read_ptr++;\treturn 1;&#125;ssize_t Readline(int fd, void *vptr, size_t maxlen)&#123;\tssize_t n, rc;\tchar c, *ptr;\tptr = vptr;\tfor (n = 1; n &lt; maxlen; n++) &#123;\t\tif ( (rc = my_read(fd, &amp;c)) == 1) &#123;\t\t\t*ptr++ = c;\t\t\tif (c == &#x27;\\n&#x27;)\t\t\t\tbreak;\t\t&#125; else if (rc == 0) &#123;\t\t\t*ptr = 0;\t\t\treturn n - 1;\t\t&#125; else\t\t\treturn -1;\t&#125;\t*ptr = 0;\treturn n;&#125;\n\nwarp.h#ifndef __WRAP_H_#define __WRAP_H_void perr_exit(const char *s);int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr);int Bind(int fd, const struct sockaddr *sa, socklen_t salen);int Connect(int fd, const struct sockaddr *sa, socklen_t salen);int Listen(int fd, int backlog);int Socket(int family, int type, int protocol);ssize_t Read(int fd, void *ptr, size_t nbytes);ssize_t Write(int fd, const void *ptr, size_t nbytes);int Close(int fd);ssize_t Readn(int fd, void *vptr, size_t n);ssize_t Writen(int fd, const void *vptr, size_t n);ssize_t my_read(int fd, char *ptr);ssize_t Readline(int fd, void *vptr, size_t maxlen);#endif\n\n\n多进程服务端#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt; #define BUF_SIZE 256 void do_sigchld(int signo, siginfo_t *siginfo, void *p)&#123;    int status;    pid_t pid;    while((pid = waitpid(0, &amp;status, WNOHANG)) &gt; 0) //0:回收跟调用进程同组的子进程的资源，WNOHANG:不阻塞    &#123;        if (WIFEXITED(status))            printf(&quot;pid = %d, parent pid = %d, child pid = %d, exit status %d\\n&quot;, pid, getpid(), siginfo-&gt;si_pid, WEXITSTATUS(status));        else if (WEXITSTATUS(status))            printf(&quot;pid = %d, parent pid = %d, child pid = %d, exit by signal %d\\n &quot;, pid, getpid(), siginfo-&gt;si_pid, WIFSIGNALED(status));    &#125;&#125; void sys_err(const char *str, int err)&#123;    perror(str);    exit(err);&#125; int main(int argc, char *argv[])&#123;    if (argc &lt; 2)    &#123;        printf(&quot;%s port\\n&quot;, argv[0]);        exit(1);    &#125;    //创建流式套接字    int lfd = socket(AF_INET, SOCK_STREAM, 0);    if (lfd &lt; 0)        sys_err(&quot;socket&quot;, 1);     //绑定ip端口        struct sockaddr_in server_addr;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons((unsigned short)atoi(argv[1]));    server_addr.sin_addr.s_addr = 0; //0表示将本机所有ip都绑定上    int ret = bind(lfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));    if (ret &lt; 0)        sys_err(&quot;bind&quot;, 1);        //监听    ret = listen(lfd, 128);    if (ret &lt; 0)        sys_err(&quot;listen&quot;, 1);        //阻塞SIGCHLD信号    sigset_t set;    sigemptyset(&amp;set);    sigaddset(&amp;set, SIGCHLD);    sigprocmask(SIG_BLOCK, &amp;set, NULL);    int block = 1;    //循环提取    int cfd;    pid_t pid;    struct sockaddr_in client_addr;     socklen_t len = sizeof(client_addr);    char buf[BUF_SIZE];    ssize_t size;    char ip[INET_ADDRSTRLEN] = &quot;&quot;;    while(1)    &#123;        cfd = accept(lfd, (struct sockaddr *)&amp;client_addr, &amp;len);        if (cfd &lt; 0)        &#123;            if (errno == EINTR)                continue;             sys_err(&quot;accept&quot;, 1);        &#125;         printf(&quot;client ip = %s, port = %d connect success\\n&quot;, inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, ip, sizeof(ip)), ntohs(client_addr.sin_port));        pid = fork();        if (pid == 0)        &#123;            //in child            close(lfd); //关闭不用了的监听套接字            //解除阻塞SIGCHLD信号            sigprocmask(SIG_UNBLOCK, &amp;set, NULL);            block = 0;             while(1)            &#123;                memset(buf, 0, sizeof(buf));                size = read(cfd, buf, sizeof(buf));                if (size == 0) //客户端断开连接                &#123;                    printf(&quot;client close\\n&quot;);                    break;                &#125;                 printf(&quot;%s\\n&quot;, buf);                write(cfd, buf, size);            &#125;             break;        &#125;        else if (pid &gt; 0)        &#123;            //in parent            close(cfd); //关闭不用了的跟客户端通讯的套接字            if (1 == block)            &#123;                //先捕捉                struct sigaction sa;                sa.sa_sigaction = do_sigchld;                sigemptyset(&amp;sa.sa_mask);                sa.sa_flags = SA_SIGINFO;                sigaction(SIGCHLD, &amp;sa, NULL);                //后解除阻塞                sigprocmask(SIG_UNBLOCK, &amp;set, NULL);                block = 0;            &#125;        &#125;        else            sys_err(&quot;fork&quot;, 1);    &#125;        //关闭套接字    if (pid == 0)        close(cfd);    else if (pid &gt; 0)        close(lfd);     return 0;&#125;\n\nnew client ip=127.0.0.1 port=53766wnew client ip=127.0.0.1 port=53768q\n\nfree_process 函数是用于处理子进程的结束的信号处理函数。当子进程结束时，父进程会收到 SIGCHLD 信号，该信号会触发 free_process 函数。这个函数使用 waitpid 函数来回收子进程，避免它们成为僵尸进程。\n多线程服务端#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &quot;wrap.h&quot;typedef struct c_info&#123;    int cfd;    struct sockaddr_in cliaddr;&#125;CINFO;void* client_fun(void *arg);int main(int argc, char *argv[])&#123;    if(argc &lt; 2)&#123;        printf(&quot;argc &lt; 2  \\n ./test 8000\\n&quot;);        return 0;    &#125;    pthread_attr_t attr;    pthread_attr_init(&amp;attr);    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED); //设置线程的分离状态为分离态,线程在退出后会自动释放其资源，而不需要其他线程等待它结束。    short port = atoi(argv[1]);    int lfd = tcp4bind(port,NULL);  //创建套接字，绑定    Listen(lfd,5);    struct sockaddr_in cliaddr;    socklen_t len = sizeof(cliaddr);    CINFO *info;    while(1)&#123;        int cfd = Accept(lfd,(struct sockaddr *)&amp;cliaddr,&amp;len);        char ip[16]=&quot;&quot;;       // printf(&quot;new client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));        pthread_t pthid;        info = malloc(sizeof(CINFO));        info-&gt;cfd = cfd;        info-&gt;cliaddr = cliaddr;       // pthread_create(&amp;pthid,NULL,client_fun,info);         pthread_create(&amp;pthid,&amp;attr,client_fun,info);    &#125;    return 0;&#125;void* client_fun(void *arg)&#123;    CINFO *info = (CINFO *)arg;    char ip[16];    printf(&quot;new client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET,&amp;info-&gt;cliaddr.sin_addr.s_addr,ip,16),ntohs(info-&gt;cliaddr.sin_port));    while(1)&#123;        char buf[1024]=&quot;&quot;;        int n = read(info-&gt;cfd,buf,sizeof(buf));        if(n &lt; 0)&#123;            perror(&quot;&quot;);            break;        &#125;else if(n == 0)&#123;            printf(&quot;client close\\n&quot;);            break;        &#125;else&#123;            printf(&quot;%s\\n&quot;,buf);            write(info-&gt;cfd,buf,n);        &#125;    &#125;    close(info-&gt;cfd);    free(info);&#125;\n\n端口复用int opt = 1;setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));\n\n","categories":["笔记"],"tags":["c++","linux","c","网络编程"]},{"title":"Linux中最大socket数量","url":"/2023/11/20/Linux%E4%B8%AD%E6%9C%80%E5%A4%A7socket%E6%95%B0%E9%87%8F/","content":"Linux中最大socket数量linux系统默认ulimit为1024个访问，用户最多可开启的程序数目。一般一个端口的最高连接为2的16次方65535。\n查看全局文件句柄数限制(系统支持的最大值)\ncat /proc/sys/fs/file-max\n\n查看每个进程文件句柄数限制\nulimit -n\n\n如何修改最大连接数量870-Linux下解决高并发socket最大连接数限制_socket 连接数_林林林ZEYU的博客-CSDN博客\n","categories":["每日一题"],"tags":["c++"]},{"title":"define和const区别","url":"/2023/11/24/define%E5%92%8Cconst%E5%8C%BA%E5%88%AB/","content":"define 和 const 区别对于 define 来说， 宏定义实际上是在预编译阶段进行处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进行字符串的展开，遇到多少次就展开多少次，而且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为define宏定义仅仅是展开，因此运行时系统并不为宏定义分配内存，（但是从汇编的角度来讲，define却以立即数的方式保留了多份数据的拷贝）。\n对于 const 来说， const 是在编译期间进行处理的，const 有类型，也有类型检查，程序运行时系统会为 const 常量分配内存，而且从汇编的角度讲，const 常量在出现的地方保留的是真正数据的内存地址，只保留了一份数据的拷贝，省去了不必要的内存空间。而且，有时编译器不会为普通的const常量分配内存，而是直接将const常量添加到符号表中，省去了读取和写入内存的操作，效率更高。\n","categories":["每日一题"],"tags":["c++"]},{"title":"http怎么实现长连接","url":"/2023/12/21/http%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5/","content":"http怎么实现长连接HTTP/1.1起，默认使⽤长连接，⽤以保持连接特性。使⽤长连接的 HTTP协议，会在响应头加⼊这⾏代码：Connection:keep-alive\n在使⽤长连接的情况下，当⼀个⽹页打开完成后，客户端和服务器之间⽤于传输 HTTP 数据 的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。\nKeep-Alive 不会永久保持连接，它有⼀个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都⽀持长连接。 HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。\n","categories":["每日一题"],"tags":["c++"]},{"title":"new和delete与malloc和free的区别","url":"/2023/11/26/new%E5%92%8Cdelete%E4%B8%8Emalloc%E5%92%8Cfree%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"new &#x2F; delete malloc &#x2F; free 区别都可以用来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。\n执行 new 实际上执行两个过程：\n\n分配未初始化的内存空间（malloc）；\n\n使用对象的构造函数对空间进行初始化；返回空间的首地址。\n\n\n如果在第一步分配空间中出现问题，则抛出std::bad_alloc异常，或被某个设定的异常处理函数捕获处理；如果在第二步构造对象时出现异常，则自动调用delete释放内存。\n\n\n执行 delete 实际上也有两个过程：\n\n使用析构函数对对象进行析构；\n回收内存空间（free）。\n\n以上也可以看出new和 malloc 的区别，new 得到的是经过初始化的空间，而malloc得到的是未初始化的空间。所以 new 是 new 一个类型，而 malloc 则是malloc一个字节长度的空间。delete 和 free同理，delete不仅释放空间还析构对象，delete 一个类型，free 一个字节长度的空间。\n\n\n为什么有了 malloc／free ,还需要 new／delete？ \n因为对于非内部数据类型而言，光用 malloc／free 无法满足动态对象的要求。对象在创建的同时需要自动执行构造函数，对象在消亡以前要自动执行析构函数。由于 mallo／free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于 malloc／free，所以有了new／delete操作符。\n","categories":["每日一题"],"tags":["c++"]},{"title":"strlen和sizeof的区别","url":"/2023/11/18/strlen%E5%92%8Csizeof%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"strlen 和 sizeof的区别sizeof是C语言中的一个单目运算符，用来计算数据类型所占空间的大小，单位为字节；而strlen是一个函数，用来计算字符串长度。简单来说，就是sizeof不包含\\0,而strlen包含\\0。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar arr1[]=&quot;abcd&quot;;//d的后面自动补上\\0;\tchar arr2[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;//以单个元素赋值，没有\\0的结束符\tprintf(&quot;strlen1=%d\\n&quot;,strlen(arr1));//strlen()计算\\0之前的字符长度\tprintf(&quot;strlen2=%d\\n&quot;,strlen(arr2));//该处计算结果应为随机值，因为arr2[]没定义元素个数，就无法知道在哪能遇到\\0;\tprintf(&quot;sizeof1=%d\\n&quot;,sizeof(arr1));//计算了包含\\0的数据空间大小\tprintf(&quot;sizeof2=%d\\n&quot;,sizeof(arr2));\treturn 0; &#125; \n\nstrlen1=4strlen2=8sizeof1=5sizeof2=4","categories":["每日一题"],"tags":["c++"]},{"title":"vector怎么扩容","url":"/2023/11/22/vector%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9/","content":"vector怎么扩容在 C++ 的标准库中，std::vector 是一个动态数组，其扩容是通过重新分配内存来实现的。当 std::vector 的元素数量达到当前分配的内存大小时，系统会为std::vector分配一块更大的内存，并将原来的元素复制到新的内存中。这个过程中原来的内存会被释放。\nstd::vector 扩容的基本步骤：\n\n分配新的内存：当 std::vector 中的元素个数达到当前分配的内存大小时，需要分配一块新的内存。新的内存大小通常是当前内存大小的两倍(Linux端），(Windows是1.5倍），这样做是为了保证std::vector的操作复杂度为平摊 O(1)。\n将元素复制到新内存：将原来的元素逐个复制到新分配的内存中。\n释放旧内存：释放原来的内存空间。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"sprintf与snprintf区别","url":"/2023/11/21/sprintf%E4%B8%8Esnprintf%E5%8C%BA%E5%88%AB/","content":"sprintf与snprintf区别int sprintf(char *str, const char &amp;format, ...);\n\nsprintf是字符串格式化命令，主要功能是把格式化的数据写入字符串str中，返回值为写入str的字节数，结束字符\\0不计入内。其中， str是指要写入的缓冲区，format控制要写入str中数据的格式，例如%s、%d、%x等。\nint snprintf(char *str, size_t size, const char *format, ...);\n\nsnprintf是字符串格式化命令，主要功能是把格式化的数据写入字符串str中，最多写size个字节，包括自动添加在字符串末尾处的结束字符\\0;返回值为写入str的字节数，**包括结束字符\\0**。\nsprintf函数返回的是实际输出到字符串缓冲中的字符个数,而snprintf函数返回的是应该输出到字符串缓冲的字符个数\n#define snprintf_nowarn(...) (snprintf(__VA_ARGS__) &lt; 0 ? abort() : (void)0)\n\n该宏用于调用 snprintf 函数，并检查其返回值是否小于 0。snprintf 函数是一个安全的字符串格式化函数，用于将格式化的数据写入字符串。这里的目的是在调用 snprintf 时，如果返回值小于 0，就调用 abort() 函数，中止程序运行，以防止潜在的错误。\n","categories":["每日一题"],"tags":["c++"]},{"title":"五种I/O模型","url":"/2023/12/19/%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B/","content":"五种I&#x2F;O模型阻塞 I&#x2F;O 模型（Blocking I&#x2F;O）：\n\n在阻塞 I&#x2F;O 模型中，当应用程序发起一个 I&#x2F;O 操作时，它会被阻塞，直到操作完成。\n这意味着应用程序无法执行其他任务，直到 I&#x2F;O 操作完成。\n\n非阻塞 I&#x2F;O 模型（Non-blocking I&#x2F;O）：\n\n在非阻塞 I&#x2F;O 模型中，应用程序可以继续执行其他任务而不必等待 I&#x2F;O 操作的完成。\n当一个 I&#x2F;O 操作发起后，应用程序可以立即返回并执行其他任务，然后周期性地检查 I&#x2F;O 操作是否完成。\n\n多路复用 I&#x2F;O 模型（I&#x2F;O Multiplexing）：\n\n多路复用 I&#x2F;O 模型使用 select、poll 或 epoll 等机制，允许应用程序监视多个文件描述符，等待其中任何一个变为可读或可写状态。\n当有数据准备好时，应用程序会得到通知，然后可以进行读或写操作。\n\n信号驱动IO\n\nlinux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。\n\n阻塞I&#x2F;O，非阻塞I&#x2F;O，信号驱动I&#x2F;O和I&#x2F;O复用都是同步I&#x2F;O。同步I&#x2F;O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I&#x2F;O操作，异步I&#x2F;O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I&#x2F;O操作。\nUNIX五种IO模型 | 蓝亭书序 (lantingshuxu.github.io)\n","categories":["每日一题"],"tags":["c++"]},{"title":"从零实现WebServer之日志类","url":"/2023/12/29/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0WebServer%E4%B9%8B%E6%97%A5%E5%BF%97%E7%B1%BB/","content":"从零实现WebServer之日志类阻塞队列模板类构造函数，初始化队列的最大容量，默认为1000block_queue(int max_size &#x3D; 1000);析构函数，清空队列~block_queue();清空队列void clear();判断队列是否已满bool full();判断队列是否为空bool empty();返回队首元素bool front(T &amp;item);返回队尾元素bool back(T &amp;item);获取队列当前元素个数int get_size();获取队列的最大容量int get_max_size();向队尾添加元素bool push_back(const T &amp;item);从队头弹出元素bool pop(T &amp;item);增加超时处理的pop函数bool pop(T &amp;item, int ms_timeout);\n\n\n#ifndef BLOCK_QUEUE_H#define BLOCK_QUEUE_H#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;sys/time.h&gt;#include &lt;deque&gt;#include &quot;../locker/locker.h&quot;using namespace std;// 阻塞队列模板类template &lt;class T&gt;class block_queue&#123;    public:    // block_queue类的构造函数用于初始化实例    block_queue(int max_size = 1000)&#123;        if(max_size &lt;= 0)&#123;            exit(-1);        &#125;        m_max_size = max_size;            &#125;    ~block_queue()&#123;        clear();    &#125;    // clear 函数通过互斥锁确保了对队列的操作是线程安全的    void clear()&#123;        m_mutex.lock();     // 加锁，确保在多线程环境中对队列的操作是互斥的        m_deque.clear();    // 清空队列，移除所有元素        m_mutex.unlock();   // 解锁，释放互斥锁，允许其他线程对队列进行操作    &#125;    bool full()&#123;        m_mutex.lock();        if(m_deque.size() &gt;= m_max_size)&#123;            m_mutex.unlock();   // 如果队列已满，解锁互斥锁            return true;        &#125;        m_mutex.unlock();        return false;    &#125;    bool empty()&#123;        m_mutex.lock();        if(m_deque.empty())            return true;        m_mutex.unlock();        return false;    &#125;    bool front(T &amp;item)&#123;        m_mutex.lock();        if(m_deque.empty())&#123;            m_mutex.unlock();            return false;        &#125;        item = m_deque.front();        m_mutex.unlock();        return true;    &#125;    bool back(T &amp;item)&#123;        m_mutex.lock();        if(m_deque.empty())&#123;            m_mutex.unlock();            return false;        &#125;        item = m_deque.back();        m_mutex.unlock();        return true;    &#125;    int get_size()&#123;        int temp = 0;        m_mutex.lock();        temp = m_deque.size();        m_mutex.unlock();        return temp;    &#125;    int get_max_size()&#123;        int temp = 0;        m_mutex.lock();        temp = m_max_size;        m_mutex.unlock();        return temp;    &#125;    bool push_back(const T &amp;item)&#123;        m_mutex.lock();     // 加锁，确保在多线程环境中对队列的操作是互斥的        if(m_deque.size() &gt;= m_max_size)&#123;   // 判断队列大小是否达到最大允许大小            m_cond.broadcast();     // 唤醒所有在条件变量上等待的线程            m_mutex.unlock();   // 解锁互斥锁            return false;       // 返回false，表示队列已满，无法添加元素        &#125;        m_deque.push_back(item);    // 向队列尾部添加元素        m_cond.broadcast(); // 唤醒所有在条件变量上等待的线程        m_mutex.unlock();   // 解锁互斥锁        return true;    &#125;    bool pop(T &amp;item)&#123;        m_mutex.lock();        while(m_deque.empty())&#123;     // 使用循环等待，直到队列非空            if(!m_cond.wait(m_mutex.get()))&#123;    // 如果条件变量等待失败                m_mutex.unlock();   // 解锁互斥锁                return false;            &#125;        &#125;        item = m_deque.front();        m_deque.pop_front();        m_mutex.unlock();        return true;    &#125;    // 增加超时处理    bool pop(T &amp;item, int ms_timeout) &#123;        struct timespec t = &#123;0, 0&#125;;  // s and ns        struct timeval now = &#123;0, 0&#125;; // s and ms        gettimeofday(&amp;now, nullptr);        m_mutex.lock();        if (m_size &lt;= 0) &#123;            t.tv_sec = now.tv_sec + ms_timeout / 1000;            t.tv_nsec = (ms_timeout % 1000) * 1000;     //使用超时参数 ms_timeout 计算出等待的超时时间            if (!m_cond.timewait(m_mutex.get(), t)) &#123;   // 等待超时处理                m_mutex.unlock();                return false;            &#125;        &#125;        item = m_deque.front();        m_deque.pop_front();        m_mutex.unlock();        return true;    &#125;private:    mutexlocker m_mutex;    // 互斥锁    condvar m_cond;         // 条件变量，用于在队列为空或队列已满时进行等待和唤醒    deque&lt;T&gt; m_deque;    int m_max_size;&#125;;#endif\n\n这个block_queue类是一个线程安全的阻塞队列实现，使用了互斥锁和条件变量来保证在多线程环境中的操作的互斥性和同步性。这个block_queue类适用于需要在多线程环境中进行数据共享的场景，提供了一种安全且高效的队列实现。\n\n线程安全性：通过使用mutexlocker和condvar实现了互斥锁和条件变量，确保多个线程对队列的并发操作是安全的。\n阻塞操作：在队列为空时，pop操作将会等待直到队列中有元素可供取出；在队列已满时，push_back操作将会等待直到队列中有空位可供插入。\n容量控制：通过full()和empty()方法提供了对队列是否已满或为空的判断。\n超时处理：pop操作提供了带有超时参数的版本，允许用户设定最长等待时间，避免无限等待。\n使用deque实现：底层使用了std::deque作为队列容器，相比于std::queue，std::deque允许从队列的前端和后端高效地进行元素的添加和删除。\n清空队列：提供了clear方法，用于清空队列并释放资源。\n异常处理：在构造函数中，如果指定的最大容量小于等于0，程序将终止，以防止非法输入。\n\n日志类流程图\n获取实例 get_instance // 公有静态方法，用于获取唯一的实例static Log* get_instance()&#123;    // 静态局部变量，确保只在第一次调用该函数时创建一个实例    static Log instance;    // 返回指向实例的指针    return &amp;instance;&#125;\n\n\nget_instance 是一个公有的静态成员函数，用于获取类的唯一实例。\nstatic Log instance; 是一个静态局部变量，确保在程序的整个生命周期内只有一个实例。这是C++11引入的线程安全的局部静态变量。\nreturn &amp;instance; 返回指向唯一实例的指针。\n\n构造函数 Logprivate:    Log();    ~Log();    // 防止复制构造和赋值操作，确保单例的唯一性    Log(const Log&amp;) = delete;    Log&amp; operator=(const Log&amp;) = delete;\n\n这是一个典型的单例模式实现，通过将构造函数和析构函数声明为私有的，以及禁用拷贝构造函数和赋值操作符，确保了类的单例性。这样，只能通过 get_instance 函数获取唯一的实例，而不能直接复制或赋值。\n\n构造函数和析构函数是私有的，防止外部直接实例化或销毁对象。\n拷贝构造函数和赋值操作符被删除，防止复制对象。\nget_instance 函数提供了获取类唯一实例的途径，同时在需要时进行实例化。\n\n异步写 async_write_log// 异步写    void async_write_log()&#123;        string single_log;        // 从阻塞队列取出一个日志        while(m_log_duque-&gt;pop(single_log))&#123;            m_mutex.lock();            // 写入后文件指针后移            fputs(single_log.c_str(),m_fp);            m_mutex.unlock();                &#125;    &#125;\n\n\nasync_write_log 函数通过阻塞队列 m_log_duque 获取一个日志条目 single_log。\n通过互斥锁 m_mutex 对文件指针 m_fp 进行保护，确保在多线程环境下对文件的写入操作是互斥的。\n使用 fputs(single_log.c_str(), m_fp); 将日志写入文件。这里假设 single_log 中已经包含了完整的日志内容，因为它是从阻塞队列中取出的。\n写入完成后解锁互斥锁，允许其他线程进行文件写入。\n\n需要注意的是，这个函数的执行是在一个独立的线程中进行的，通过异步写入的方式，避免了在主线程中直接写文件可能导致的性能问题。这种异步的方式允许主线程继续执行其他任务，而不必等待文件写入完成。\n// 线程工作函数，静态函数防止this指针static void* flush_log_thread(void *args)&#123;    Log::get_instance()-&gt;async_write_log();    return nullptr;&#125;\n\n\nflush_log_thread 是一个静态成员函数，它被设计为一个线程的入口函数，用于执行异步写日志的操作。\n静态函数中调用了 Log::get_instance()-&gt;async_write_log();，这样就通过单例模式获取了 Log 类的唯一实例，然后调用了 async_write_log 函数，实现了异步写日志的逻辑。\n函数返回 nullptr，这是符合线程入口函数的标准，即线程执行完毕后返回的是 nullptr。\n\n这段代码的目的是启动一个线程，用于在后台执行异步写日志的操作，从而不阻塞主线程的执行。在 Log 类的构造函数中，可以看到这个线程是在初始化时被创建的。该线程的生命周期和 Log 类的生命周期是一致的。当 Log 类的实例被销毁时，这个线程也应该被正确地终止。\n宏定义 snprintf_nowarn// 检查snprintf返回值，防止warning#define snprintf_nowarn(...) (snprintf(__VA_ARGS__) &lt; 0 ? abort() : (void)0)// 可变参数宏__VA_ARGS__，当可变参数个数为0时，##__VA_ARGS__把前面多余的“，”去掉#define LOG_DEBUG(format, ...) if(m_close_log == 0) &#123;Log::get_instance()-&gt;write_log(0, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_INFO(format, ...) if(m_close_log == 0) &#123;Log::get_instance()-&gt;write_log(1, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_WARN(format, ...) if(m_close_log == 0) &#123;Log::get_instance()-&gt;write_log(2, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_ERROR(format, ...) if(m_close_log == 0) &#123;Log::get_instance()-&gt;write_log(3, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;\n\n这段代码定义了一组宏，用于在日志中输出不同级别的日志信息。下面是对每个宏的解释：\n\nsnprintf_nowarn: 这是一个宏，用于检查 snprintf 的返回值，防止编译器产生警告。如果 snprintf 返回值小于 0，就调用 abort 终止程序，否则不进行任何操作。\nLOG_DEBUG(format, ...): 这是一个宏，用于输出调试级别的日志信息。如果 m_close_log 不为 0（即日志未关闭），则调用 Log::get_instance()-&gt;write_log(0, format, ##__VA_ARGS__) 写入调试日志，然后调用 Log::get_instance()-&gt;flush() 刷新日志。\nLOG_INFO(format, ...): 类似于 LOG_DEBUG，用于输出信息级别的日志。\nLOG_WARN(format, ...): 类似于 LOG_DEBUG，用于输出警告级别的日志。\nLOG_ERROR(format, ...): 类似于 LOG_DEBUG，用于输出错误级别的日志。\n\n这些宏的使用方式类似于普通的日志输出函数，但通过宏的方式可以方便地控制是否输出日志（通过 m_close_log 变量的值判断）。这样的设计可以在日志关闭时，避免不必要的字符串拼接和日志输出操作，提高程序性能。\n初始化日志 init// 初始化日志，异步需要设置阻塞队列的长度，同步不需要bool Log::init(const char *file_name, int log_buf_size, int split_lines, int max_queue_size)&#123;    // 如果设置了max_queue_size,则设置为异步    if(max_queue_size &gt;= 1)&#123;        m_is_async = true;        m_log_duque = new block_queue&lt;string&gt;(max_queue_size);        //创建线程异步写        pthread_t tid;        pthread_create(&amp;tid,nullptr,flush_log_thread,nullptr);    &#125;    // 初始化日志    m_log_buf_size = log_buf_size;    m_buf = new char[m_log_buf_size];    memset(m_buf,0,m_log_buf_size);    m_split_lines = split_lines;    // 获取当前时间    time_t t = time(nullptr);    struct tm *sys_tm = localtime(&amp;t);    struct tm my_tm = *sys_tm;    // 查找字符从右边开始第一次出现的位置，截断文件名    const char *p = strrchr(file_name,&#x27;/&#x27;);    char log_full_name[256] = &#123;0&#125;;    // 构造日志文件名    if(p == nullptr)&#123;        // 将可变参数格式化到字符串中        // 没有/则直接到当前路径下        snprintf_nowarn(log_full_name,255,&quot;%d_%02d_%02d_%s&quot;,my_tm.tm_year + 1900,my_tm.tm_mon+1,my_tm.tm_mday,file_name);    &#125;else&#123;        strcpy(log_name,p+1);   // 日志文件名        strncpy(dir_name,file_name,p-file_name+1);  // 日志路径        snprintf_nowarn(log_full_name,255,&quot;%s%d_%02d_%02d_%s&quot;,dir_name,my_tm.tm_year + 1900,my_tm.tm_mon+1,my_tm.tm_mday,log_name);    &#125;    m_today = my_tm.tm_mday;    // 追加写    m_fp = fopen(log_full_name,&quot;a&quot;);    if(m_fp == nullptr)        return false;    return true;&#125;\n\n这段 C++ 代码定义了日志类 Log 中的初始化函数 init。此函数用于初始化日志记录，包括设置日志文件名、缓冲区大小、拆分行数等参数。如果设置了异步模式，还会创建一个线程用于异步写日志。\n\n判断是否启用异步模式：\n\nif (max_queue_size &gt;= 1) &#123;    m_is_async = true;    m_log_duque = new block_queue&lt;string&gt;(max_queue_size);    // 创建线程异步写    pthread_t tid;    pthread_create(&amp;tid, nullptr, flush_log_thread, nullptr);&#125;\n\n如果设置了 max_queue_size 大于等于 1，表示启用异步模式。在异步模式下，创建了一个 block_queue&lt;string&gt; 类型的阻塞队列，并通过线程 pthread_create 创建了一个用于异步写日志的线程。\n\n初始化日志参数：\n\nm_log_buf_size = log_buf_size;m_buf = new char[m_log_buf_size];memset(m_buf, 0, m_log_buf_size);m_split_lines = split_lines;\n\n初始化日志缓冲区大小、拆分行数等参数。\n\n获取当前时间并构造日志文件名：\n\ntime_t t = time(nullptr);struct tm *sys_tm = localtime(&amp;t);struct tm my_tm = *sys_tm;const char *p = strrchr(file_name, &#x27;/&#x27;);char log_full_name[256] = &#123;0&#125;;\n\n获取当前时间，并通过 localtime 函数转换为本地时间。根据文件名中是否包含路径分隔符 /，构造日志文件名 log_full_name。\n\n设置日志文件名和路径：\n\nif (p == nullptr) &#123;    snprintf_nowarn(log_full_name, 255, &quot;%d_%02d_%02d_%s&quot;, my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, file_name);&#125; else &#123;    strcpy(log_name, p + 1);   // 日志文件名    strncpy(dir_name, file_name, p - file_name + 1);  // 日志路径    snprintf_nowarn(log_full_name, 255, &quot;%s%d_%02d_%02d_%s&quot;, dir_name, my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, log_name);&#125;\n\n根据文件名中是否包含路径分隔符 /，设置日志文件名和路径。如果没有路径分隔符，则直接在当前路径下创建日志文件。如果文件名中包含路径分隔符，首先使用 strcpy 将文件名部分（不包含 /）拷贝到 log_name 中。接着，使用 strncpy 将路径部分拷贝到 dir_name 中，注意这里复制的长度为 p - file_name + 1，确保包含路径分隔符。最后，使用 snprintf_nowarn 将路径和文件名组合成完整的日志文件名。\n\n打开日志文件：\n\nm_fp = fopen(log_full_name, &quot;a&quot;);if (m_fp == nullptr)    return false;\n\n使用 fopen 打开日志文件，以追加写入的方式打开。如果打开失败，则返回 false。\n写日志 write_log// 写日志void Log::write_log(int level, const char *format,...)&#123;    // 秒、微妙    struct timeval now = &#123;0,0&#125;;    gettimeofday(&amp;now,nullptr);    // 获取时间结构体    time_t t = now.tv_sec;    struct tm *sys_tm = localtime(&amp;t);    struct tm my_tm = *sys_tm;    // 临界区加锁    m_mutex.lock();    m_count++;    // 新的一天或者日志达到最大行数，需要更换日志文件    if(m_today != my_tm.tm_mday || m_count % m_split_lines == 0)&#123;        // 刷新文件缓冲并关闭文件        fflush(m_fp);        fclose(m_fp);        // 新日志路径        char new_log[256] = &#123;0&#125;;        char tail[16] = &#123;0&#125;;        snprintf_nowarn(tail,16,&quot;%d_%02d_%02d_&quot;,my_tm.tm_year + 1900,my_tm.tm_mon+1,my_tm.tm_mday);        // 天数变化        if(m_today != my_tm.tm_mday)&#123;            snprintf_nowarn(new_log,255,&quot;%s%s%s&quot;,dir_name,tail,log_name);            m_today = my_tm.tm_mday;            m_count = 0;        &#125;else&#123;  // 日志达到最大行数            snprintf_nowarn(new_log,255,&quot;%s%s%s.%lld&quot;,dir_name,tail,log_name,m_count / m_split_lines);        &#125;        // 打开新日志        m_fp = fopen(new_log,&quot;a&quot;);           &#125;    m_mutex.unlock();    // 日志级别    char s[16] = &#123;0&#125;;    switch(level)&#123;        case 0:             strcpy(s,&quot;[debug]:&quot;);            break;        case 1:            strcpy(s,&quot;[info]:&quot;);            break;        case 2:            strcpy(s,&quot;[warn]:&quot;);            break;        case 3:            strcpy(s,&quot;[error]:&quot;);            break;        default:           strcpy(s,&quot;[debug]:&quot;);            break;     &#125;    // 临界区加锁    m_mutex.lock();    // 构造日志内容、时间、级别    int n = snprintf(m_buf,48,&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s&quot;,                            my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday,                            my_tm.tm_hour,my_tm.tm_min,my_tm.tm_sec,now.tv_usec,s);    if(n &lt; 0)&#123;        abort();    &#125;    // 正文    va_list valst;    va_start(valst,format);    int m = vsnprintf(m_buf + n,m_log_buf_size -1, format, valst);    if(m &lt; 0)&#123;        abort();    &#125;    va_end(valst);    m_buf[n + m] = &#x27;\\n&#x27;;    m_buf[n + m + 1] = &#x27;\\0&#x27;;    // 异步写    if(m_is_async &amp;&amp; !m_log_duque-&gt;full())&#123;        m_log_duque-&gt;push_back(m_buf);    &#125;else&#123;  // 同步写        fputs(m_buf,m_fp);    &#125;    m_mutex.unlock();&#125;\n\n这段代码是 Log 类的写日志函数 write_log，它实现了日志的记录和切割功能。以下是对代码的详细解释：\n\n获取当前时间：\nstruct timeval now = &#123;0,0&#125;;gettimeofday(&amp;now,nullptr);time_t t = now.tv_sec;struct tm *sys_tm = localtime(&amp;t);struct tm my_tm = *sys_tm;\n\n使用 gettimeofday 获取当前时间（秒和微秒），然后将秒数转换为本地时间结构体 tm，保存在 my_tm 中。\n\n判断是否需要切换日志文件：\nm_mutex.lock();m_count++;if (m_today != my_tm.tm_mday || m_count % m_split_lines == 0) &#123;\n\n每次写入日志，都会判断当前日期是否与 m_today 相同，以及是否达到了日志的最大行数。如果是，则需要切换到新的日志文件。\n\n关闭并刷新当前日志文件，打开新日志文件：\nfflush(m_fp);fclose(m_fp);char new_log[256] = &#123;0&#125;;char tail[16] = &#123;0&#125;;\n\n先刷新和关闭当前的日志文件，然后构造新的日志文件名。如果是新的一天，直接拼接日期和文件名，如果是同一天但已达到最大行数，追加一个序号。\n\n构造新的日志文件路径：\nsnprintf_nowarn(tail,16,&quot;%d_%02d_%02d_&quot;,my_tm.tm_year + 1900,my_tm.tm_mon+1,my_tm.tm_mday);if (m_today != my_tm.tm_mday) &#123;    snprintf_nowarn(new_log,255,&quot;%s%s%s&quot;,dir_name,tail,log_name);    m_today = my_tm.tm_mday;    m_count = 0;&#125; else &#123;    snprintf_nowarn(new_log,255,&quot;%s%s%s.%lld&quot;,dir_name,tail,log_name,m_count / m_split_lines);&#125;\n\n使用 snprintf_nowarn 构造新的日志文件路径，并更新 m_today 和 m_count。\n\n打开新的日志文件：\nm_fp = fopen(new_log,&quot;a&quot;);\n\n使用 fopen 打开新的日志文件，以追加写入的方式。\n\n构造日志级别前缀：\nchar s[16] = &#123;0&#125;;switch(level)&#123;    // ...&#125;\n\n根据传入的日志级别（0: Debug, 1: Info, 2: Warn, 3: Error）选择对应的日志级别前缀。\n\n构造日志内容：\nint n = snprintf(m_buf,48,&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s&quot;,                  my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday,                        my_tm.tm_hour,my_tm.tm_min,my_tm.tm_sec,now.tv_usec,s);\n\n使用 snprintf 构造时间戳和日志级别前缀。\n\n构造日志正文：\nva_list valst;va_start(valst,format);int m = vsnprintf(m_buf + n,m_log_buf_size -1, format, valst);va_end(valst);\n\nva_list 是一个指向参数的列表的类型，用于存储可变参数信息。va_start 宏用于初始化 valst，使其指向参数列表中的第一个可变参数。第一个参数是 valst，第二个参数是可变参数列表的最后一个已知的固定参数。vsnprintf 是一个可变参数版本的 snprintf 函数，用于将格式化的数据写入字符串。这里，它将可变参数根据指定的 format 格式化并写入 m_buf 字符数组中，起始位置是 m_buf + n，最大写入长度是 m_log_buf_size - 1。使用 vsnprintf 将可变参数格式化成字符串，追加到之前的时间戳后。\n\n添加换行符和异步&#x2F;同步写入：\nm_buf[n + m] = &#x27;\\n&#x27;;m_buf[n + m + 1] = &#x27;\\0&#x27;;if(m_is_async &amp;&amp; !m_log_duque-&gt;full())&#123;    m_log_duque-&gt;push_back(m_buf);&#125;else&#123;    fputs(m_buf,m_fp);&#125;\n\n在字符串末尾添加换行符，并根据异步标志和队列是否满，选择是异步写入到阻塞队列还是同步写入到文件。最后，解锁临界区。\n\n\n这段代码完成了日志的记录、切割和写入功能，支持同步和异步两种写入模式。\n强制刷新文件缓冲 flush// 强制刷新文件缓冲void Log::flush(void)&#123;    m_mutex.lock();  // 加锁，确保在多线程环境中对文件缓冲的操作是互斥的    fflush(m_fp);    // 刷新文件缓冲，将缓冲区中的数据写入文件    m_mutex.unlock();  // 解锁，释放互斥锁，允许其他线程对文件缓冲进行操作&#125;\n\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"从零实现WebServer之线程同步机制包装类","url":"/2023/12/28/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0WebServer%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%8C%85%E8%A3%85%E7%B1%BB/","content":"从零实现WebServer之线程同步机制包装类信号量封装类初始化信号量\nint sem_init(sem_t *sem, int pshared, unsigned int value);\n  sem 信号量对象\n  pshared 不为0信号量在进程间共享，否则在当前进程的所有线程共享\n  value 信号量值大小\n  成功返回0，失败返回-1并设置errno\n原子操作V\nint sem_wait(sem_t *sem);\n  信号量不为0则-1，为0则阻塞\n  成功返回0，失败返回-1并设置errno\n原子操作P\nint sem_post(sem_t *sem);\n  信号量+1\n  成功返回0，失败返回-1并设置errno\n销毁信号量\nint sem_destroy(sem_t *sem);\n  成功返回0，失败返回-1并设置errno\n\n\n\n\nclass semaphore&#123;public:    // semaphore() 是默认构造函数，用于创建一个初始值为 0 的信号量    semaphore()&#123;        if(sem_init(&amp;m_sem,0,0) != 0)&#123;            throw std::exception();        &#125;    &#125;    // semaphore(int num) 是带参数的构造函数，用于创建一个初始值为 num 的信号量。    semaphore(int num)&#123;        if(sem_init(&amp;m_sem,0,num) != 0)&#123;            throw std::exception();        &#125;    &#125;    // 析构函数负责释放信号量占用的资源，调用 sem_destroy 函数    ~semaphore()&#123;        sem_destroy(&amp;m_sem);    &#125;    // 内部调用了 sem_wait 函数，该函数会使当前线程阻塞，直到信号量的值大于等于 1，然后将信号量的值减少    bool wait()&#123;        return sem_wait(&amp;m_sem) == 0;    &#125;    // 内部调用了 sem_post 函数，该函数将信号量的值增加    bool post()&#123;        return sem_post(&amp;m_sem)  == 0;    &#125;    private:    sem_t m_sem;&#125;;\n\n这段代码定义了一个名为semaphore的类，它实现了一个信号量（Semaphore）。信号量是一种用于多线程或多进程之间同步的机制，它可以用来控制对共享资源的访问。\n\n构造函数 semaphore() 和 semaphore(int num)：\nsemaphore() 是默认构造函数，用于创建一个初始值为 0 的信号量。\nsemaphore(int num) 是带参数的构造函数，用于创建一个初始值为 num 的信号量。\n在两个构造函数中，都调用了 sem_init 函数来初始化信号量。如果初始化失败（sem_init 返回非零值），则抛出 std::exception 异常。\n\n\n析构函数 ~semaphore()：\n析构函数负责释放信号量占用的资源，调用 sem_destroy 函数。\n\n\n成员函数 bool wait()：\nwait 函数用于等待信号量的值变为大于等于 1。如果调用成功，它返回 true；否则，返回 false。\n内部调用了 sem_wait 函数，该函数会使当前线程阻塞，直到信号量的值大于等于 1，然后将信号量的值减少。\nsem_wait 的作用是使调用线程阻塞，直到信号量的值大于等于 1。当信号量的值大于等于 1 时，sem_wait 将信号量的值减一，并立即返回。如果信号量的值已经是 0，那么 sem_wait 将阻塞调用线程，直到有其他线程调用了 sem_post 增加了信号量的值。\n\n\n成员函数 bool post()：\npost 函数用于增加信号量的值，表示资源可用。如果调用成功，它返回 true；否则，返回 false。\n内部调用了 sem_post 函数，该函数将信号量的值增加。\n\n\n私有成员 sem_t m_sem：\nm_sem 是一个 sem_t 类型的信号量变量，用于存储信号量的状态信息。\n\n\n\n这个类的目的是提供一个简单的接口，允许线程之间进行同步，通过 wait 和 post 函数来控制对共享资源的访问。使用信号量的一个常见场景是确保在多线程环境中对临界区（critical section）的互斥访问。\n互斥锁封装类初始化互斥锁\nint pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);\n  mutex 互斥锁对象\n  attr 互斥锁属性，默认普通锁\n  value信号量值大小\n  成功返回0\n加锁\nint pthread_mutex_lock (pthread_mutex_t *mutex);\n  请求锁线程形成等待序列，解锁后按优先级获得锁\n  成功返回0\n解锁\nint pthread_mutex_unlock (pthread_mutex_t *mutex);\n  成功返回0\n销毁互斥锁\nint pthread_mutex_destroy (pthread_mutex_t *mutex);\n  成功返回0\n\n\nclass mutexlocker&#123;public:    // 构造函数负责初始化互斥锁，使用 pthread_mutex_init 函数    mutexlocker()&#123;        if(pthread_mutex_init(&amp;m_mutex,NULL) != 0)&#123;            throw std::exception();        &#125;    &#125;    ~mutexlocker()&#123;        pthread_mutex_destroy(&amp;m_mutex);    &#125;    bool lock()&#123;        return pthread_mutex_lock(&amp;m_mutex) == 0;    &#125;    bool unlock()&#123;        return pthread_mutex_unlock(&amp;m_mutex) == 0;    &#125;    // get 函数返回指向互斥锁的指针，允许用户直接操作互斥锁    pthread_mutex_t* get()&#123;        return &amp;m_mutex;    &#125;private:    pthread_mutex_t m_mutex;&#125;;\n\n这段代码定义了一个名为 mutexlocker 的类，用于实现互斥锁（Mutex）。互斥锁是一种用于多线程之间同步的机制，它确保同时只有一个线程可以访问被保护的资源。\n\n构造函数 mutexlocker()：\n构造函数负责初始化互斥锁，使用 pthread_mutex_init 函数。\n如果初始化失败，即 pthread_mutex_init 返回非零值，那么抛出 std::exception 异常。\n\n\n析构函数 ~mutexlocker()：\n析构函数负责销毁互斥锁，使用 pthread_mutex_destroy 函数。\n\n\n成员函数 bool lock()：\nlock 函数用于获取互斥锁。如果调用成功，它返回 true；否则，返回 false。\n内部调用了 pthread_mutex_lock 函数，该函数会阻塞调用线程，直到成功获取互斥锁。\n\n\n成员函数 bool unlock()：\nunlock 函数用于释放互斥锁。如果调用成功，它返回 true；否则，返回 false。\n内部调用了 pthread_mutex_unlock 函数，该函数会释放互斥锁。\n\n\n成员函数 pthread_mutex_t\\* get()：\nget 函数返回指向互斥锁的指针，允许用户直接操作互斥锁。\n\n\n私有成员 pthread_mutex_t m_mutex：\nm_mutex 是一个 pthread_mutex_t 类型的互斥锁变量，用于存储互斥锁的状态信息。\n\n\n\n这个类的目的是提供一个简单的接口，允许线程对临界区进行互斥访问。通过 lock 和 unlock 函数，以及 get 函数，用户可以方便地操作互斥锁，确保在多线程环境中对共享资源的安全访问。在构造函数和析构函数中进行初始化和销毁操作，确保互斥锁的正确使用。\n条件变量封装类初始化条件变量\nint pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);\n  cv 条件变量对象\n  cattr 条件变量属性\n  成功返回0\n等待条件变量成立\nint pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex);\n  调用该函数时，线程总处于某个临界区，持有某个互斥锁\n  释放mutex防止死锁，阻塞等待唤醒，然后再获取mutex\n  成功返回0\n计时等待条件变量成立\nint pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *mutex, struct timespec *abstime);\n  成功返回0，超时返回ETIMEDOUT\n唤醒一个wait的线程\nint pthread_cond_signal(pthread_cond_t *cv);\n  成功返回0\n唤醒所有wait的线程\nint pthread_cond_broadcast(pthread_cond_t *cv);\n  成功返回0\n\n\nclass condvar&#123;public:    condvar()&#123;        if(pthread_cond_init(&amp;m_cond,NULL) != 0)&#123;            throw std::exception();        &#125;    &#125;    ~condvar()&#123;        pthread_cond_destroy(&amp;m_cond);    &#125;    // wait 函数用于将调用线程放入条件变量的请求队列，并解锁与给定互斥锁关联的临界区。    // 线程将被阻塞，直到其他某个线程调用 signal 或 broadcast 来唤醒它    bool wait(pthread_mutex_t *m_mutex)&#123;        return pthread_cond_wait(&amp;m_cond,m_mutex) == 0;    &#125;    // timewait 函数类似于 wait，但是可以设置超时时间，如果超过指定时间条件还未满足，线程将被唤醒    bool timewait(pthread_mutex_t * m_mutex, struct timespec t)&#123;        return pthread_cond_timedwait(&amp;m_cond,&amp;m_mutex,&amp;t) == 0;    &#125;    // signal 函数用于唤醒等待在条件变量上的一个线程。如果有多个线程在等待，只有其中一个会被唤醒    bool signal()&#123;        return pthread_cond_signal(&amp;m_cond) == 0;    &#125;    // broadcast 函数用于唤醒所有等待在条件变量上的线程    bool broadcast()&#123;        return pthread_cond_broadcast(&amp;m_cond) == 0;    &#125;private:    pthread_cond_t m_cond;&#125;;\n\n这段代码定义了一个名为 condvar 的类，用于实现条件变量（Condition Variable）。条件变量是一种线程同步的机制，它允许线程在某个条件成立之前等待，并在条件成立时被唤醒。\n\n构造函数 condvar()：\n构造函数负责初始化条件变量，使用 pthread_cond_init 函数。\n如果初始化失败，即 pthread_cond_init 返回非零值，那么抛出 std::exception 异常。\n\n\n析构函数 ~condvar()：\n析构函数负责销毁条件变量，使用 pthread_cond_destroy 函数。\n\n\n成员函数 bool wait(pthread_mutex_t \\*m_mutex)：\nwait 函数用于将调用线程放入条件变量的请求队列，并解锁与给定互斥锁关联的临界区。线程将被阻塞，直到其他某个线程调用 signal 或 broadcast 来唤醒它。\n返回值为 true 表示成功，false 表示出错。\n\n\n成员函数 bool timewait(pthread_mutex_t \\*m_mutex, struct timespec t)：\ntimewait 函数类似于 wait，但是可以设置超时时间，如果超过指定时间条件还未满足，线程将被唤醒。\n返回值为 true 表示成功，false 表示出错。\n\n\n成员函数 bool signal()：\nsignal 函数用于唤醒等待在条件变量上的一个线程。如果有多个线程在等待，只有其中一个会被唤醒。\n返回值为 true 表示成功，false 表示出错。\n\n\n成员函数 bool broadcast()：\nbroadcast 函数用于唤醒所有等待在条件变量上的线程。\n返回值为 true 表示成功，false 表示出错。\n\n\n私有成员 pthread_cond_t m_cond：\nm_cond 是一个 pthread_cond_t 类型的条件变量变量，用于存储条件变量的状态信息。\n\n\n\n这个类的目的是提供一个简单的接口，允许线程等待某个条件的发生，并在条件满足时被唤醒。通过 wait、timewait、signal 和 broadcast 函数，以及构造函数和析构函数的初始化和销毁操作，用户可以方便地使用条件变量来实现线程之间的同步。\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"使用Qt开发工作上的需求","url":"/2023/10/26/%E4%BD%BF%E7%94%A8Qt%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E4%B8%8A%E7%9A%84%E9%9C%80%E6%B1%82/","content":"记录最近工作设及到一些关于qt编程的相关内容\n\n\n功能1：鼠标点击图片显示坐标和像素最近工作设及到一些关于qt编程的工作，主要内容就是在一个QGraphicsView上显示了一个QGraphicsPixmapItem的相机监控的图片，并用鼠标点击图片显示坐标和像素。\n最初在网上找到的解决方案是重写mousePressEvent()方法\nvoid ImgHelper::mousePressEvent(QGraphicsSceneMouseEvent* event)&#123;    std::cout &lt;&lt; &quot;Item: (&quot; &lt;&lt; event-&gt;scenePos().x() &lt;&lt; &quot;, &quot; &lt;&lt; event-&gt;scenePos().y() &lt;&lt; &#x27;)&#x27; &lt;&lt; std::endl; &#125;\n\n测试发现未响应鼠标事件，网上找到说：重写鼠标点击事件函数时发现鼠标点击事件在子类化后的QGraphicsScene中被响应，但是子类化后的QGraphicsPixmapItem无法响应。QGraphicsView的事件传递机制的顺序是View-&gt;Scene-&gt;Item，也就是说事件被子类化的QGraphicsScene吞没了，没有传递到下一级的item。解决方案，在子类化的QGraphicsScene中重写mousePressEvent()方法内部一定要要记得调用：\nQGraphicsScene::mousePressEvent(event);\n\n注意，要想返回图像坐标系的位置，就需要在子类化的QGraphicsPixmapItem中调用scenePos()函数。即使放大图像，点击图像中相同位置也会返回相同坐标结果。\n结果发现还是没有反应，还有一种说法就是加上下面这句话\n//使能QGraphcisView控件的鼠标跟踪view-&gt;setMouseTracking(true);\n\n最后尝试把mousePressEvent函数在最上层的mainwindow中重写并使能鼠标，有效果，但是坐标并不是我想要的效果，现在的坐标系是整个界面的，我想要的是图像的坐标，然后能通过图像控件的位置和长宽进行筛选，但是获得的图像是经过qt自适应缩放在600X600的容器里的。\n在一筹莫展的时候，突然看到eventFilter事件过滤器。\n\n原本事件应该直接发送给“组件对象”，但是现在却先将事件发送给“过滤器对象”，经过过滤的事件再发给“组件对象”。\n事件过滤器的操作：\n\n首先给需要添加事件过滤器的部件注册监听对象；对象名-&gt;installEventFilter(true);\n重写eventFilter(QObject *obj, QEvent *event)函数进行处理。\n首先使用参数obj进行与绑定的控件对象进行判断，是否与其相等；然后在使用参数event-&gt;type()的返回值与枚举鼠标或者键盘进行判断；最后将event转换为鼠标事件对象或者键盘对象事件，就可以进行操作了。\n\nbool ImgHelper::eventFilter(QObject *watched, QEvent *event)&#123;    //判断信号是不是来自QGraphicsView    if(watched == view-&gt;viewport())&#123;        switch (event-&gt;type()) &#123;        //鼠标移动事件        case  QEvent::MouseMove:        &#123;            QMouseEvent *m_event = (QMouseEvent*)event;            if(pixmapItem == NULL)&#123;                break;            &#125;           // QPoint point = m_event-&gt;pos();            QPixmap pix= pixmapItem-&gt;pixmap();            QImage img = pix.toImage();          //  QSize size = pixmapItem-&gt;pixmap().size();            QPoint point = m_event-&gt;pos();           // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;            // 坐标系转换 - 视图 -&gt; 场景            QPointF scenePoint = view-&gt;mapToScene(point);            //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;            // 坐标系转换 - 场景 -&gt; 图元            QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);           // qDebug()&lt;&lt;&quot;itempoint:&quot;&lt;&lt;itempoint&lt;&lt;endl;            QString str;            // 判断所选点是否在图像范围内            if(itempoint.x()&gt;=0 &amp;&amp;itempoint.x()&lt;=pix.width() &amp;&amp; itempoint.y()&gt;=0 &amp;&amp; itempoint.y()&lt;= pix.height())&#123;                QRgb pixColor = img.pixel(itempoint.x(),itempoint.y());               // qDebug()&lt;&lt;pixColor&lt;&lt;&quot; &quot;&lt;&lt;qRed(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qGreen(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qBlue(pixColor)&lt;&lt;endl;                str = QString(&quot;X:%1\\nY:%2\\nR:%3\\nG:%4\\nB:%5\\n&quot;).arg(QString::number(itempoint.x(),&#x27;f&#x27;,1))                                                                .arg(QString::number(itempoint.y(),&#x27;f&#x27;,1))                                                                .arg(qRed(pixColor))                                                                .arg(qGreen(pixColor))                                                                .arg(qBlue(pixColor)).toLocal8Bit();            &#125;            else&#123;                str = &quot;&quot;;            &#125;            img_xy_pix-&gt;setText(str);            img_xy_pix-&gt;setStyleSheet(&quot;color:red;&quot;);            break;        &#125;        // 鼠标点击事件        case QEvent::MouseButtonPress:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            // 左键点击确定起点            if(m_event-&gt;button() == Qt::LeftButton )&#123;             //   QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                startPoint = itempoint;                break;            &#125;            break;        &#125;        // 送开鼠标，确定终点        case QEvent::MouseButtonRelease:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            if(m_event-&gt;button() == Qt::LeftButton )&#123;//                QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                QPointF endPoint = itempoint;                if(startPoint.x() != 0 &amp;&amp; startPoint.y() != 0)&#123;                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());                    painter.drawRect(rectangle);                    painter.setPen(QPen(Qt::red,1));                    rects = scene-&gt;addRect(rectangle,rectPen);//                    float rectInfo[8];//                    rectcounts++;//                    rectInfo[0] = rectcounts;//                    float x = (endPoint.x()-startPoint.x()) / 2 + startPoint.x();//                    float y = (endPoint.y()-startPoint.y()) / 2 + startPoint.y();//                    float height;//                    float width;//                    if(endPoint.x()-startPoint.x() &gt; endPoint.y()-startPoint.y())&#123;//                       height = endPoint.x()-startPoint.x();//                       width = endPoint.y()-startPoint.y();//                    &#125;else&#123;//                        width = endPoint.x()-startPoint.x();//                        height = endPoint.y()-startPoint.y();//                    &#125;                 //   rectInfo[1] = x;                 //   rectInfo[2] = y;                 //   rectInfo[3] = height;                 //      rectInfo[4] = width;                  //  float angle = -90;                 //   rectInfo[5] = angle;//                    CassUdpHelper* udpClient = new CassUdpHelper(localPort, this);                    //                     bool flag = false;  //                    int rectCountsAddr = 353345520;//                    flag = udpClient-&gt;writeBytesByModbus(rectCountsAddr, (char*)&amp;rectcounts, sizeof(short), hostIpAddr, hostPort);//                    if(!flag) &#123;//                        delete udpClient;//                         break;//                    &#125;//                    int startAddr = 427778712;//                    flag = udpClient-&gt;writeBytesByModbus(startAddr + sizeof(float)*8 *(rectcounts - 1), (char*)rectInfo, sizeof(float)*8, hostIpAddr, hostPort);//                    if(!flag) &#123;//                        delete udpClient;//                         break;//                    &#125;//                    delete udpClient;                                    &#125;                break;            &#125;            break;        &#125;        default:            break;        &#125;    &#125;    return false;&#125;\n\n功能2：Qt拖动鼠标画一个矩形想要画一个矩形就需要过滤鼠标点击事件，鼠标按下时确定矩形的起点，然后拖动一段距离，松开确定终点。\n\n// 鼠标点击事件        case QEvent::MouseButtonPress:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            // 左键点击确定起点            if(m_event-&gt;button() == Qt::LeftButton )&#123;             //   QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                startPoint = itempoint;                break;            &#125;            break;        &#125;        // 送开鼠标，确定终点        case QEvent::MouseButtonRelease:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            if(m_event-&gt;button() == Qt::LeftButton )&#123;//                QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                QPointF endPoint = itempoint;                if(startPoint.x() != 0 &amp;&amp; startPoint.y() != 0)&#123;                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());                    painter.drawRect(rectangle);                    painter.setPen(QPen(Qt::red,1));                    rects = scene-&gt;addRect(rectangle,rectPen);\n\n这是在网上看到其他人重写的一个QGraphicsRectItem类，画出来的矩形可以拖动，变形，旋转，使用时只需要导入这个类\n\nmygraphicrectitem.h\n\n#ifndef MYGRAPHICRECTITEM_H#define MYGRAPHICRECTITEM_H#include &lt;QObject&gt;#include &lt;QWidget&gt;#include &lt;QMouseEvent&gt;#include &lt;QGraphicsScene&gt;#include &lt;QGraphicsRectItem&gt;#include &lt;QGraphicsSceneMouseEvent&gt;#include &lt;QRect&gt;#include &lt;QPainter&gt;#include &lt;QPolygon&gt;#include &lt;QList&gt;enum STATE_FLAG&#123;    DEFAULT_FLAG=0,    MOV_LEFT_LINE,//标记当前为用户按下矩形的左边界区域    MOV_TOP_LINE,//标记当前为用户按下矩形的上边界区域    MOV_RIGHT_LINE,//标记当前为用户按下矩形的右边界区域    MOV_BOTTOM_LINE,//标记当前为用户按下矩形的下边界区域    MOV_RIGHTBOTTOM_RECT,//标记当前为用户按下矩形的右下角    MOV_RECT,//标记当前为鼠标拖动图片移动状态    ROTATE//标记当前为旋转状态&#125;;class myGraphicRectItem:public QObject,public QGraphicsItem&#123;    Q_OBJECTpublic:    myGraphicRectItem(QGraphicsItem *parent = nullptr);    //myGraphicRectItem(QRectF m_OriginRect = QRectF(0,0,100,100));    QRectF  boundingRect() const;    ~myGraphicRectItem();    void setRectSize(QRectF mrect,bool bResetRotateCenter = true);    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);    void mousePressEvent(QGraphicsSceneMouseEvent *event);    void mouseMoveEvent(QGraphicsSceneMouseEvent *event);    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);    void SetRotate(qreal RotateAngle,QPointF ptCenter=QPointF(-999,-999));    QPointF getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle);//获取旋转后的点    QList&lt;QPointF&gt; getRotatePoints(QPointF ptCenter,QList&lt;QPointF&gt; ptIns,qreal angle);//获取多个旋转后的点    QPolygonF getRotatePolygonFromRect(QPointF ptCenter,QRectF rectIn,qreal angle);//将矩形旋转之后返回多边形    QRectF getCrtPosRectToSceen();    QRectF m_SmallRotateRect;//矩形顶部用来表示旋转的标记的矩形    QPolygonF m_SmallRotatePolygon;//矩形顶部用来表示旋转的标记的矩形旋转后形成的多边形    QPointF getSmallRotateRectCenter(QPointF ptA,QPointF ptB);//获取旋转时候矩形正上方的旋转标记矩形    QRectF  getSmallRotateRect(QPointF ptA,QPointF ptB);    bool    m_bRotate;    qreal   m_RotateAngle;    QPointF m_RotateCenter;private:    QRectF  m_oldRect;    QPolygonF m_oldRectPolygon;    QRectF  m_RotateAreaRect;    bool    m_bResize;    QPolygonF m_insicedPolygon;    QRectF  m_insicedRectf;    QPolygonF m_leftPolygon;    QRectF  m_leftRectf;    QPolygonF m_topPolygon;    QRectF  m_topRectf;    QPolygonF m_rightPolygon;    QRectF  m_rightRectf;    QPolygonF m_bottomPolygon;    QRectF  m_bottomRectf;//    QPolygonF m_rbPolygon;//    QRectF  m_rbRectf;    QPointF m_startPos;    STATE_FLAG m_StateFlag;    QPointF *pPointFofSmallRotateRect;protected:&#125;;#endif // MYGRAPHICRECTITEM_H\n\nmygraphicrectitem.cpp\n\n#include &quot;mygraphicrectitem.h&quot;#include &lt;QtMath&gt;#include &lt;QDebug&gt;myGraphicRectItem::myGraphicRectItem(QGraphicsItem *parent):    m_bResize(false),    m_oldRect(0,0,100,100),    m_bRotate(false),    m_RotateAngle(0),    m_StateFlag(DEFAULT_FLAG)&#123;    //setParent(parent);    setRectSize(m_oldRect);    setToolTip(&quot;Click and drag me!&quot;);  //提示    setCursor(Qt::ArrowCursor);   //改变光标形状,手的形状    setFlag(QGraphicsItem::ItemIsMovable);    //    setAcceptDrops(true);    pPointFofSmallRotateRect = new QPointF[4];    SetRotate(0);    setFlag(QGraphicsItem::ItemIsSelectable);//&#125;QRectF myGraphicRectItem::boundingRect() const&#123;    //return m_oldRectPolygon.boundingRect();    QRectF boundingRectF = m_oldRectPolygon.boundingRect();    return QRectF(boundingRectF.x()-40,boundingRectF.y()-40,boundingRectF.width()+80,boundingRectF.height()+80);&#125;myGraphicRectItem::~myGraphicRectItem()&#123;    delete []pPointFofSmallRotateRect;    pPointFofSmallRotateRect = nullptr;&#125;void myGraphicRectItem::setRectSize(QRectF mrect, bool bResetRotateCenter)&#123;    m_oldRect = mrect;    if(bResetRotateCenter)    &#123;        m_RotateCenter.setX(m_oldRect.x()+m_oldRect.width()/2);        m_RotateCenter.setY(m_oldRect.y()+m_oldRect.height()/2);    &#125;    m_oldRectPolygon = getRotatePolygonFromRect(m_RotateCenter,m_oldRect,m_RotateAngle);    m_insicedRectf = QRectF(m_oldRect.x()+8,m_oldRect.y()+8,m_oldRect.width()-16,m_oldRect.height()-16);    m_insicedPolygon =getRotatePolygonFromRect(m_RotateCenter,m_insicedRectf,m_RotateAngle);    m_leftRectf = QRectF(m_oldRect.x(),m_oldRect.y(),8,m_oldRect.height()-8);    m_leftPolygon = getRotatePolygonFromRect(m_RotateCenter,m_leftRectf,m_RotateAngle);    m_topRectf = QRectF(m_oldRect.x()+8,m_oldRect.y(),m_oldRect.width()-8,8);    m_topPolygon = getRotatePolygonFromRect(m_RotateCenter,m_topRectf,m_RotateAngle);    m_rightRectf = QRectF(m_oldRect.right()-8,m_oldRect.y()+8,8,m_oldRect.height()-16);    m_rightPolygon = getRotatePolygonFromRect(m_RotateCenter,m_rightRectf,m_RotateAngle);    m_bottomRectf = QRectF(m_oldRect.x(),m_oldRect.bottom()-8,m_oldRect.width()-8,8);    m_bottomPolygon = getRotatePolygonFromRect(m_RotateCenter,m_bottomRectf,m_RotateAngle);//    m_rbRectf = QRectF(m_oldRect.right()-8,m_oldRect.bottom()-8,8,8);//    m_rbPolygon = getRotatePolygonFromRect(m_RotateCenter,m_rbRectf,m_RotateAngle);    m_SmallRotateRect = getSmallRotateRect(mrect.topLeft(),mrect.topRight());//矩形正上方的旋转标记矩形    m_SmallRotatePolygon = getRotatePolygonFromRect(m_RotateCenter,m_SmallRotateRect,m_RotateAngle);&#125;void myGraphicRectItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123;    QPen mPen = QPen(Qt::yellow);    painter-&gt;setPen(mPen);    //绘制旋转后的矩形    painter-&gt;drawPolygon(m_oldRectPolygon);    //绘制旋转圆形    mPen.setWidth(2);    mPen.setColor(Qt::green);    painter-&gt;setPen(mPen);    QPointF pf = getSmallRotateRectCenter(m_oldRectPolygon[0],m_oldRectPolygon[1]);    QRectF rect = QRectF(pf.x()-10,pf.y()-10,20,20);    painter-&gt;drawEllipse(rect);//绘制圆形    painter-&gt;drawPoint(pf);//绘制点&#125;void myGraphicRectItem::mousePressEvent(QGraphicsSceneMouseEvent *event)&#123;    if(event-&gt;button()== Qt::LeftButton)    &#123;        m_startPos = event-&gt;pos();//鼠标左击时，获取当前鼠标在图片中的坐标，        if(m_SmallRotatePolygon.containsPoint(m_startPos,Qt::WindingFill))//旋转矩形        &#123;            setCursor(Qt::PointingHandCursor);            m_StateFlag = ROTATE;        &#125;        else if(m_insicedPolygon.containsPoint(m_startPos,Qt::WindingFill))//在矩形内框区域时按下鼠标，则可拖动图片        &#123;            setCursor(Qt::ClosedHandCursor);   //改变光标形状,手的形状            m_StateFlag = MOV_RECT;//标记当前为鼠标拖动图片移动状态        &#125;        else if(m_leftPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeHorCursor);            m_StateFlag = MOV_LEFT_LINE;//标记当前为用户按下矩形的左边界区域        &#125;        else if(m_rightPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeHorCursor);            m_StateFlag = MOV_RIGHT_LINE;//标记当前为用户按下矩形的右边界区域        &#125;        else if(m_topPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeVerCursor);            m_StateFlag = MOV_TOP_LINE;//标记当前为用户按下矩形的上边界区域        &#125;        else if(m_bottomPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeVerCursor);            m_StateFlag = MOV_BOTTOM_LINE;//标记当前为用户按下矩形的下边界区域        &#125;//        else if(m_rbPolygon.containsPoint(m_startPos,Qt::WindingFill))//        &#123;//            setCursor(Qt::SizeFDiagCursor);//            m_StateFlag = MOV_RIGHTBOTTOM_RECT;//标记当前为用户按下矩形的右下角//        &#125;        else        &#123;            m_StateFlag = DEFAULT_FLAG;        &#125;    &#125;    else    &#123;        QGraphicsItem::mousePressEvent(event);    &#125;&#125;void myGraphicRectItem::mouseMoveEvent(QGraphicsSceneMouseEvent *event)&#123;    if(m_StateFlag == ROTATE)    &#123;       int nRotateAngle = atan2((event-&gt;pos().x()-m_RotateCenter.x()),(event-&gt;pos().y()-m_RotateCenter.y()))*180/M_PI;       SetRotate(180-nRotateAngle);       setRectSize(m_oldRect);       //qDebug()&lt;&lt;nRotateAngle;    &#125;    else if(m_StateFlag == MOV_RECT)    &#123;        QPointF point = (event-&gt;pos() - m_startPos);        moveBy(point.x(), point.y());        setRectSize(m_oldRect);        scene()-&gt;update();    &#125;    else if(m_StateFlag == MOV_LEFT_LINE)    &#123;        QPointF pf = QPointF((m_oldRectPolygon.at(1).x()+m_oldRectPolygon.at(2).x())/2,((m_oldRectPolygon.at(1).y()+m_oldRectPolygon.at(2).y())/2));        //计算到右侧边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2RT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));        if(dis&lt;16||dis2LT&gt;dis2RT)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setLeft(m_oldRect.right()-dis);            newRect.setRight(m_oldRect.right());            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;    else if(m_StateFlag == MOV_TOP_LINE)    &#123;        //底边中点        QPointF pf = QPointF((m_oldRectPolygon.at(2).x()+m_oldRectPolygon.at(3).x())/2,((m_oldRectPolygon.at(2).y()+m_oldRectPolygon.at(3).y())/2));        //计算到底边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2LB = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));        if(dis&lt;16||dis2LT&gt;dis2LB)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setTop(m_oldRect.bottom()-dis);            newRect.setBottom(m_oldRect.bottom());            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;    else if(m_StateFlag == MOV_RIGHT_LINE)    &#123;        QPointF pf = QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(3).x())/2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(3).y())/2));        //计算到左侧边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2RT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));        if(dis&lt;16||dis2LT&lt;dis2RT)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setLeft(m_oldRect.left());            newRect.setRight(m_oldRect.left()+dis);            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;    else if(m_StateFlag == MOV_BOTTOM_LINE)    &#123;        //顶边中点        QPointF pf = QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(1).x())/2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(1).y())/2));        //计算到底边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2LB = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));        if(dis&lt;16||dis2LT&lt;dis2LB)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setTop(m_oldRect.top());            newRect.setBottom(m_oldRect.top()+dis);            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;&#125;void myGraphicRectItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)&#123;    setCursor(Qt::ArrowCursor);    if(m_StateFlag == MOV_RECT)    &#123;        m_StateFlag = DEFAULT_FLAG;    &#125;    else &#123;        QGraphicsItem::mouseReleaseEvent(event);    &#125;&#125;void myGraphicRectItem::SetRotate(qreal RotateAngle, QPointF ptCenter)&#123;    m_bRotate = true;    if(ptCenter.x()==-999 &amp;&amp; ptCenter.y()==-999)    &#123;        m_RotateCenter = QPointF(m_oldRect.x()+m_oldRect.width()/2,m_oldRect.y()+m_oldRect.height()/2);    &#125;    else    &#123;        m_RotateCenter = ptCenter;    &#125;    m_RotateAngle = RotateAngle;    this-&gt;update();&#125;QPointF myGraphicRectItem::getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle)&#123;    double dx = ptCenter.x();    double dy = ptCenter.y();    double x = ptIn.x();    double y = ptIn.y();    double xx,yy;    xx = (x-dx)*cos(angle*M_PI/180)-(y-dy)*sin(angle*M_PI/180)+dx;    yy = (x-dx)*sin(angle*M_PI/180)+(y-dy)*cos(angle*M_PI/180)+dy;    return QPointF(xx,yy);&#125;QList&lt;QPointF&gt; myGraphicRectItem::getRotatePoints(QPointF ptCenter, QList&lt;QPointF&gt; ptIns, qreal angle)&#123;    QList&lt;QPointF&gt; lstPt;    for(int i = 0;i&lt;ptIns.count();i++)    &#123;        lstPt.append(getRotatePoint(ptCenter,ptIns.at(i),angle));    &#125;    return lstPt;&#125;QPolygonF myGraphicRectItem::getRotatePolygonFromRect(QPointF ptCenter, QRectF rectIn, qreal angle)&#123;    QVector&lt;QPointF&gt; vpt;    QPointF pf = getRotatePoint(ptCenter,rectIn.topLeft(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.topRight(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.bottomRight(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.bottomLeft(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.topLeft(),angle);    vpt.append(pf);    return QPolygonF(vpt);&#125;QRectF myGraphicRectItem::getCrtPosRectToSceen()&#123;    QRectF retRect = QRectF(m_oldRect.x()+pos().x(),m_oldRect.y()+pos().y(),m_oldRect.width(),m_oldRect.height());    return retRect;&#125;QRectF myGraphicRectItem::getSmallRotateRect(QPointF ptA,QPointF ptB)&#123;    QPointF pt = getSmallRotateRectCenter(ptA,ptB);    return QRectF(pt.x()-10,pt.y()-10,20,20);&#125;QPointF myGraphicRectItem::getSmallRotateRectCenter(QPointF ptA,QPointF ptB)&#123;    QPointF ptCenter = QPointF((ptA.x()+ptB.x())/2,(ptA.y()+ptB.y())/2);//A,B点的中点C    //中垂线方程式为 y=x*k + b;    qreal x,y;//旋转图标矩形的中心    if(abs(ptB.y()-ptA.y())&lt;0.1)    &#123;        if(ptA.x()&lt;ptB.x())//矩形左上角在上方        &#123;            x = ptCenter.x();            y = ptCenter.y()-20;        &#125;        else//矩形左上角在下方        &#123;            x = ptCenter.x();            y = ptCenter.y()+20;        &#125;    &#125;    else if(ptB.y()&gt;ptA.y())//顺时针旋转0-180    &#123;        qreal k = (ptA.x()-ptB.x())/(ptB.y()-ptA.y());//中垂线斜率        qreal b = (ptA.y()+ptB.y())/2-k*(ptA.x()+ptB.x())/2;        //求AB线中垂线上离AB中点20个像素的点C的坐标        x = 20*cos(atan(k))+ptCenter.x();        y = k*x+b;    &#125;    else if(ptB.y()&lt;ptA.y())//顺时针旋转180-360    &#123;        qreal k = (ptA.x()-ptB.x())/(ptB.y()-ptA.y());//中垂线斜率        qreal b = (ptA.y()+ptB.y())/2-k*(ptA.x()+ptB.x())/2;        //求AB线中垂线上离AB中点20个像素的点C的坐标        x = -20*cos(atan(k))+ptCenter.x();        y = k*x+b;    &#125;    return QPointF(x,y);&#125;\n\n功能3：Qt中设置QGraphicsView的背景色为透明且无边框\n设置背景色为透明：在QGraphicsView上调用setStyleSheet()方法，并将背景色样式设置为透明。示例代码如下：\n\nQGraphicsView* view = new QGraphicsView;view-&gt;setStyleSheet(&quot;background-color: transparent;&quot;);\n\n\n设置边框：在QGraphicsView上调用setFrameStyle()方法，并将边框样式设置为无边框。示例代码如下：\n\nQGraphicsView* view = new QGraphicsView;view-&gt;setFrameStyle(QFrame::NoFrame);\n\n在Qt中使用一个按钮清除QGraphicsView上监控的图片QGraphicsPixmapItem上画出来不需要的矩形QGraphicsRectItem\n\n首先，在QGraphicsView上绑定一个按钮QPushButton\nQPushButton* clearBtn = new QPushButton(view);# 将按钮放置在view的左下角btn.setGeometry(0,view.geometry().height()-40,40,20);btn.setText(&quot;clear&quot;);\n\n给按钮绑定槽函数，用于清除矩形\n#在.h文件中定义槽函数private slots:\tvoid on_btn_clicked();\n\n# 在构造函数中绑定槽函数connect(clearBtn,SIGNAL(clicked()),this,SLOT(on_btn_clicked()));\n\n# 槽函数的具体实现void ImgHelper::on_btn_clicked()&#123;\trectcounts = 0;\t#设矩形个数为0\tscene-&gt;clear();\t# 清空scene\timgUpdated(cloneImage);\t# 将直接保存的监控图片重新添加进scene&#125;\n\n功能4：保存错误图片当发现监控的图片有问题时，就可以一键保存监控的图片，按日期创建文件夹，方便查看问题\nvoid ImgHelper::onSaveErrorImage()&#123;    //20230908    QString currentPath = QDir::currentPath();    QString filedir = currentPath + QDir::separator() + &quot;errorImg&quot;;    QDir dir(filedir);    if(!dir.exists())&#123;       if(dir.mkdir(filedir))&#123;       &#125;else&#123;           qDebug()&lt;&lt;&quot;创建目录失败&quot;;       &#125;    &#125;    QString nowDate = QDateTime::QDateTime::currentDateTime().toString(&quot;yyyy-MM-dd&quot;) ;    QString filedirdate = filedir + QDir::separator() + nowDate;    QDir dirdate(filedirdate);    if(!dirdate.exists())&#123;       if(dirdate.mkdir(filedirdate))&#123;       &#125;else&#123;           qDebug()&lt;&lt;&quot;创建目录失败&quot;;       &#125;    &#125;    for(int i = 1; i &lt;= 8; i++)&#123;        QString imgpath = filedirdate + QDir::separator() + &quot;tt&quot; + QString::number(i) +&quot;.bmp&quot;;        QFile file(imgpath);        //判断文件是否存在        if(file.exists())&#123;           continue;        &#125;        if(pixmapItem != NULL)&#123;            pixmapItem-&gt;pixmap().save(imgpath);        &#125;        break;    &#125;&#125;\n\n功能5：修复图片通道异常//2023926加  修复PLC查看图片出现的通道异常        for(int x = 0 ; x &lt; image.height(); x++)&#123;                    for(int y = 0 ; y &lt; image.width(); y++)&#123;                        QRgb pixel = image.pixel(x,y);                        int red = qBlue(pixel);                        int green =qRed(pixel);                        int blue = qGreen(pixel);                        QRgb newpixel = qRgb(red,green,blue);                        image.setPixel(x,y,newpixel);                    &#125;                &#125;\n\n\n\n","categories":["笔记"],"tags":["c++","Qt"]},{"title":"从零实现WebServer之数据库连接池类","url":"/2023/12/29/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0WebServer%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%B1%BB/","content":"从零实现WebServer之数据库连接池类数据库连接池类流程图\n\n获取实例 get_instance // 单例模式static connection_pool* get_instance()&#123;    static connection_pool connPool;    return &amp;connPool;&#125;\n\n这是一个典型的单例模式实现，通过在静态成员函数 get_instance 中创建 static 局部变量 connPool，确保了在程序的生命周期内只有一个实例被创建。这种方式被称为懒汉式单例模式，因为实例在第一次调用 get_instance 时被创建。 在 C++11 及以上标准中，对于静态局部变量的初始化是线程安全的，因此这种实现在多线程环境下是安全的。在早期的 C++ 标准中，可能需要考虑额外的线程安全性措施。当程序结束时，connPool 对象将在全局静态存储区自动销毁，确保了释放资源。\n构造函数 connection_poolconnection_pool::connection_pool()&#123;    m_cur_conn = 0;    m_free_conn = 0;&#125;\n\n在构造函数 connection_pool::connection_pool() 中，初始化了 m_cur_conn 和 m_free_conn 两个成员变量。这样的初始化是很常见的，通常用于确保在对象创建时，这些成员变量处于一个已知的初始状态。\n\nm_cur_conn 用于记录当前已经使用的数据库连接数。\nm_free_conn 用于记录当前空闲的数据库连接数。\n\n通过将它们初始化为零，确保了在对象创建时，这两个计数器的初始值为零。接下来，在程序运行时，通过 get_connection 获取连接时，m_cur_conn 会递增，而在 release_connection 释放连接时，m_cur_conn 会递减，同时 m_free_conn 也会相应地增加或减少。这样的设计方案有助于在连接池中管理数据库连接的数量，以及追踪当前连接的使用情况。\n析构函数 ~connection_poolconnection_pool::~connection_pool()&#123;    list&lt;MYSQL*&gt;::iterator iter;    for(iter = conn_list.begin(); iter != conn_list.end(); ++iter)&#123;        MYSQL * conn = *iter;        mysql_close(conn);    &#125;&#125;\n\n在 connection_pool 类的析构函数 connection_pool::~connection_pool() 中，对连接池中的 MySQL 连接进行了关闭。\n具体地说，它遍历了 conn_list 列表，关闭了每个 MySQL 连接。这是一个良好的实践，因为在对象销毁时，应该释放所有的资源，包括打开的数据库连接。通过在析构函数中完成这个工作，确保了在对象生命周期结束时，相关资源能够被正确释放，从而避免了潜在的资源泄漏问题。\n需要注意的是，MySQL 连接的关闭不仅仅是释放连接对象本身，还包括释放底层的资源，确保在数据库连接不再需要时，相关资源能够被正确释放。\n初始化连接池 init// 初始化连接池void connection_pool::init(string url, string user, string password, string database_name, int port, int max_conn, int close_log)&#123;    m_url = url;    m_port = port;    m_user = user;    m_password = password;    m_database_name = database_name;    m_close_log = close_log;    // 构造连接    for(int i = 0; i &lt; max_conn; ++i)&#123;        // 初始化一个mysql连接的实例对象，MYSQL* mysql_init(MYSQL *mysql);        MYSQL *conn = nullptr;        conn = mysql_init(conn);        if(conn == nullptr)&#123;            LOG_ERROR(&quot;MySQL init Error&quot;);            exit(1);        &#125;        // 与数据库引擎建立连接        conn = mysql_real_connect(conn,url.c_str(),user.c_str(),password.c_str(),database_name.c_str(),port,nullptr,0);        if(conn == nullptr)&#123;            LOG_ERROR(&quot;MySQL real connect Error&quot;);            exit(1);        &#125;        // 添加到连接链表        conn_list.push_back(conn);        ++m_free_conn;    &#125;    // 创建信号量    reserve = semaphore(m_free_conn);    m_max_conn = m_free_conn;&#125;\n\n在 connection_pool 类的初始化函数 connection_pool::init 中，进行了数据库连接池的初始化工作。下面是对该函数的一些主要步骤的解释：\n\n初始化成员变量： 将函数参数中传递的各种连接信息（如主机地址、用户名、密码等）赋值给类的成员变量。\nm_url = url;m_port = port;m_user = user;m_password = password;m_database_name = database_name;m_close_log = close_log;\n\n构造连接： 使用 mysql_init 函数初始化一个 MySQL 连接的实例对象。\nMYSQL *conn = nullptr;conn = mysql_init(conn);\n\n如果初始化失败，记录错误日志并退出程序。\n\n建立与数据库引擎的连接： 使用 mysql_real_connect 函数与数据库引擎建立连接。\nconn = mysql_real_connect(conn, url.c_str(), user.c_str(), password.c_str(), database_name.c_str(), port, nullptr, 0);\n\n如果连接失败，记录错误日志并退出程序。\n\n添加到连接链表： 将成功建立连接的 MySQL 对象添加到连接链表中，并增加空闲连接数。\nconn_list.push_back(conn);++m_free_conn;\n\n创建信号量： 使用 semaphore 类创建一个信号量对象 reserve，初始值为空闲连接数。\nreserve = semaphore(m_free_conn);\n\n设置最大连接数： 将当前的空闲连接数作为最大连接数。\nm_max_conn = m_free_conn;\n\n该函数的目标是初始化数据库连接池，包括创建连接、建立与数据库引擎的连接、管理连接链表和信号量等。这是一个典型的连接池初始化流程。\n获取可用连接 get_connection// 有请求时，从数据库连接池返回一个可用连接MYSQL* connection_pool::get_connection()&#123;    // 无空闲连接    if(conn_list.size() == 0)&#123;        return nullptr;    &#125;    MYSQL *conn = nullptr;    // 等待空闲连接    reserve.wait();    // 加互斥锁    lock.lock();    // 取连接池第一个连接    conn = conn_list.front();    conn_list.pop_front();    --m_free_conn;    ++m_cur_conn;    lock.unlock();    return conn;&#125;\n\nconnection_pool::get_connection 函数用于在有请求时从数据库连接池返回一个可用连接。下面是对该函数的主要步骤解释：\n\n检查连接池是否有空闲连接： 如果连接池中没有空闲连接（conn_list.size() == 0），则返回 nullptr 表示没有可用连接。\nif(conn_list.size() == 0)&#123;    return nullptr;&#125;\n\n等待空闲连接： 调用信号量的 wait 函数等待有可用连接为止。\nreserve.wait();\n\n这里使用了信号量 reserve 来表示有多少个可用连接。如果 reserve 的值为零，表示没有可用连接，该函数将会被阻塞。\n\n获取连接： 在获取连接之前，使用互斥锁保护临界区，以确保线程安全。从连接链表的头部获取一个连接，并从链表中移除。\nlock.lock();conn = conn_list.front();conn_list.pop_front();\n\n更新连接计数： 减少空闲连接数，增加当前已使用连接数。\n--m_free_conn;++m_cur_conn;lock.unlock();\n\n返回连接： 返回获取到的连接。\nreturn conn;\n\n该函数在有请求时从连接池中获取一个可用连接，确保线程安全地管理连接池状态。\n在 connection_pool::init 函数中，初始化的过程是在单线程环境下进行的，因此不需要加锁。在初始化过程中，不会有其他线程同时尝试修改连接池的状态，因此不存在竞争条件。\n而在 connection_pool::get_connection 函数中，涉及到获取连接、更新连接池状态等操作，这些操作在多线程环境下可能会被多个线程同时调用。所有需要使用互斥锁进行保护。\n\n\n释放连接 release_connection// 释放当前使用的连接，成功返回truebool connection_pool::release_connection(MYSQL *conn)&#123;    if(conn == nullptr)&#123;        return false;    &#125;    lock.lock();    conn_list.push_back(conn);    ++m_free_conn;    --m_cur_conn;    lock.unlock();    reserve.post();    return true;&#125;\n\n在 connection_pool::release_connection 函数中，通过互斥锁 lock 对连接池的状态进行了修改，确保在多线程环境下对连接池的操作是互斥的。这是因为在释放连接的过程中，会涉及到对连接池中的连接列表、空闲连接数、当前使用连接数等状态的修改，而这些修改是不可分割的操作。\n以下是函数中的主要操作：\n\n加锁： 使用互斥锁 lock.lock()，将当前线程锁住，防止其他线程同时修改连接池状态。\n连接释放： 将当前使用的连接 conn 放回连接池的连接列表 conn_list 中，同时更新空闲连接数 m_free_conn 和当前使用连接数 m_cur_conn。\n解锁： 使用互斥锁 lock.unlock()，释放锁，允许其他线程访问连接池。\n信号量增加： 调用 reserve.post()，将信号量的计数增加，表示有一个空闲连接可用。\n\n这样设计确保了在多线程环境下对连接池状态的修改是线程安全的。如果不使用互斥锁进行保护，可能会导致多个线程同时修改连接池状态而出现问题。\n当前空闲连接数 get_freeconn// 当前空闲连接数int connection_pool::get_freeconn()&#123;    return this-&gt;m_free_conn;&#125;\n\n资源获取即初始化connectionRAII 类是一个简单的资源获取即初始化（RAII）类。在构造函数中获取资源（数据库连接），在析构函数中释放这些资源。这个类的主要目的是通过构造函数获得资源（数据库连接），并在对象销毁时通过析构函数释放这些资源。使用这个类可以确保在任何情况下都能正确地释放数据库连接，避免资源泄漏。这是 C++ 中一种常见的资源管理方式，称为 RAII 设计模式。\n\n\n获取连接 connectionRAII// 从连接池获取一个数据库连接connectionRAII::connectionRAII(MYSQL **conn, connection_pool *connPool)&#123;    *conn = connPool-&gt;get_connection();    connRAII = *conn;    poolRAII = connPool;&#125;\n\nconnectionRAII 类的构造函数是一个资源获取即初始化的操作，通过该构造函数可以获取一个数据库连接并初始化 connRAII 和 poolRAII 成员变量。\n具体步骤如下：\n\n获取连接： 调用 connPool-&gt;get_connection() 从数据库连接池中获取一个连接，并将连接指针赋值给 *conn，这是通过传入的参数来返回连接的。\n初始化成员变量： 将获取的连接赋值给 connRAII，表示当前对象拥有该数据库连接。\n保存连接池指针： 将传入的 connPool 赋值给 poolRAII，表示当前对象持有该连接所属的连接池的指针。\n\n这样，在 connectionRAII 对象构造时，就完成了数据库连接的获取，并且通过 connRAII 持有了这个连接，同时也保存了连接所属的连接池的指针。这符合资源获取即初始化的 RAII 设计思想。\n释放连接 ~connectionRAII// 释放持有的数据库连接connectionRAII::~connectionRAII()&#123;    poolRAII-&gt;release_connection(connRAII);&#125;\n\nconnectionRAII 类的析构函数实现了资源的释放操作。在析构函数中，它调用了 poolRAII-&gt;release_connection(connRAII) 来释放持有的数据库连接。\n释放连接： 调用 poolRAII-&gt;release_connection(connRAII)，将持有的数据库连接 connRAII 释放回连接池。这个操作会使连接池的空闲连接数量增加，同时当前对象持有的连接数量减少。\n通过这样的设计，当 connectionRAII 对象生命周期结束时（例如，超出了其作用域），它会自动释放持有的数据库连接，确保连接得到有效的回收和重用。这符合 RAII 设计模式，简化了资源管理的代码。\n以下部分参考：C++多线程连接池MySQL (foryouos.cn)\n\nC++ 封装 MySQL API构造函数 (MySqlConnect::MySqlConnect)：MySqlConnect::MySqlConnect() &#123;    m_conn = mysql_init(nullptr);    mysql_set_character_set(m_conn, &quot;utf8&quot;);&#125;\n\n\n功能： 初始化m_conn，即MySQL连接对象。\n详解：\n使用mysql_init初始化MySQL连接对象。\n通过mysql_set_character_set设置字符集为”utf8”，以支持UTF-8编码。\n\n\n\n析构函数 (MySqlConnect::~MySqlConnect)：MySqlConnect::~MySqlConnect() &#123;    if (m_conn != nullptr) &#123;        mysql_close(m_conn);    &#125;    freeResult();&#125;\n\n\n功能： 关闭MySQL连接，释放相关资源。\n详解：\n使用mysql_close关闭MySQL连接。\n调用freeResult释放执行查询时产生的结果集。\n\n\n\n释放结果集 (MySqlConnect::freeResult)：void MySqlConnect::freeResult() &#123;    if (m_result) &#123;        mysql_free_result(m_result);        m_result = nullptr;    &#125;&#125;\n\n\n功能： 释放结果集占用的内存。\n详解：\n使用mysql_free_result释放结果集占用的内存。\n将m_result置为nullptr，确保不再指向已释放的内存。\n\n\n\n连接数据库 (MySqlConnect::connect)：bool MySqlConnect::connect(string user, string passwd, string dbName, string ip, unsigned short port) &#123;    MYSQL* ptr = mysql_real_connect(m_conn, ip.c_str(), user.c_str(), passwd.c_str(), dbName.c_str(), port, nullptr, 0);    return ptr != nullptr;&#125;\n\n\n功能： 连接到MySQL数据库。\n详解：\n使用mysql_real_connect进行实际的数据库连接。\n返回连接是否成功的布尔值。\n\n\n\n执行更新操作 (MySqlConnect::update)：bool MySqlConnect::update(string sql) &#123;    if (mysql_query(m_conn, sql.c_str())) &#123;        return false;    &#125;    return true;&#125;\n\n\n功能： 执行更新操作（插入、更新、删除等）的SQL语句。\n详解：\n使用mysql_query执行SQL语句。\n返回执行是否成功的布尔值。\n\n\n\n执行查询操作 (MySqlConnect::query)：bool MySqlConnect::query(string sql) &#123;    freeResult();    if (mysql_query(m_conn, sql.c_str())) &#123;        return false;    &#125;    m_result = mysql_store_result(m_conn);    return true;&#125;\n\n\n功能： 执行查询操作的SQL语句。\n详解：\n在执行查询之前通过freeResult释放之前的结果集。\n使用mysql_query执行SQL语句。\n使用mysql_store_result将查询结果存储在m_result中。\n返回执行是否成功的布尔值。\n\n\n\n遍历查询结果 (MySqlConnect::next)：bool MySqlConnect::next() &#123;    if (m_result != nullptr) &#123;        m_row = mysql_fetch_row(m_result);        return true;    &#125;    return false;&#125;\n\n\n功能： 移动到结果集中的下一行。\n详解：\n使用mysql_fetch_row获取结果集中的下一行数据。\n返回是否成功移动到下一行的布尔值。\n\n\n\n获取结果集中的字段值 (MySqlConnect::value)：string MySqlConnect::value(int index) &#123;    int row_num = mysql_num_fields(m_result);    if (index &gt;= row_num || index &lt; 0) &#123;        return string();    &#125;    char* val = m_row[index];    unsigned long length = mysql_fetch_lengths(m_result)[index];    return string(val, length);&#125;\n\n\n功能： 获取当前行中指定列的值。\n详解：\n使用mysql_num_fields获取结果集中的列数。\n如果指定的列索引超出范围，返回空字符串。\n使用mysql_fetch_lengths获取列的长度。\n返回当前行中指定列的字符串值。\n\n\n\n事务操作 (MySqlConnect::transaction, MySqlConnect::commit, MySqlConnect::rollback)：bool MySqlConnect::transaction() &#123;    return mysql_autocommit(m_conn, false);&#125;bool MySqlConnect::commit() &#123;    return mysql_commit(m_conn);&#125;bool MySqlConnect::rollback() &#123;    return mysql_rollback(m_conn);&#125;\n\n\n功能： 执行事务操作（开启事务、提交、回滚）。\n详解：\ntransaction方法用于开启事务，关闭自动提交。\ncommit方法用于提交事务。\nrollback方法用于回滚事务。\n返回执行是否成功的布尔值。\n\n\n\nMySQLConnect.h#pragma once#ifndef MYSQLCONNECT_H#define MYSQLCONNECT_H#include &lt;iostream&gt;#include &lt;mysql.h&gt;using namespace std;class MySqlConnect&#123;private:\t// 什么时候调用释放结果集\t//1, 析构函数 2，可能会对数据库进行多次查询，每次查询一次都会得到结果集，查询是清空掉上次的结果集\tvoid freeResult(); // 释放结果集\tMYSQL* m_conn = nullptr; // 保存 MySQL 初始化的私有成员\tMYSQL_RES* m_result = nullptr; // 报错结果集\tMYSQL_ROW m_row = nullptr; // 保存着当前字段的所有列的数值public:\t// 初始化数据库连接\tMySqlConnect();\t// 释放数据库连接\t~MySqlConnect();\t// 连接数据库，使用默认端口可省略端口书写\tbool connect(string user, string passwd,string dbName,string ip,unsigned short port = 3306 );\t// 更新数据库 (插入，更新，删除)，传递字符串\tbool update(string sql);\t// 查询数据库，单词 query: 查询\tbool query(string sql);\t// 遍历查询得到的结果集，每调一次，从结果集中取出一条数据\tbool next(); \t// 得到结果集中的字段值，取记录里面字段方法\tstring value(int index); \t// 事务操作，关闭自动提交\tbool transaction();\t// 提交事务\tbool commit();\t// 事务回滚；\tbool rollback();&#125;;#endif // !MYSQLCONNECT_H\n\nMySQLConnect.cpp#include &quot;MySQLConnect.h&quot;void MySqlConnect::freeResult()&#123;\tif (m_result)\t&#123;\t\tmysql_free_result(m_result);\t\tm_result = nullptr;\t&#125;&#125;MySqlConnect::MySqlConnect()&#123;\tm_conn = mysql_init(nullptr);\tmysql_set_character_set(m_conn, &quot;utf8&quot;);&#125;MySqlConnect::~MySqlConnect()&#123;\tif (m_conn != nullptr)\t&#123;\t\tmysql_close(m_conn);\t&#125;\tfreeResult();&#125;bool MySqlConnect::connect(string user, string passwd, string dbName, string ip, unsigned short port)&#123;\t//ip 传入为 string，使用.str 将 ip 转为 char * 类型\tMYSQL* ptr = mysql_real_connect(m_conn, ip.c_str(), user.c_str(), passwd.c_str(), dbName.c_str(), port, nullptr, 0);\t// 连接成功返回 true\t// 如果连接成功返回 TRUE，失败返回 FALSE\treturn ptr!=nullptr;&#125;bool MySqlConnect::update(string sql)&#123;\t//query 执行成功返回 0\tif (mysql_query(m_conn, sql.c_str()))\t&#123;\t\treturn false;\t&#125;;\treturn true;&#125;boolMySqlConnect::query(string sql)&#123;\tfreeResult();\t//query 执行成功返回 0\tif (mysql_query(m_conn, sql.c_str()))\t&#123;\t\treturn false;\t&#125;;\tm_result = mysql_store_result(m_conn);\treturn true;&#125;bool MySqlConnect::next()&#123;\t// 如果结果集为空则没有必要遍历\tif (m_result != nullptr)\t&#123;\t\t// 保存着当前字段的所有列的数值\t\tm_row = mysql_fetch_row(m_result);\t\treturn true;\t&#125;\treturn false;&#125;string MySqlConnect::value(int index)&#123; \t// 表示列的数量\tint row_num = mysql_num_fields(m_result); // 函数得到结果集中的列数\t// 如果查询的的 index 列大于总列，或小于 0，是错误的\tif (index &gt;= row_num || index &lt; 0)\t&#123;\t\treturn string();\t&#125;\tchar* val = m_row[index]; // 若为二进制数据，中间是有 &quot;\\0&quot; 的\tunsigned long length = mysql_fetch_lengths(m_result)[index];\treturn string(val,length); // 传入 length 就不会以 &quot;\\0&quot; 为结束符，而是通过长度把对应的字符转换为 string 类型&#125;bool MySqlConnect::transaction()&#123;\treturn mysql_autocommit(m_conn,false); // 函数返回值本身就是 bool 类型&#125;bool MySqlConnect::commit()&#123;\treturn mysql_commit(m_conn);// 提交&#125;bool MySqlConnect::rollback()&#123;\treturn mysql_rollback(m_conn);//bool 类型，函数成功返回 TRUE，失败返回 FALSE&#125;\n\n数据库连接池：包含封装MySQL API构造函数 (ConnectionPool::ConnectionPool)：ConnectionPool::ConnectionPool() &#123;    if (!parseJsonFile()) &#123;        cout &lt;&lt; &quot;数据库连接失败&quot; &lt;&lt; endl;        return;    &#125;    for (int i = 0; i &lt; m_minSize; ++i) &#123;        if (m_connectionQ.size() &lt; m_maxSize) &#123;            MySqlConnect* conn = new MySqlConnect;            conn-&gt;connect(m_user, m_passwd, m_dbName, m_ip, m_port);            m_connectionQ.push(conn);        &#125; else &#123;            cout &lt;&lt; &quot;当前连接数量已超过允许的最大连接数&quot; &lt;&lt; endl;            break;        &#125;    &#125;    thread producer(&amp;ConnectionPool::produceConnection, this);    thread recycler(&amp;ConnectionPool::recycleConnection, this);    producer.detach();    recycler.detach();&#125;\n\n\n功能： 构造函数，初始化连接池。\n详解：\n调用parseJsonFile加载配置信息。\n初始化连接池中的连接，保证达到最小连接数。\n创建两个线程，一个用于生成新连接(produceConnection)，一个用于回收连接(recycleConnection)。\n将生成连接线程和回收连接线程分离。\n\n\n\n析构函数 (ConnectionPool::~ConnectionPool)：ConnectionPool::~ConnectionPool() &#123;    while (!m_connectionQ.empty()) &#123;        MySqlConnect* conn = m_connectionQ.front();        m_connectionQ.pop();        delete conn;    &#125;&#125;\n\n\n功能： 析构函数，释放连接池中的连接。\n详解：\n循环弹出连接队列中的连接，并释放内存。\n\n\n\n解析JSON文件 (ConnectionPool::parseJsonFile)：bool ConnectionPool::parseJsonFile() &#123;    try &#123;        ifstream ifs(&quot;dbconf.json&quot;);        Reader rd;        Value root;        rd.parse(ifs, root);        if (root.isObject()) &#123;            m_ip = root[&quot;ip&quot;].asString();            m_port = root[&quot;port&quot;].asInt();            m_user = root[&quot;userName&quot;].asString();            m_passwd = root[&quot;password&quot;].asString();            m_dbName = root[&quot;dbName&quot;].asString();            m_minSize = root[&quot;minSize&quot;].asInt();            m_maxSize = root[&quot;maxSize&quot;].asInt();            m_maxIdleTime = root[&quot;maxIdleTime&quot;].asInt();            m_timeout = root[&quot;timeout&quot;].asInt();            return true;        &#125;        throw(&quot;读取连接数据库json失败！&quot;);        return false;    &#125; catch (exception&amp; e) &#123;        cout &lt;&lt; e.what() &lt;&lt; endl;        return false;    &#125;&#125;\n\n\n功能： 解析JSON配置文件。\n详解：\n打开dbconf.json文件，使用Reader解析JSON。\n从JSON中提取数据库连接的相关信息。\n\n\n\n生产连接 (ConnectionPool::produceConnection)：void ConnectionPool::produceConnection() &#123;    while (true) &#123;        unique_lock&lt;mutex&gt; locker(m_mutexQ);        while (m_connectionQ.size() &gt;= m_minSize) &#123;            m_cond.wait(locker);        &#125;        addConnection();        m_cond.notify_all();    &#125;&#125;\n\n\n功能： 生成新的数据库连接。\n详解：\n在连接池连接数不足时，生成新的数据库连接。\n使用addConnection添加连接到连接池。\n唤醒等待的消费者。\n\n\n\n回收连接 (ConnectionPool::recycleConnection)：void ConnectionPool::recycleConnection() &#123;    while (true) &#123;        this_thread::sleep_for(chrono::milliseconds(500));        lock_guard&lt;mutex&gt; locker(m_mutexQ);        while (m_connectionQ.size() &gt; m_minSize) &#123;            MySqlConnect* conn = m_connectionQ.front();            if (conn-&gt;getAliveTime() &gt;= m_maxIdleTime) &#123;                m_connectionQ.pop();                delete conn;            &#125; else &#123;                break;            &#125;        &#125;    &#125;&#125;\n\n\n功能： 回收空闲连接。\n详解：\n每隔一定时间检查连接池中的连接，将超过最大空闲时间的连接释放。\n通过sleep_for休息一段时间。\n\n\n\n添加连接 (ConnectionPool::addConnection)：void ConnectionPool::addConnection() &#123;    MySqlConnect* conn = new MySqlConnect;    conn-&gt;connect(m_user, m_passwd, m_dbName, m_ip, m_port);    conn-&gt;refreshAliveTime();    m_connectionQ.push(conn);&#125;\n\n\n功能： 添加新连接到连接池。\n详解：\n创建新的MySqlConnect对象，连接数据库。\n刷新连接的起始空闲时间。\n将连接添加到连接池队列中。\n\n\n\n获取连接 (ConnectionPool::getConnection)：shared_ptr&lt;MySqlConnect&gt; ConnectionPool::getConnection() &#123;    unique_lock&lt;mutex&gt; locker(m_mutexQ);    while (m_connectionQ.empty()) &#123;        if (cv_status::timeout == m_cond.wait_for(locker, chrono::milliseconds(m_timeout))) &#123;            if (m_connectionQ.empty()) &#123;                continue;            &#125;        &#125;    &#125;    shared_ptr&lt;MySqlConnect&gt; connptr(m_connectionQ.front(), [this](MySqlConnect* conn) &#123;        lock_guard&lt;mutex&gt; locker(m_mutexQ);        conn-&gt;refreshAliveTime();        m_connectionQ.push(conn);    &#125;);    m_connectionQ.pop();    m_cond.notify_all();    return connptr;&#125;\n\n\n功能： 获取数据库连接。\n详解：\n使用unique_lock上锁，保证线程安全。\n当连接池为空时，等待可用连接或超时。\n获取连接并返回其shared_ptr，使用lambda表达式在连接释放时刷新连接的起始空闲时间。\n唤醒等待的生产者线程。\n\n\n\nConnectionPool.h#pragma once// 连接池头文件#ifndef CONNECTIONPOOL_H#define CONNECTIONPOOL_H#include&lt;queue&gt;#include &quot;MySQLConnect.h&quot;#include &lt;mutex&gt; //C++ 独占的互斥锁#include &lt;condition_variable&gt; // 引用 C++ 条件变量using namespace std;// 连接池class ConnectionPool&#123;public:\t// 静态实例，通过静态方法获得唯一的单例对象\tstatic ConnectionPool* getConnectPool();\t// 删除掉构造函数\tConnectionPool(const ConnectionPool&amp; obj) = delete;\t// 移动赋值函数重载，删除掉，防止对象的复制\tConnectionPool&amp; operator =(const ConnectionPool&amp; obj)= delete;\t// 获取连接时返回一个可用的连接，返回共享的智能指针\tshared_ptr&lt;MySqlConnect&gt; getConnection();\t// 析构函数\t~ConnectionPool();private:\tConnectionPool();\t// 解析 JSON 文件的函数\tbool paraseJsonFile();\t// 用来生产数据库连接\tvoid produceConnection();\t\t// 用来销毁数据库连接 回收数据库连接\tvoid recycleConnection();\t// 添加连接\tvoid addConnection();\t// 数据库相关信息\t// 通过加载配置文件 Json，访问用户指定的数据库\t// 数据库 ip\tstring m_ip; \t// 数据库用户\tstring m_user;\t// 数据库密码\tstring m_passwd;\t// 数据库名称\tstring m_dbName;\t// 数据库访问端口\tunsigned short m_port;\t// 设置连接上限\tint m_minSize;\t// 设置连接的上限\tint m_maxSize;\t// 设置线程等待最大时长，单位毫秒\t// 超时时长\tint m_timeout; \t// 最大空闲时长单位毫秒\tint m_maxIdleTime;\t// 存储若干数据库连接队列\tqueue&lt;MySqlConnect*&gt; m_connectionQ;\t// 设置互斥锁\tmutex m_mutexQ;\t// 设置条件变量\tcondition_variable m_cond;&#125;;#endif // !CONNECTIONPOOL_H\n\nConnectionPool.cpp#include &quot;ConnectionPool.h&quot;#include &lt;json/json.h&gt;#include &lt;fstream&gt;#include &lt;mysql.h&gt;#include &lt;thread&gt; // 加载多线程using namespace Json;// 静态函数ConnectionPool* ConnectionPool::getConnectPool()&#123;    static ConnectionPool pool; // 静态局部对象，不管后面调用多少次，得到的都是同一块内存地址    return &amp;pool;&#125;// 打开数据库信息文件，并判断是否读取到相关信息bool ConnectionPool::paraseJsonFile()&#123;    try    &#123;        ifstream ifs(&quot;dbconf.json&quot;);        Reader rd;        Value root;        rd.parse(ifs, root);        if (root.isObject())        &#123;            m_ip = root[&quot;ip&quot;].asString();            m_port = root[&quot;port&quot;].asInt();            m_user = root[&quot;userName&quot;].asString();            m_passwd = root[&quot;password&quot;].asString();            m_dbName = root[&quot;dbName&quot;].asString();            m_minSize = root[&quot;minSize&quot;].asInt();            m_maxSize = root[&quot;maxSize&quot;].asInt();            m_maxIdleTime = root[&quot;maxIdlTime&quot;].asInt();            m_timeout = root[&quot;timeout&quot;].asInt();            return true;        &#125;        throw(&quot;读取连接数据库json失败！&quot;);        return false;    &#125;    catch (exception&amp; e)    &#123;        cout &lt;&lt; e.what() &lt;&lt; endl;    &#125;        &#125;// 子线程对应的任务函数，生成新的可用连接void ConnectionPool::produceConnection()&#123;    //    while (true)     &#123;        // 判断当前连接池是否够用        //uniuqe 模版类，mutex 互斥锁类型 locker 对象管理        unique_lock&lt;mutex&gt; locker(m_mutexQ);        while (m_connectionQ.size() &gt;= m_minSize)        &#123;            // 阻塞条件变量            m_cond.wait(locker);        &#125;        // 生产一个数据库连接        addConnection();        // 调用对应的唤醒函数，唤醒的所有消费者        m_cond.notify_all();    &#125;&#125;// 当空闲的链接数量过多void ConnectionPool::recycleConnection()&#123;    while (true)    &#123;        // 休息一段时间，每隔一秒种，进行一次检测        this_thread::sleep_for(chrono::milliseconds(500));        // 进行加锁        lock_guard&lt;mutex&gt;locker(m_mutexQ);        // 当大于最小连接数        while (m_connectionQ.size() &gt; m_minSize)        &#123;            // 先进后出            MySqlConnect* conn = m_connectionQ.front(); // 取出队头元素            // 判断队头元素存活时长是不是大于指定的最长存活时长            if (conn-&gt;getAliveTime() &gt;= m_maxIdleTime)            &#123;                m_connectionQ.pop(); // 将队头的链接销毁                delete conn;            &#125;            else            &#123;                break;            &#125;        &#125;    &#125;&#125;void ConnectionPool::addConnection()&#123;    MySqlConnect* conn = new MySqlConnect;    conn-&gt;connect(m_user, m_passwd, m_dbName, m_ip, m_port);    // 数据库连接之后就开始记录时间错    conn-&gt;refreshAliveTime();    m_connectionQ.push(conn);&#125;shared_ptr&lt;MySqlConnect&gt; ConnectionPool::getConnection()&#123;    // 封装互斥锁，保证线程安全    unique_lock&lt;mutex&gt; locker(m_mutexQ);    // 检查是否有可用的连接，如果没有阻塞一会    while (m_connectionQ.empty())    &#123;        if (cv_status::timeout == m_cond.wait_for(locker, chrono::milliseconds(m_timeout)))         &#123;            if (m_connectionQ.empty())            &#123;                continue;            &#125;        &#125;    &#125;    shared_ptr&lt;MySqlConnect&gt; connptr(m_connectionQ.front(), [this](MySqlConnect* conn)         &#123;            // 加锁            lock_guard&lt;mutex&gt; locker(m_mutexQ);           // 刷新起始空闲时间            conn-&gt;refreshAliveTime();               m_connectionQ.push(conn);        &#125;);    m_connectionQ.pop();    m_cond.notify_all();// 唤醒生产者    return connptr;&#125;// 线程池析构函数ConnectionPool::~ConnectionPool()&#123;    while (m_connectionQ.empty())    &#123;        MySqlConnect* conn = m_connectionQ.front();        m_connectionQ.pop();        delete conn;    &#125;&#125;// 构造函数的实现ConnectionPool::ConnectionPool()&#123;    // 加载配置文件    if (!paraseJsonFile())    &#123;        cout &lt;&lt; &quot;数据库连接失败&quot; &lt;&lt; endl;        return;    &#125;    // 初始化配置连接数    for (int i = 0; i &lt; m_minSize; ++i)  // 连接数    &#123;         // 如果队列总数小于最大数量        if (m_connectionQ.size() &lt; m_maxSize)        &#123;            // 实例化对象            MySqlConnect* conn = new MySqlConnect;            // 链接数据库            conn-&gt;connect(m_user, m_passwd, m_dbName, m_ip, m_port);            m_connectionQ.push(conn);        &#125;        // 当连接总数大于允许连接的最大数量        else        &#123;            cout &lt;&lt; &quot;当前连接数量以超过允许连接的总数&quot; &lt;&lt; endl;            break;        &#125;    &#125;    // 当前实例对象 this 指针，单例模式，    thread producer(&amp;ConnectionPool::produceConnection,this); // 生成线程池的连接    thread recycler(&amp;ConnectionPool::recycleConnection,this); // 有没有需要销毁的连接    /*    将 producer 线程与当前线程分离，使得它们可以独立执行，    */    // 主线程和子线程分离    producer.detach();    recycler.detach();&#125;\n\n","categories":["笔记"],"tags":["c++","WebServer"]},{"title":"信号量和互斥锁有什么区别","url":"/2023/11/23/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","content":"信号量和互斥锁有什么区别信号量用于线程的同步，互斥锁用于线程的互斥。\n信号量值可以为非负整数，互斥锁值只能为0&#x2F;1。\n信号量可以由一个线程释放，另一个线程得到，互斥锁的加锁和解锁必须由同一线程分别对应使用。\n信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这个资源。\n","categories":["每日一题"],"tags":["c++"]},{"title":"关键字static的使用","url":"/2023/12/20/%E5%85%B3%E9%94%AE%E5%AD%97static%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"关键字static的使用\n静态变量：在函数内部声明的静态变量具有静态生存期，即它们在整个程序执行期间都存在，并且只会初始化一次。例如：\n\nvoid foo() &#123;    static int count = 0; // 静态局部变量    count++;    cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; endl;&#125;\n\n\n静态成员变量：静态成员变量属于类本身而不是类的实例，并且在所有类对象之间共享。例如：\n\nclass MyClass &#123;public:    static int sharedVariable; // 静态成员变量声明&#125;;int MyClass::sharedVariable = 10; // 静态成员变量定义int main() &#123;    cout &lt;&lt; MyClass::sharedVariable &lt;&lt; endl; // 访问静态成员变量    return 0;&#125;\n\n\n静态成员函数：静态成员函数属于类本身而不是类的实例，可以直接通过类名来调用，而不需要创建对象实例。例如：\n\nclass MyClass &#123;public:    static void myStaticFunction() &#123;         cout &lt;&lt; &quot;This is a static member function.&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    MyClass::myStaticFunction(); // 调用静态成员函数    return 0;&#125;\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"内存对齐","url":"/2023/11/16/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/","content":"内存对齐什么是内存对齐内存对齐是指在分配内存时，数据存储在内存中的起始地址是按照一定的规则对齐的。\n假设现在CPU是按照每4个字节来访问内存，有地址0、和地址1，现在要存1个char变量（假设char变量占1字节）和1个int变量（假设int变量占4字节），那么可以有内存对齐和内存不对齐的存储方式，如下图：\n\n假如不采用内存对齐的方式存储数据，那么CPU需要访问地址0和地址1，再进行合并，才能得到最终的结果；采用内存对齐的方式进行存储数据的话，则只需访问地址1就可以得到最终的结果。因此，采用内存对齐的存储方式可以减少CPU的访问运行时间，缺点是没有充分利用存储空间。\n对齐规则数据是根据初始化的顺序存储的，先定义的先储存，存储地址需要是sizeof(数据变量)的整数倍。\n例如，假设sizeof(char) = 1，sizeof(int) = 4，sizeof(int) = 4，sizeof(double) = 8。结构的对齐规则是要先确定对齐字节数（对齐字节数&#x3D;结构体中的变量占用空间最大的那个字节数，下面的结构体t3、t4就是sizeof(double) = 8），然后再保证存储地址是sizeof(数据变量)的整数倍。\n#include &lt;iostream&gt;using namespace std;struct t1&#123;    char a;    short c;    int x;    char b;&#125;;struct t2&#123;    int x;    char b;    char c;    short a;&#125;;struct t3&#123;    short a;    double c;    int x;    char b;&#125;;struct t4&#123;    char a, b;    int x;    double c;&#125;;int main()&#123;        cout &lt;&lt; sizeof(t1) &lt;&lt; endl; //12    cout &lt;&lt; sizeof(t2) &lt;&lt; endl; //8    cout &lt;&lt; sizeof(t3) &lt;&lt; endl; //24    cout &lt;&lt; sizeof(t4) &lt;&lt; endl; //16    return 0;&#125;\n\n\n在C&#x2F;C++中，内存对齐是由编译器负责的。编译器会按照平台的要求为数据进行对齐，通常会将数据按照其自身大小对齐到特定字节的倍数。这个特定字节的倍数通常由平台决定，例如，在32位系统中可能是4字节，而在64位系统中可能是8字节。\nC&#x2F;C++中可以使用一些特殊的关键字或编译器指令来控制内存对齐，例如：alignas关键字：C++11引入了alignas关键字，用于指定对齐方式。\nalignas(16) struct MyStruct &#123;    // 结构体成员&#125;;\n\n作用\n提高访问速度：许多计算机体系结构要求数据按照特定的边界地址存储，而不是任意地址。当数据被按照这些边界对齐时，处理器能够更快地访问这些数据，提高数据存取速度。\n硬件要求：一些硬件平台对于特定类型的数据要求按照一定的对齐方式存储，不遵循这个规则可能导致硬件异常或性能下降。\n减少浪费：内存对齐可以减少内存碎片，提高内存利用率。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"内存泄漏的定义，如何检测与避免","url":"/2023/11/25/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D/","content":"内存泄漏的定义，如何检测与避免定义：内存泄漏简单的说就是申请了一块内存空间，使用完毕后没有释放掉。 它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。\n如何检测内存泄漏\n\n首先可以通过观察猜测是否可能发生内存泄漏，Linux 中使用swap 命令观察还有多少可用的交换空间，在一两分钟内键入该命令三到四次，看看可用的交换区是否在减少。\n还可以使用 其他一些 /usr/bin/stat 工具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，一个可能的解释就是有个进程出现了内存泄漏。\n当然也有用于内存调试，内存泄漏检测以及性能分析的软件开发工具 valgrind 这样的工具来进行内存泄漏的检测。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"单例模式","url":"/2023/11/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"单例模式最简单也是被问到最多的设计模式之一，保证一个类只创建一个实例，同时提供全局访问的方法。\n\n懒汉模式在使用这个实例对象时才去创建，创建对象时加锁保证有且仅有一个（有线程安全问题）\n实现方式\n\n静态局部变量\n\n互斥锁\n\n使用C++11新特性call_once\n\n\n经典的线程安全例子class single&#123;private:    //私有静态指针变量指向唯一实例    static single *p;    //静态锁，是由于静态函数只能访问静态成员    static pthread_mutex_t lock;    //私有化构造函数    single()&#123;        pthread_mutex_init(&amp;lock, NULL);    &#125;    ~single()&#123;&#125;public:    //公有静态方法获取实例    static single* getinstance();&#125;;pthread_mutex_t single::lock;single* single::p = NULL;single* single::getinstance()&#123;    if (NULL == p)&#123;        pthread_mutex_lock(&amp;lock);        if (NULL == p)&#123;            p = new single;        &#125;        pthread_mutex_unlock(&amp;lock);    &#125;    return p;&#125;\n\n为什么要用双检测，只检测一次不行吗？\n如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL &#x3D;&#x3D; p的情况，直接返回已创建好的实例。\n局部静态变量之线程安全懒汉模式class single&#123;private:    single()&#123;&#125;    ~single()&#123;&#125;public:    static single* getinstance();&#125;;single* single::getinstance()&#123;    static single obj;    return &amp;obj;&#125;\n\n这种方法不加锁会不会造成线程安全问题？\nC++0X以后，要求编译器保证内部静态变量的线程安全性。\n饿汉模式不管是否使用这个实例对象，只要类被创建出来，实例对象就被创建（无线程安全问题）\n饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。\nclass single&#123;private:    static single* p;    single()&#123;&#125;    ~single()&#123;&#125;public:    static single* getinstance();&#125;;single* single::p = new single();single* single::getinstance()&#123;    return p;&#125;//测试方法int main()&#123;    single *p1 = single::getinstance();    single *p2 = single::getinstance();    if (p1 == p2)        cout &lt;&lt; &quot;same&quot; &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;\n\n饿汉模式存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。\n","categories":["笔记"],"tags":["c++","设计模式"]},{"title":"基于epoll的web服务器(C语言版本)","url":"/2023/10/28/%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8-C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/","content":"记录学习使用epoll实现web服务器\n\n\n基于epoll的web服务器(C语言版本)1. 初始化监听套接字包括创建监听套接字，设置端口复用，绑定，设置监听等步骤\n1.1 创建监听套接字（socket函数）socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。\n#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);domain:\tAF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址\tAF_INET6 与上面类似，不过是来用IPv6的地址\tAF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用type:\tSOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。\tSOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。\tSOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。\tSOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）\tSOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序protocol:\t传0 表示使用默认协议。返回值：\t成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno\n\n\n\n1.2 设置端口复用（setsockopt函数）在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是listenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。\n在server代码的socket()和bind()调用之间插入如下代码：\nint opt = 1;setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));\n\n1.3 绑定（bind函数）服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。\n#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockfd：\tsocket文件描述符addr:\t构造出IP地址加端口号addrlen:\tsizeof(addr)长度返回值：\t成功返回0，失败返回-1, 设置errno\n\nbind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如：\nstruct sockaddr_in addr;bzero(&amp;addr, sizeof(addr));servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\t//INADDR_ANY = 0servaddr.sin_port = htons(8888);\n\n首先将整个结构体清零，然后设置地址类型为AF_INET，网络地址为INADDR_ANY**，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为8888。\n1.4 设置监听 （listen函数）#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);sockfd:\tsocket文件描述符backlog:\t排队建立3次握手队列和刚刚建立3次握手队列的链接数和(现在只表示建立链接队列的数量)\n\n查看系统默认backlog\ncat /proc/sys/net/ipv4/tcp_max_syn_backlog\n\n典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。\n1.5 初始化监听套接字（initListenFd函数）// 初始化监听套接字int initListenFd(port)&#123;    // 1. 创建监听套接字    int lfd = socket(AF_INET,SOCK_STREAM,0);    if(lfd == -1)&#123;        perror(&quot;socket error&quot;);        return -1;    &#125;    // 2. 设置端口复用    int opt = 1;    int ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt));    if(ret == -1)&#123;        perror(&quot;setsockopt error&quot;);        return -1;    &#125;    // 3. 绑定    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = 0;    int ret = bind(lfd,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ret == -1)&#123;        perror(&quot;bind error&quot;);        return -1;    &#125;    // 4.设置监听    ret = listen(lfd,128);    if(ret == -1)&#123;        perror(&quot;listen error&quot;);        return -1;    &#125;    // 5. 返回fd    return lfd;&#125;\n\n\n\n2. 启动epollepoll是Linux下IO多路复用接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。\nepoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。\n2.1 创建epoll树  (epoll_create) 创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。(参数size已经弃用，只需提供大于0的数字就行)\n#include &lt;sys/epoll.h&gt;int epoll_create(int size)\t\tsize：监听数目（内核参考值）返回值：成功：非负文件描述符；失败：-1，设置相应的errno\n\n可以使用cat命令查看一个进程可以打开的socket描述符上限。\ncat /proc/sys/fs/file-max806425\n\n如有需要，可以通过修改配置文件的方式修改该上限值。\nsudo vi /etc/security/limits.conf在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。* soft nofile 65536* hard nofile 100000\n\n\n2.2 上树（epoll_ctl函数）控制某个epoll监控的文件描述符上的事件：注册、修改、删除。\n#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)    epfd：\t为epoll_creat的句柄    op：\t\t表示动作，用3个宏来表示：    EPOLL_CTL_ADD (注册新的fd到epfd)，    EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，    EPOLL_CTL_DEL (从epfd删除一个fd)；    event：\t告诉内核需要监听的事件struct epoll_event &#123;    __uint32_t events; /* Epoll events */    epoll_data_t data; /* User data variable */&#125;;typedef union epoll_data &#123;    void *ptr;    int fd;    uint32_t u32;    uint64_t u64;&#125; epoll_data_t;EPOLLIN ：\t表示对应的文件描述符可以读（包括对端SOCKET正常关闭）EPOLLOUT：\t表示对应的文件描述符可以写EPOLLPRI：\t表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）EPOLLERR：\t表示对应的文件描述符发生错误EPOLLHUP：\t表示对应的文件描述符被挂断；EPOLLET： \t将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里返回值：成功：0；失败：-1，设置相应的errno\n\n2.3 检测（epoll_wait函数）等待所监控文件描述符上有事件的产生，类似于select()调用。\n#include &lt;sys/epoll.h&gt;\tint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)    events：\t\t用来存内核得到事件的集合，可简单看作数组。    maxevents：\t告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，    timeout：\t是超时时间    -1：\t阻塞    0：\t立即返回，非阻塞    &gt;0：\t指定毫秒    返回值：\t成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1\n\n2.4 启动epoll(epollrun函数)//启动epollvoid epollrun(int lfd)&#123;    // 1. 创建epoll树    int epfd = epoll_create(1);    if(epfd == -1)&#123;        perror(&quot;epoll_create error&quot;);        return -1;    &#125;    // 2. lfd上树    struct epoll_event ev;    ev.data.fd = lfd;    ev.events = EPOLLIN;    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    // 3. 检测(委托内核检测添加到树上的节点)    struct epoll_event evs[1024];    int size = siezof(evs) / sizeof(struct epoll_event);    while(1)&#123;        int num = epoll_wait(epfd,evs,size,-1);        if(num == -1) &#123;            perror(&quot;epoll_wait error&quot;);            return -1;        &#125;        // 遍历发生变化的节点        for(int i = 0; i &lt; num; ++i)&#123;            if(!(evs[i].events &amp; EPOLLIN)) &#123;                // 不是读事件                continue;            &#125;            int fd = evs[i].data.fd;            if(fd == lfd)&#123;                // 建立新连接 accept                acceptClient(lfd,epfd);            &#125;else&#123;                // 主要是接受对端的数据(读数据)                recvHttpRequest(fd,epfd);            &#125;        &#125;    &#125;&#125;\n\n3. 建立连接3.1 建立连接 （accept函数）三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。\n#include &lt;sys/types.h&gt; \t\t/* See NOTES */#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);sockdf:\tsocket文件描述符addr:\t传出参数，返回链接客户端地址信息，含IP地址和端口号addrlen:\t传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小返回值：\t成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno\n\n我们的服务器程序结构是这样的：\nwhile (1) &#123;\tcliaddr_len = sizeof(cliaddr);\tconnfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);\tn = read(connfd, buf, MAXLINE);\t......\tclose(connfd);&#125;\n\n整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。\n3.2 epoll事件模型EPOLL事件有两种模型：\n\nEdge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。\n\nLevel Triggered (LT) 水平触发只要有数据都会触发。\n\n\n思考如下步骤：1.\t假定我们已经把一个用来从管道中读取数据的文件描述符(rfd)添加到epoll描述符。2.\t管道的另一端写入了2KB的数据3.\t调用epoll_wait，并且它会返回rfd，说明它已经准备好读取操作4.\t读取1KB的数据5.\t调用epoll_wait……\n\nET模式 即Edge Triggered工作模式（边沿触发）\n如果我们在第1步将rfd添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。\n\n基于非阻塞文件句柄\n\n只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。\n\n\nLT模式即Level Triggered工作模式(水平触发)\n与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。\n比较\nLT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。**传统的select/poll**都是这种模型的代表。\nET(edge-triggered)：**ET是高速工作方式，只支持no-block socket**。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知**(only once)**.\n3.3 阻塞与非阻塞\n非阻塞模式可以理解为，执行此套接字的网络调用时，不管是否执行成功，都会立即返回。\n\n​\t\t如调用recv( )函数读取网络缓冲区中的数据时，不管是否读到数据都立即返回，而不会一直挂在此函数的调用上。\n\n阻塞模式为只有接收到数据后才会返回，套接字默认的会创建堵塞模式。\n\n3.4 建立连接（accpetClient函数）int accpetClient(int lfd,int epfd)&#123;    // 1. 建立连接    struct sockaddr_in cliaddr;    socklen_t len = sizeof(cliaddr);    cliaddr.sin_family = AF_INET;    int cfd = accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len);    if(cfd == -1)&#123;        perror(&quot;accept error&quot;);        return -1;    &#125;    char ip[16]=&quot;&quot;;    printf(&quot;new client ip=%s port=%d\\n&quot;,    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));        // 2. 设置非阻塞    int flag = fcntl(cfd,F_GETFL);    flag |= O_NONBLOCK;    fcntl(cfd,F_SETFL,flag);    // 3. cfd添加到epoll    struct epoll_event ev;    ev.data.fd = cfd;    ev.events = EPOLLIN | EPOLLET;      //边沿模式    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    return 0;&#125;\n\n\n\n4. 接收客户端发来的http请求4.1 接收数据 （recv函数）接收来自socket缓冲区的数据，当缓冲区没有数据可取时，recv会一直处于阻塞状态()，直到缓冲区至少又一个字节数据可读取，或者对端关闭，并读取所有数据后返回。\n#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;int recv(int sockfd, char * buf, int len, int flags);sockfd：连接的fdbuf：用于接收数据的缓冲区len：缓冲区长度flags：指定调用方式返回值：成功返回实际读到的字节数。如果recv在copy时出错，那么它返回err，err小于0；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。\n\nread\nread函数从文件描述符（包括TCP Socket）中读取数据，并将读取的数据存储到指定的缓冲区中。\nssize_t read(int fd, void *buf, size_t count);fd：要读取数据的文件描述符，可以是TCP Socket。buf：存储读取数据的缓冲区。count：要读取的字节数。返回值：成功时返回实际读取的字节数，失败时返回-1，并设置errno变量来指示错误的原因。\n\nread函数和recv函数都是阻塞调用，即在没有数据可读时会一直阻塞等待。它们的主要区别在于recv函数可以通过flags参数控制一些特殊的行为，如设置MSG_PEEK标志来预览数据而不将其从缓冲区中移除。\n4.2 EAGAIN错误以O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read或者recv操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。\n（epoll的ET模式下设置recv，对应的fd文件描述符设置为非阻塞）下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。\n\n4.3 接受http请求（recvHttpRequest函数）int recvHttpRequest(int cfd,int epfd)&#123;    char buf[4096] = &#123; 0 &#125;;    char tmp[1024] = &#123; 0 &#125;;    int len = 0;    int total = 0;    // 1. 接收数据    while((len = recv(cfd,tmp,sizeof(tmp),0)) &gt; 0)&#123;        if(total + len &lt; sizeof(buf))&#123;            memcpy(buf + total,tmp,len);        &#125;        total += len;    &#125;    // 2. 判断数据是否接受完毕    if(len == -1 &amp;&amp; errno == EAGAIN)&#123;        // 解析请求行           /*        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19        G E T   / 1 . t x t H  T  T  P  /  1  .  1  /r /n        */        char* pt = strstr(buf,&quot;\\r\\n&quot;);  //大字符串找小字符串        int reqLen = pt - buf;        buf[reqLen] = &#x27;\\0&#x27;;    &#125;    else if(len == 0)&#123;        // 客户端断开连接        epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);    &#125;    else&#123;        perror(&quot;recv error&quot;);    &#125;    return 0;&#125;\n\n5. 解析请求行5.1 格式化拆分字符串 （sscanf函数）sprintf（）是把格式化数据输出成（存储到）字符串。sscanf（）是从字符串中读取格式化的数据。\n\n// 函数原型// 将参数str的字符串根据参数format字符串来转换并格式化数据，转换后的结果存于对应的参数内。sscanf(const char *str, const char *format, ...)。具体功能如下：（1）根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。（2）取指定长度的字符串（3）取到指定字符为止的字符串（4）取仅包含指定字符集的字符串（5）取到指定字符集为止的字符串// 可以使用正则表达式进行字符串的拆分// shell脚本的时候, 会将正则表达式, 其实就是字符串的匹配规则, 用特殊字符来描述一类字符串/*正则匹配规则:\t[1-9]: 匹配一个字符, 这个字符在 1-9 范围内就满足条件\t[2-7]: 匹配一个字符, 这个字符在 2-7 范围内就满足条件\t[a-z]: 匹配一个字符, 这个字符在 a-z 范围内就满足条件\t[A,b,c,D, e, f]: 匹配一个字符, 这个字符是集合中任意一个就满足条件\t[1-9, f-x]: 匹配一个字符, 这个字符是1-9, 或者f-x 集合中的任意一个就满足条件\t[^1]: ^代表否定, 匹配一个字符,这个字符只要不是1就满足条件\t[^2-8]: 匹配一个字符,这个字符只要不在 2-8 范围内就满足条件\t[^a-f]: 匹配一个字符,这个字符只要不在 a-f 范围内就满足条件\t[^ ]: 匹配一个字符,这个字符只要不是空格就满足条件使用正则表达式如何取匹配字符串:举例: \t字符串 ==&gt; abcdefg12345AABBCCDD890\t正则表达式: [1-9][a-z], 可以匹配两个字符\t匹配方式: 从原始字符串开始位置遍历, 每遍历一个字符都需要和正则表达式进行匹配, \t\t满足条件继续向后匹配, 不满足条件, 匹配结束\t\t从新开始: 从正则表达式的第一个字符重新开始向后一次匹配\t\t\t当整个大字符串被匹配一遍, 就结束了\tabcdefg12345AABBCCDD893b\t\t- 匹配到一个子字符串: 3b\t1a2b3c4d5e6f7g12345AABBCCDD893b\t - 1a\t - 2b\t - 3c\t - 4d\t - 5e\t - 6f\t - 7g\t - 3b*/sscanf可以支持格式字符%[]：(1)-: 表示范围，如：%[1-9]表示只读取1-9这几个数字 %[a-z]表示只读取a-z小写字母，类似地 %[A-Z]只读取大写字母(2)^: 表示不取，如：%[^1]表示读取除&#x27;1&#x27;以外的所有字符 %[^/]表示除/以外的所有字符(3),: 范围可以用&quot;,&quot;相连接 如%[1-9,a-z]表示同时取1-9数字和a-z小写字母 (4)原则：从第一个在指定范围内的数字开始读取，到第一个不在范围内的数字结束%s 可以看成%[] 的一个特例 %[^ ](注意^后面有一个空格！)\n\n5.2 转码假设浏览器访问的文件名中有中文: Linux内核.jpg\t- 浏览器在给服务器发送请求的时候, 会自动将中文进制转换: Linux%E5%86%85%E6%A0%B8.jpg\t- 为什么要转换?\t\t- 在http请求的请求行中不支持中文字符, 如果有中文, 浏览器就会自动将中文进行转换\t\t- 在服务器端收到的文件名就不是原来的名字了, 因此服务器端就不能识别了\t\t- 如果服务器端想要正确的处理, 需要将特殊字符串解析成原来的汉字\t\t$ unicode 内UTF-8: e5 86 85 $ unicode 核UTF-8: e6 a0 b8\n\n5.3 获取文件信息（stat）Linux 下可以使用stat 命令查看文件的属性，其实这个命令内部就是通过调用 stat()函数来获取文件属性的，stat 函数是 Linux 中的系统调用，用于获取文件相关的信息。\n#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int stat(const char *pathname, struct stat *buf);\n\nstruct stat&#123;\t dev_t st_dev; /* 文件所在设备的 ID */\t ino_t st_ino; /* 文件对应 inode 节点编号 */\t mode_t st_mode; /* 文件对应的模式 */\t nlink_t st_nlink; /* 文件的链接数 */\t uid_t st_uid; /* 文件所有者的用户 ID */\t gid_t st_gid; /* 文件所有者的组 ID */\t dev_t st_rdev; /* 设备号（指针对设备文件） */\t off_t st_size; /* 文件大小（以字节为单位） */\t blksize_t st_blksize; /* 文件内容存储的块大小 */\t blkcnt_t st_blocks; /* 文件内容所占块数 */\t struct timespec st_atim; /* 文件最后被访问的时间 */\t struct timespec st_mtim; /* 文件内容最后被修改的时间 */\t struct timespec st_ctim; /* 文件状态最后被改变的时间 */&#125;;st_dev：该字段用于描述此文件所在的设备。不常用，可以不用理会。st_ino：文件的 inode 编号。st_mode：该字段用于描述文件的模式，譬如文件类型、文件权限都记录在该变量中。st_nlink：该字段用于记录文件的硬链接数，也就是为该文件创建了多少个硬链接文件。链接文件可以分为软链接（符号链接）文件和硬链接文件。st_uid、st_gid：此两个字段分别用于描述文件所有者的用户 ID 以及文件所有者的组 ID。st_rdev：该字段记录了设备号，设备号只针对于设备文件，包括字符设备文件和块设备文件，不用理会。st_size：该字段记录了文件的大小（逻辑大小），以字节为单位。st_atim、st_mtim、st_ctim：此三个字段分别用于记录文件最后被访问的时间、文件内容最后被修改的时间以及文件状态最后被改变的时间，都是 struct timespec 类型变量。\n\n5.3 解析请求行（parseRequestLine函数）int parseRequestLine(const char* line,int cfd)&#123;    // 1. 拆分http请求行   get /xxx/1.jpg http/1.1    char method[12];    // 方法    char path[1024];    // 路径    char protocol[12];  // 协议    sscanf(line,&quot;%[^ ] %[^ ] %[^ ]&quot;,method,path,protocol);    printf(&quot;method = %s, path = %s, protocol = %s\\n&quot;, method, path, protocol);    // 判断是否是get请求    if(strcasecmp(method,&quot;get&quot;) != 0)&#123;     //不区分大小写        return -1;    &#125;    // 转码 将不能识别的中文乱码 -&gt; 中文    // 解码 %23 %34 %5f    decode_str(path, path);    // 2. 处理客户端请求的静态资源    char* file = NULL;    // 如果没有指定访问的资源, 默认显示资源目录中的内容    if(strcmp(path,&quot;/&quot;) == 0)&#123;        // file的值, 资源目录的当前位置        file = &quot;./&quot;;    &#125;else&#123;        // 去掉path中的/ 获取访问文件名        file = path + 1;    &#125;        // 3. 获取文件属性    struct stat st;    int ret = stat(file,&amp;st);    if(ret == -1)&#123;        // 文件不存在--回复404        return 0;    &#125;    // 判断文件类型（判断是目录还是文件）    if(S_ISDIR(st.st_mode))&#123;    // 目录        // 把目录发给客户端    &#125;else&#123;        // 把文件内容发给客户端    &#125;    return 0;&#125;\n\n6. 发送响应头int sendHeadMsg(int cfd,int status,const char* desrc,const char* type,int length)&#123;    // 状态行    char buf[4096] = &#123; 0 &#125;;    sprintf(buf,&quot;http/1.1 %d %s \\r\\n&quot;,status,desrc);    // 消息报头    sprintf(buf + strlen(buf),&quot;Content-Type: %s\\r\\n&quot;,type);    sprintf(buf + strlen(buf),&quot;Content-Length: %d\\r\\n&quot;,length);    send(cfd,buf,strlen(buf),0);     // 空行    send(cfd, &quot;\\r\\n&quot;, 2, 0);    return 0;&#125;\n\n7. 通过文件名获取文件的类型// 通过文件名获取文件的类型const char *get_file_type(const char *name)&#123;    char* dot;    // 自右向左查找‘.’字符, 如不存在返回NULL    dot = strrchr(name, &#x27;.&#x27;);       if (dot == NULL)        return &quot;text/plain; charset=utf-8&quot;;    if (strcmp(dot, &quot;.html&quot;) == 0 || strcmp(dot, &quot;.htm&quot;) == 0)        return &quot;text/html; charset=utf-8&quot;;    if (strcmp(dot, &quot;.jpg&quot;) == 0 || strcmp(dot, &quot;.jpeg&quot;) == 0)        return &quot;image/jpeg&quot;;    if (strcmp(dot, &quot;.gif&quot;) == 0)        return &quot;image/gif&quot;;    if (strcmp(dot, &quot;.png&quot;) == 0)        return &quot;image/png&quot;;    if (strcmp(dot, &quot;.css&quot;) == 0)        return &quot;text/css&quot;;    if (strcmp(dot, &quot;.au&quot;) == 0)        return &quot;audio/basic&quot;;    if (strcmp( dot, &quot;.wav&quot; ) == 0)        return &quot;audio/wav&quot;;    if (strcmp(dot, &quot;.avi&quot;) == 0)        return &quot;video/x-msvideo&quot;;    if (strcmp(dot, &quot;.mov&quot;) == 0 || strcmp(dot, &quot;.qt&quot;) == 0)        return &quot;video/quicktime&quot;;    if (strcmp(dot, &quot;.mpeg&quot;) == 0 || strcmp(dot, &quot;.mpe&quot;) == 0)        return &quot;video/mpeg&quot;;    if (strcmp(dot, &quot;.vrml&quot;) == 0 || strcmp(dot, &quot;.wrl&quot;) == 0)        return &quot;model/vrml&quot;;    if (strcmp(dot, &quot;.midi&quot;) == 0 || strcmp(dot, &quot;.mid&quot;) == 0)        return &quot;audio/midi&quot;;    if (strcmp(dot, &quot;.mp3&quot;) == 0)        return &quot;audio/mpeg&quot;;    if (strcmp(dot, &quot;.ogg&quot;) == 0)        return &quot;application/ogg&quot;;    if (strcmp(dot, &quot;.pac&quot;) == 0)        return &quot;application/x-ns-proxy-autoconfig&quot;;    return &quot;text/plain; charset=utf-8&quot;;&#125;\n\n8. 发送文件8.1 断言（assert函数）编译期assert函数的目的在于当条件不满足时，阻止编译，从而防止错误的逻辑通过编辑。而运行期assert的目的在于运行时发现条件不满足时，产生一个Debug事件(DebugBreak)，从而让调试器停下来方便用户检查原因。assert 是一个宏，不是函数。\n//表达式可以是任何有效的 C 语言表达式，很多时候它是一个条件。void assert(int expression or variable);\n\n8.2 光标函数（lseek函数）#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;off_t lseek(int handle, off_t offset, int fromwhere);1) 欲将读写位置移到文件开头时:lseek（int fildes,0,SEEK_SET）；2) 欲将读写位置移到文件尾时:lseek（int fildes，0,SEEK_END）；3) 想要取得目前文件位置时:lseek（int fildes，0,SEEK_CUR）；\n\n8.3 发送文件（sendFile函数）int sendFile(const char* filename,int cfd)&#123;    // 1. 打开文件    int fd = open(filename,O_RDONLY);    assert(fd &gt; 0);     // 断言    // if(fd == -1)&#123;    //     perror(&quot;open error&quot;);    // &#125;    // 2. 循环读文件#if 1    char buf[4096] = &#123; 0 &#125;;    int len = 0, ret = 0;    while((len = read(fd,buf,sizeof(buf))) &gt; 0)&#123;        // 发送读出的数据        ret = send(cfd,buf,len,0);        if(ret == -1)&#123;            if(errno = EAGAIN)&#123;                perror(&quot;send error:&quot;);                continue;            &#125;else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;    &#125;#else    off_t offset = 0;    int size = lseek(fd,0,SEEK_END);    lseek(fd,0,SEEK_SET);    while(offset &lt; size)&#123;        int ret = sendfile(cfd,fd,&amp;offset,size);        printf(&quot;ret value: %d\\n&quot;,ret);        if(ret == -1 &amp;&amp; errno == EAGAIN)&#123;            printf(&quot;没数据。。。\\n&quot;);            perror(&quot;snedfile&quot;);                    &#125;    &#125;#endif    close(fd);    return 0;&#125;\n\n9. 发送目录9.1 目录扫描函数（scandir函数）scandir()会扫描参数dir指定的目录文件，经由参数select指定的函数来挑选目录结构至参数namelist数组中，最后再调用参数compar指定的函数来排序namelist数组中的目录数据。每次从目录文件中读取一个目录结构后便将此结构传给参数select所指的函数，select函数若不想要将此目录结构复制到namelist数组就返回0，若select为空指针则代表选择所有的目录结构。scandir()会调用qsort()来排序数据，参数compar则为qsort()的参数，若是要排列目录名称字母则可使用alphasort()。\n#include &lt;dirent.h&gt;int scandir(const char *dir, \t\t\tstruct dirent ***namelist,\t\t\tint (*select)(const struct dirent *),\t\t\tint (*compar)(const struct dirent **, \t\t\tconst struct dirent **));dir:指定扫描的目录namelist:struct dirent结构体类型的三级指针，用于获取该函数内部为存放返回结果的分配的动态内存select:函数指针，指向过滤模式函数,当selectr指针设置为NULL时，扫描dir目录下的所有顶层文件.该函数有一个参数const struct dirent *是指在遍历过程中所遍历到的每一个子目录dirent，select可以根据dirent的类型、名称等信息来判定当前的dirent是否为合法的子目录，合法则函数返回0，则该子目录的名称会被存储在namelist中；否则返回非0，则该子目录被过滤掉。compar:函数指针，指向对遍历结果进行排序函数，alphasort函数和versionsort是经常用到的函数\n\n9.2 发送目录（sendDir函数）// 发送目录内容int sendDir(const char* dirname, int cfd)&#123;      // 拼接一个html页面&lt;table&gt;&lt;/table&gt;   char buf[4096] = &#123; 0 &#125;;      sprintf(buf,&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;,dirname);   //sprintf(buf + strlen(buf),&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;,dirname);    // 目录项二级指针    struct dirent** ptr;    int num = scandir(dirname,&amp;ptr,NULL,alphasort);    // 遍历目录    for(int i = 0; i &lt; num; i++)&#123;        // 取出文件名 namelist 指向的是一个指针数组 struct dirent* tmp[]        char* name = ptr[i]-&gt;d_name;        char subPath[1024] = &#123; 0 &#125;;        // 拼接文件袋完整路径        sprintf(subPath,&quot;%s/%s&quot;,dirname,name);                struct stat st;        stat(subPath,&amp;st);        char enstr[1024] = &#123;0&#125;;        // 编码生成 %E5 %A7 之类的东西        encode_str(enstr, sizeof(enstr), name);        // 如果是文件        if(S_ISREG(st.st_mode)) &#123;                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\\&quot;%s\\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125; else if(S_ISDIR(st.st_mode)) &#123;\t\t// 如果是目录                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\\&quot;%s/\\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125;        int ret = send(cfd, buf, strlen(buf), 0);        if (ret == -1) &#123;            if (errno == EAGAIN) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;        memset(buf, 0, sizeof(buf));        // 字符串拼接        free(ptr[i]);    &#125;          // 字符串拼接    //memset(buf, 0, sizeof(buf));    sprintf(buf, &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);    send(cfd, buf, strlen(buf), 0);    printf(&quot;dir message send OK!!!!\\n&quot;); #if 0    // 打开目录    DIR* dir = opendir(dirname);    if(dir == NULL)    &#123;        perror(&quot;opendir error&quot;);        exit(1);    &#125;    // 读目录    struct dirent* ptr = NULL;    while( (ptr = readdir(dir)) != NULL )    &#123;        char* name = ptr-&gt;d_name;    &#125;    closedir(dir);#endif    free(ptr);    return 0;&#125;\n\n10. 完整代码整体框架\n/*客户端: 浏览器\t- 通过浏览器访问服务器:\t\t- 访问方式: 服务器的IP地址:端口\t- 应用层协议使用: http, 数据需要在浏览器端使用该协议进行包装\t- 响应消息的处理也是浏览器完成的 =&gt; 程序猿不需要管\t- 客户端通过url访问服务器资源\t\t- 客户端访问的路径:\t\t1. http://192.168.1.100:8989/  或者  http://192.168.1.100:8989\t\t\t- 访问服务器提供的资源目录的根目录\t\t\t\t- 并不是服务器上的 / 目录  \t\t\t\t- 这个目录根据服务器端的描述应该是: /home/robin/luffy 目录\t\t\t- 请求行:\t\t\t\tGET / HTTP/1.1\t\t2. http://192.168.1.100:8989/a.txt\t\t\t- 端口后边的/代表服务器的资源根目录\t\t\t\t- 在服务器端路径: /home/robin/luffy 目录\t\t\t- 客户端要访问服务器上的a.txt的文件\t\t\t- a.txt 这个文件在服务器提供的资源目录中\t\t\t\t- 服务器上的路径: /home/robin/luffy/a.txt\t\t\t- 请求行:\t\t\t\tGET /a.txt HTTP/1.1\t\t3. http://192.168.1.100:8989/hello/a.txt\t\t\t- http://192.168.1.100:8989: 服务器地址\t\t\t- /hello/a.txt\t\t\t\t- /: 服务器端提供的资源根目录\t\t\t\t- hello: 资源根目录的子目录\t\t\t\t- a.txt: 在hello目录中\t\t\t- 请求行:\t\t\t\tGET /hello/a.txt HTTP/1.1\t\t4. http://192.168.1.100:8989/hello/wrold/\t\t\t- http://192.168.1.100:8989: 服务器地址\t\t\t- /hello/world/\t\t\t\t- /: 服务器端提供的资源根目录\t\t\t\t- hello: 资源根目录的子目录\t\t\t\t- world/: 如果world后边有/代表这是一个目录, 这个目录在hello目录中\t\t\t- 请求行:\t\t\t\tGET /hello/world/ HTTP/1.1*//*服务器端: 提供服务器, 让客户端访问\t- 支持多客户端访问\t\t- 使用IO多路转接 =&gt; epoll\t- 客户端发送给的请求消息是基于http的\t\t- 需要能够解析http请求\t- 服务器回复客户端数据, 使用http协议封装回复的数据 ==&gt; http响应\t- 服务器端需要提供一个资源目录, 目录中的文件可以供客户端访问\t\t- 客户端访问的文件没有在资源目录中, 就不能访问了\t\t\t- 假设服务器提供个资源目录: /home/robin/luffy 目录*/\n\n// 服务器端处理的伪代码int main()&#123;    // 1. 创建监听的fd    socket();    // 2. 绑定    bind();    // 3. 设置监听    listen();        // 4. 创建epoll模型    epoll_create();    epoll_ctl();    // 5. 检测    while(1)    &#123;        epoll_wait();        // 监听的文件描述符        accept();        // 通信的        // 接收数据-&gt;http请求消息        recvAndParseHttp();    &#125;    return 0;&#125;// 基于边沿非阻塞模型接收数据int recvAndParseHttp()&#123;    // 循环接收数据    // 解析http请求消息    // http请求由两种:get / post    // 只处理get请求, 浏览器向服务器请求访问的文件都是静态资源, 因此使用get就可以    // 判断是不是get请求  ==&gt; 在请求行中 ==&gt; 请求行的第一部分    // 客户端向服务器请求的静态资源是什么? =&gt; 请求行的第二部分    // 找到服务器上的静态资源    \t- 文件 -&gt; 读文件内容        - 目录 -&gt; 遍历目录    // 将文件内容或者目录内容打包到http响应协议中    // 将整条协议发送回给客户端即可&#125;\n\nepoll_web.c\n#include &quot;epoll_web.h&quot;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;#include &lt;assert.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;dirent.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#include &lt;sys/types.h&gt;// 初始化监听套接字int initListenFd(unsigned int port)&#123;    // 1. 创建监听套接字    int lfd = socket(AF_INET,SOCK_STREAM,0);    if(lfd == -1)&#123;        perror(&quot;socket error&quot;);        return -1;    &#125;    // 2. 设置端口复用    int opt = 1;    int ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt));    if(ret == -1)&#123;        perror(&quot;setsockopt error&quot;);        return -1;    &#125;    // 3. 绑定    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = 0;    ret = bind(lfd,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ret == -1)&#123;        perror(&quot;bind error&quot;);        return -1;    &#125;    // 4.设置监听    ret = listen(lfd,128);    if(ret == -1)&#123;        perror(&quot;listen error&quot;);        return -1;    &#125;    // 5. 返回fd    return lfd;&#125;//启动epollint epollrun(int lfd)&#123;    // 1. 创建epoll树    int epfd = epoll_create(1);    if(epfd == -1)&#123;        perror(&quot;epoll_create error&quot;);        return -1;    &#125;    // 2. lfd上树    struct epoll_event ev;    ev.data.fd = lfd;    ev.events = EPOLLIN;    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    // 3. 检测(委托内核检测添加到树上的节点)    struct epoll_event evs[1024];    int size = sizeof(evs) / sizeof(struct epoll_event);    while(1)&#123;        int num = epoll_wait(epfd,evs,size,-1);        if(num == -1) &#123;            perror(&quot;epoll_wait error&quot;);            return -1;        &#125;        // 遍历发生变化的节点        for(int i = 0; i &lt; num; ++i)&#123;            if(!(evs[i].events &amp; EPOLLIN)) &#123;                // 不是读事件                continue;            &#125;            int fd = evs[i].data.fd;            if(fd == lfd)&#123;                //建立新连接accept                accpetClient(lfd,epfd);            &#125;else&#123;                // 读数据                printf(&quot;=============before recvHttpRequest=============\\n&quot;);                recvHttpRequest(fd,epfd);                printf(&quot;=============after recvHttpRequest=============\\n&quot;);            &#125;        &#125;    &#125;    return 0;&#125;int accpetClient(int lfd,int epfd)&#123;    // 1. 建立连接    struct sockaddr_in cliaddr;    socklen_t len = sizeof(cliaddr);    cliaddr.sin_family = AF_INET;    int cfd = accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len);    if(cfd == -1)&#123;        perror(&quot;accept error&quot;);        return -1;    &#125;    char ip[16]=&quot;&quot;;    printf(&quot;new client ip=%s port=%d\\n&quot;,    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));        // 2. 设置cfd为非阻塞    int flag = fcntl(cfd,F_GETFL);    flag |= O_NONBLOCK;    fcntl(cfd,F_SETFL,flag);    // 3. cfd添加到epoll    struct epoll_event ev;    ev.data.fd = cfd;    // 边沿非阻塞模式    ev.events = EPOLLIN | EPOLLET;      //边沿模式    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    return 0;&#125;int recvHttpRequest(int cfd,int epfd)&#123;    char buf[4096] = &#123; 0 &#125;;    char tmp[1024] = &#123; 0 &#125;;    int len = 0;    int total = 0;    // 1. 接收数据    while((len = recv(cfd,tmp,sizeof(tmp),0)) &gt; 0)&#123;        if(total + len &lt; sizeof(buf))&#123;            memcpy(buf + total,tmp,len);        &#125;        total += len;    &#125;    // 2. 判断数据是否接受完毕    if(len == -1 &amp;&amp; errno == EAGAIN)&#123;        // 解析请求行           /*        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19        G E T   / 1 . t x t H  T  T  P  /  1  .  1  /r /n        */        char* pt = strstr(buf,&quot;\\r\\n&quot;);  //大字符串找小字符串        int reqLen = pt - buf;        buf[reqLen] = &#x27;\\0&#x27;;        parseRequestLine(buf,cfd);    &#125;    else if(len == 0)&#123;        // 客户端断开连接        epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);        close(cfd);    &#125;    else&#123;        perror(&quot;recv error&quot;);    &#125;    return 0;&#125;int parseRequestLine(const char* line,int cfd)&#123;    // 1. 拆分http请求行   get /xxx/1.jpg http/1.1    char method[12];    // 方法    char path[1024];    // 路径    char protocol[12];  // 协议    sscanf(line,&quot;%[^ ] %[^ ] %[^ ]&quot;,method,path,protocol);    printf(&quot;method = %s, path = %s, protocol = %s\\n&quot;, method, path, protocol);    // 判断是否是get请求    if(strcasecmp(method,&quot;get&quot;) != 0)&#123;     //不区分大小写        return -1;    &#125;    // 转码 将不能识别的中文乱码 -&gt; 中文    // 解码 %23 %34 %5f    decode_str(path, path);    // 2. 处理客户端请求的静态资源    char* file = NULL;    // 如果没有指定访问的资源, 默认显示资源目录中的内容    if(strcmp(path,&quot;/&quot;) == 0)&#123;        // file的值, 资源目录的当前位置        file = &quot;./&quot;;    &#125;else&#123;        // 去掉path中的/ 获取访问文件名        file = path + 1;    &#125;        // 3. 获取文件属性    struct stat st;    int ret = stat(file,&amp;st);    if(ret == -1)&#123;        // 文件不存在--回复404        sendHeadMsg(cfd,404,&quot;Not Found&quot;,get_file_type(&quot;.html&quot;),-1);        sendFile(&quot;404.html&quot;,cfd);        return 0;    &#125;    // 判断文件类型（判断是目录还是文件）    if(S_ISDIR(st.st_mode))&#123;    // 目录        // 把目录发给客户端         sendHeadMsg(cfd,200,&quot;OK&quot;,get_file_type(&quot;.html&quot;),-1);         sendDir(file,cfd);    &#125;else&#123;        // 把文件内容发给客户端        sendHeadMsg(cfd,200,&quot;OK&quot;,get_file_type(file),st.st_size);        sendFile(file,cfd);    &#125;    return 0;&#125;int sendHeadMsg(int cfd,int status,const char* desrc,const char* type,int length)&#123;    // 状态行    char buf[4096] = &#123; 0 &#125;;    sprintf(buf,&quot;http/1.1 %d %s \\r\\n&quot;,status,desrc);    // 消息报头    sprintf(buf + strlen(buf),&quot;Content-Type: %s\\r\\n&quot;,type);    sprintf(buf + strlen(buf),&quot;Content-Length: %d\\r\\n&quot;,length);    send(cfd,buf,strlen(buf),0);     // 空行    send(cfd, &quot;\\r\\n&quot;, 2, 0);    return 0;&#125;int sendFile(const char* filename,int cfd)&#123;    // 1. 打开文件    int fd = open(filename,O_RDONLY);    assert(fd &gt; 0);     // 断言    // if(fd == -1)&#123;    //     perror(&quot;open error&quot;);    // &#125;    // 2. 循环读文件#if 1    char buf[4096] = &#123; 0 &#125;;    int len = 0, ret = 0;    while((len = read(fd,buf,sizeof(buf))) &gt; 0)&#123;        // 发送读出的数据        ret = send(cfd,buf,len,0);        if(ret == -1)&#123;            if(errno = EAGAIN)&#123;                perror(&quot;send error:&quot;);                continue;            &#125;else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;    &#125;#else    off_t offset = 0;    int size = lseek(fd,0,SEEK_END);    lseek(fd,0,SEEK_SET);    while(offset &lt; size)&#123;        int ret = sendfile(cfd,fd,&amp;offset,size);        printf(&quot;ret value: %d\\n&quot;,ret);        if(ret == -1 &amp;&amp; errno == EAGAIN)&#123;            printf(&quot;没数据。。。\\n&quot;);            perror(&quot;snedfile&quot;);                    &#125;    &#125;#endif    close(fd);    return 0;&#125;// 发送目录内容int sendDir(const char* dirname, int cfd)&#123;      // 拼接一个html页面&lt;table&gt;&lt;/table&gt;   char buf[4096] = &#123; 0 &#125;;      sprintf(buf,&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;,dirname);   //sprintf(buf + strlen(buf),&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;,dirname);    // 目录项二级指针    struct dirent** ptr;    int num = scandir(dirname,&amp;ptr,NULL,alphasort);    // 遍历目录    for(int i = 0; i &lt; num; i++)&#123;        // 取出文件名 namelist 指向的是一个指针数组 struct dirent* tmp[]        char* name = ptr[i]-&gt;d_name;        char subPath[1024] = &#123; 0 &#125;;        // 拼接文件袋完整路径        sprintf(subPath,&quot;%s/%s&quot;,dirname,name);                struct stat st;        stat(subPath,&amp;st);        char enstr[1024] = &#123;0&#125;;        // 编码生成 %E5 %A7 之类的东西        encode_str(enstr, sizeof(enstr), name);        // 如果是文件        if(S_ISREG(st.st_mode)) &#123;                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\\&quot;%s\\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125; else if(S_ISDIR(st.st_mode)) &#123;\t\t// 如果是目录                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\\&quot;%s/\\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125;        int ret = send(cfd, buf, strlen(buf), 0);        if (ret == -1) &#123;            if (errno == EAGAIN) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;        memset(buf, 0, sizeof(buf));        // 字符串拼接        free(ptr[i]);    &#125;          // 字符串拼接    //memset(buf, 0, sizeof(buf));    sprintf(buf, &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);    send(cfd, buf, strlen(buf), 0);    printf(&quot;dir message send OK!!!!\\n&quot;); #if 0    // 打开目录    DIR* dir = opendir(dirname);    if(dir == NULL)    &#123;        perror(&quot;opendir error&quot;);        exit(1);    &#125;    // 读目录    struct dirent* ptr = NULL;    while( (ptr = readdir(dir)) != NULL )    &#123;        char* name = ptr-&gt;d_name;    &#125;    closedir(dir);#endif    free(ptr);    return 0;&#125;/* *  这里的内容是处理%20之类的东西！是&quot;解码&quot;过程。 *  %20 URL编码中的‘ ’(space) *  %21 &#x27;!&#x27; %22 &#x27;&quot;&#x27; %23 &#x27;#&#x27; %24 &#x27;$&#x27; *  %25 &#x27;%&#x27; %26 &#x27;&amp;&#x27; %27 &#x27;&#x27;&#x27; %28 &#x27;(&#x27;...... *  相关知识html中的‘ ’(space)是&amp;nbsp */// 16进制数转化为10进制int hexit(char c)&#123;    if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)        return c - &#x27;0&#x27;;    if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;)        return c - &#x27;a&#x27; + 10;    if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;F&#x27;)        return c - &#x27;A&#x27; + 10;    return 0;&#125;void encode_str(char* to, int tosize, const char* from)&#123;    int tolen;    for (tolen = 0; *from != &#x27;\\0&#x27; &amp;&amp; tolen + 4 &lt; tosize; ++from) &#123;            if (isalnum(*from) || strchr(&quot;/_.-~&quot;, *from) != (char*)0) &#123;                  *to = *from;            ++to;            ++tolen;        &#125; else &#123;            sprintf(to, &quot;%%%02x&quot;, (int) *from &amp; 0xff);            to += 3;            tolen += 3;        &#125;    &#125;    *to = &#x27;\\0&#x27;;&#125;void decode_str(char *to, char *from)&#123;    for ( ; *from != &#x27;\\0&#x27;; ++to, ++from  ) &#123;             if (from[0] == &#x27;%&#x27; &amp;&amp; isxdigit(from[1]) &amp;&amp; isxdigit(from[2])) &#123;                   *to = hexit(from[1])*16 + hexit(from[2]);            from += 2;                              &#125; else &#123;            *to = *from;        &#125;    &#125;    *to = &#x27;\\0&#x27;;&#125;// 通过文件名获取文件的类型const char *get_file_type(const char *name)&#123;    char* dot;    // 自右向左查找‘.’字符, 如不存在返回NULL    dot = strrchr(name, &#x27;.&#x27;);       if (dot == NULL)        return &quot;text/plain; charset=utf-8&quot;;    if (strcmp(dot, &quot;.html&quot;) == 0 || strcmp(dot, &quot;.htm&quot;) == 0)        return &quot;text/html; charset=utf-8&quot;;    if (strcmp(dot, &quot;.jpg&quot;) == 0 || strcmp(dot, &quot;.jpeg&quot;) == 0)        return &quot;image/jpeg&quot;;    if (strcmp(dot, &quot;.gif&quot;) == 0)        return &quot;image/gif&quot;;    if (strcmp(dot, &quot;.png&quot;) == 0)        return &quot;image/png&quot;;    if (strcmp(dot, &quot;.css&quot;) == 0)        return &quot;text/css&quot;;    if (strcmp(dot, &quot;.au&quot;) == 0)        return &quot;audio/basic&quot;;    if (strcmp( dot, &quot;.wav&quot; ) == 0)        return &quot;audio/wav&quot;;    if (strcmp(dot, &quot;.avi&quot;) == 0)        return &quot;video/x-msvideo&quot;;    if (strcmp(dot, &quot;.mov&quot;) == 0 || strcmp(dot, &quot;.qt&quot;) == 0)        return &quot;video/quicktime&quot;;    if (strcmp(dot, &quot;.mpeg&quot;) == 0 || strcmp(dot, &quot;.mpe&quot;) == 0)        return &quot;video/mpeg&quot;;    if (strcmp(dot, &quot;.vrml&quot;) == 0 || strcmp(dot, &quot;.wrl&quot;) == 0)        return &quot;model/vrml&quot;;    if (strcmp(dot, &quot;.midi&quot;) == 0 || strcmp(dot, &quot;.mid&quot;) == 0)        return &quot;audio/midi&quot;;    if (strcmp(dot, &quot;.mp3&quot;) == 0)        return &quot;audio/mpeg&quot;;    if (strcmp(dot, &quot;.ogg&quot;) == 0)        return &quot;application/ogg&quot;;    if (strcmp(dot, &quot;.pac&quot;) == 0)        return &quot;application/x-ns-proxy-autoconfig&quot;;    return &quot;text/plain; charset=utf-8&quot;;&#125;\n\nepoll_web.h#ifndef _EPOLL_SEVER_H#define _EPOLL_SEVER_H// 初始化监听的套接字int initListenFd(unsigned int port);//启动epollint epollrun(int lfd);// 建立新连接int accpetClient(int lfd,int epfd);// 读数据int recvHttpRequest(int fd,int epfd);// 解析请求行int parseRequestLine(const char* line,int cfd);// 发送响应头（状态行+响应头）int sendHeadMsg(int cfd,int status,const char* desrc,const char* type,int length);// 发送文件int sendFile(const char* filename,int cfd);// 发送目录int sendDir(const char* dirName,int cfd);// 通过文件名获取文件的类型const char *get_file_type(const char *name);int hexit(char c);void encode_str(char* to, int tosize, const char* from);void decode_str(char *to, char *from);#endif\n\nmain.c#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include &quot;epoll_web.h&quot;int main(int argc, char* argv[])&#123;    if(argc &lt; 3)&#123;        printf(&quot;./a.out port path\\n&quot;);        exit(1);    &#125;    // 采用指定端口    unsigned int port = atoi(argv[1]);    // 修改进程工作目录，方便后续操作    int ret = chdir(argv[2]);    if(ret == -1)&#123;        perror(&quot;chdir error&quot;);    &#125;    // 初始化监听套接字    int lfd = initListenFd(port);    // 启动epoll模型    epollrun(lfd);    return 0;&#125;\n\n","categories":["笔记"],"tags":["linux","c","网络编程"]},{"title":"实现多态的方法","url":"/2023/11/27/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%96%B9%E6%B3%95/","content":"实现多态的方法多态其实一般就是指继承加虚函数实现的多态，对于重载来说，实际上基于的原理是，编译器为函数生成符号表时的不同规则，重载只是一种语言特性，与多态无关，与面向对象也无关，但这又是 C++中增加的新规则，所以也算属于 C++，所以如果非要说重载算是多态的一种，那就可以说：多态可以分为静态多态和动态多态。\n静态多态其实就是重载，因为静态多态是指在编译时期就决定了调用哪个函数，根据参数列表来决定；\n动态多态是指通过子类重写父类的虚函数来实现的，因为是在运行期间决定调用的函数，所以称为动态多态，\n一般情况下我们不区分这两个时所说的多态就是指动态多态。\n动态多态的实现与虚函数表，虚函数指针相关。\n子类是否要重写父类的虚函数？\n子类继承父类时， 父类的纯虚函数必须重写，否则子类也是一个虚类不可实例化。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。\n","categories":["每日一题"],"tags":["c++"]},{"title":"手写线程池","url":"/2023/11/08/%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"手写线程池线程池原理线程池的组成主要分为3个部分，这三部分配合工作就可以得到一个完整的线程池：\n\n任务队列，存储需要处理的任务，由工作的线程来处理这些任务通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除已处理的任务会被从任务队列中删除线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程\n工作的线程（任务队列任务的消费者） ，N个线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理工作的线程相当于是任务队列的消费者角色，如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量&#x2F;信号量阻塞)如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作\n管理者线程（不处理任务队列中的任务），1个它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测当任务过多的时候, 可以适当的创建一些新的工作线程当任务过少的时候, 可以适当的销毁一些工作的线程\n\n\n1. c语言版main.c#include&lt;stdio.h&gt;#include &quot;threadpool.h&quot;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void taskFunc(void* arg)&#123;    int num = *(int*)arg;    printf(&quot;thread is working, number = %d, tid = %ld\\n&quot;,num,pthread_self());    usleep(1000);&#125;int main()&#123;    // 创建线程池    ThreadPool* pool = threadPoolCreate(3,10,100);    for(int i = 0; i &lt; 100; i++)&#123;                // threadPoolAdd(pool,taskFunc,&amp;i);        int* num = (int*)malloc(sizeof(int));        *num = i + 100;        threadPoolAdd(pool, taskFunc, num);    &#125;    sleep(30);    threadPoolDestory(pool);       return 0;&#125;\n\nthreadpool.c#include &quot;threadpool.h&quot;const int NUMBER = 2;//  任务结构体typedef struct  Task&#123;    void (*function)(void* arg);    //函数指针    void* arg;&#125;Task;//线程池结构体struct ThreadPool&#123;    //任务队列    Task* taskQ;    int queueCapacity;  // 容量     int queueSize;      //当前任务个数    int queueFront;     //队头  -&gt;取数据    int queueRear;      //队尾  &lt;-存数据    //管理者线程    pthread_t   managerID;  //管理者线程ID    //工作线程    pthread_t   *threadIDs; //工作的线程ID        int minNum;     //最小线程数量    int maxNum;     //最大线程数量    int busyNum;    //忙的线程个数    int liveNum;    //存活的线程个数    int exitNum;    //要销毁的线程个数    //互斥锁    pthread_mutex_t mutexPool;  //锁整个的线程池    pthread_mutex_t mutexBusy;  //锁busyNum变量    //条件变量    pthread_cond_t notFull;     //任务队列是不是满了    pthread_cond_t notEmpty;    //任务队列是不是空了    int shutdown;   //是不是要销毁线程池，销毁为1，不销毁为0&#125;;ThreadPool* threadPoolCreate(int min, int max, int queueSize)&#123;    ThreadPool* pool = (ThreadPool*)malloc(sizeof(ThreadPool));    do&#123;        if(pool == NULL)&#123;            printf(&quot;malloc threadpool fail...\\n&quot;);            break;        &#125;        pool-&gt;threadIDs = (pthread_t*)malloc(sizeof(pthread_t) * max);        if(pool-&gt;threadIDs == NULL)&#123;            printf(&quot;malloc threadIDS fail...\\n&quot;);            break;        &#125;        memset(pool-&gt;threadIDs,0,sizeof(pthread_t) * max);        //bzero(&amp;pool-&gt;threadIDs,sizeof(pthread_t) * max);    //清0        pool-&gt;minNum = min;        pool-&gt;maxNum = max;        pool-&gt;busyNum = 0;        pool-&gt;liveNum = min;    //与最小个数相等        pool-&gt;exitNum = 0;        if(pthread_mutex_init(&amp;pool-&gt;mutexBusy,NULL) != 0 ||        pthread_mutex_init(&amp;pool-&gt;mutexPool,NULL) != 0 ||        pthread_cond_init(&amp;pool-&gt;notEmpty,NULL)  != 0 ||        pthread_cond_init(&amp;pool-&gt;notFull,NULL) != 0)&#123;            printf(&quot;mutex or condition init fail...\\n&quot;);            break;        &#125;        //任务队列        pool-&gt;taskQ = (Task*)malloc(sizeof(Task) * queueSize);        pool-&gt;queueCapacity = queueSize;        pool-&gt;queueSize = 0;        pool-&gt;queueFront = 0;        pool-&gt;queueRear = 0;        pool-&gt;shutdown = 0;        //创建线程        pthread_create(&amp;pool-&gt;managerID,NULL,manager,pool);        for(int i = 0; i &lt; min; i++)&#123;            pthread_create(&amp;pool-&gt;threadIDs[i],NULL,worker,pool);        &#125;        return pool;    &#125;while(0);    //释放资源    if(pool &amp;&amp; pool-&gt;threadIDs)&#123;        free(pool-&gt;threadIDs);    &#125;    if(pool &amp;&amp; pool-&gt;taskQ)&#123;        free(pool-&gt;taskQ);    &#125;        if(pool)&#123;        free(pool);    &#125;    return NULL;&#125;void threadPoolAdd(ThreadPool* pool, void(*func)(void*),void* arg)&#123;    pthread_mutex_lock(&amp;pool-&gt;mutexPool);    while (pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)    &#123;        //阻塞生产者线程（阻塞生产者）        pthread_cond_wait(&amp;pool-&gt;notFull,&amp;pool-&gt;mutexPool);    &#125;    if(pool-&gt;shutdown)&#123;        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);        return ;    &#125;    // 添加任务    pool-&gt;taskQ[pool-&gt;queueRear].function = func;    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;    pool-&gt;queueRear = (pool-&gt;queueRear + 1) % pool-&gt;queueCapacity;    pool-&gt;queueSize++;    pthread_cond_signal(&amp;pool-&gt;notEmpty);   //唤醒消费者           pthread_mutex_unlock(&amp;pool-&gt;mutexPool);&#125;int  threadPoolBusyNum(ThreadPool* pool)&#123;    pthread_mutex_lock(&amp;pool-&gt;mutexBusy);    int busyNum = pool-&gt;busyNum;    pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);    return busyNum;&#125;int threadPoolAliveNum(ThreadPool* pool)&#123;    pthread_mutex_lock(&amp;pool-&gt;mutexPool);    int liveNum = pool-&gt;liveNum;    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);    return liveNum;&#125;int threadPoolDestory(ThreadPool* pool)&#123;    if(pool == NULL)&#123;        return -1;    &#125;    // 关闭线程池    pool-&gt;shutdown = 1;    // 阻塞回收管理者线程    pthread_join(pool-&gt;managerID,NULL);    // 唤醒阻塞的消费者线程    for(int i = 0; i &lt; pool-&gt;liveNum; i++)&#123;        pthread_cond_signal(&amp;pool-&gt;notEmpty);    &#125;    if(pool-&gt;taskQ)&#123;        free(pool-&gt;taskQ);    &#125;    if(pool-&gt;threadIDs)&#123;        free(pool-&gt;threadIDs);    &#125;    // 销毁锁和条件变量    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);    pthread_cond_destroy(&amp;pool-&gt;notEmpty);    pthread_cond_destroy(&amp;pool-&gt;notFull);    free(pool);    pool = NULL;    return 0;&#125;// 消费者线程void* worker(void* arg)&#123;    ThreadPool* pool = (ThreadPool*)arg;    while(1)&#123;        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        // 当前任务队列是否为空        while (pool-&gt;queueSize == 0 &amp;&amp; !pool-&gt;shutdown)        &#123;            // 阻塞工作线程（阻塞消费者）            pthread_cond_wait(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool);                    // 判断是不是要销毁线程            if(pool-&gt;exitNum &gt; 0)&#123;                pool-&gt;exitNum--;                if(pool-&gt;liveNum &gt; pool-&gt;minNum)&#123;                    pool-&gt;liveNum--;                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);    // 销毁前，先解锁，防止死锁                    threadExit(pool);                &#125;                                //pthread_exit(NULL);            &#125;        &#125;                // 判断线程池是否被关闭        if(pool-&gt;shutdown)&#123;            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);     //防止死锁            threadExit(pool);            //pthread_exit(NULL);        &#125;        // 从队列中取出一个任务        Task task;        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;        // 移动头节点        pool-&gt;queueFront = (pool-&gt;queueFront + 1) % pool-&gt;queueCapacity;        pool-&gt;queueSize--;        //解锁        pthread_cond_signal(&amp;pool-&gt;notFull);    //唤醒生产者           pthread_mutex_unlock(&amp;pool-&gt;mutexPool);        //开始工作        printf(&quot;thread %ld  start working...\\n&quot;,pthread_self());        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        pool-&gt;busyNum++;        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);        //调用任务里的函数        task.function(task.arg);        //参数建议传堆内存        //(*task.function)(task.arg);   //另一种写法        free(task.arg);        task.arg = NULL;        printf(&quot;thread %ld  end working...\\n&quot;,pthread_self());        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        pool-&gt;busyNum--;        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);    &#125;    return NULL;&#125;void* manager(void* arg)&#123;    ThreadPool* pool = (ThreadPool*)arg;    while(!pool-&gt;shutdown)&#123;        // 每3s检测一次        sleep(3);        // 取出线程池中日任务的数量和当前线程的数量        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        int queueSize = pool-&gt;queueSize;        int liveNum = pool-&gt;liveNum;        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);                // 取出忙的线程的数量        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        int busyNum = pool-&gt;busyNum;        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);                //添加线程        //自定义规则：任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程个数 &lt; 线程的最大个数        if(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)&#123;            pthread_mutex_lock(&amp;pool-&gt;mutexPool);            int count = 0;            for(int i = 0; i &lt; pool-&gt;maxNum &amp;&amp; count &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)&#123;                if(pool-&gt;threadIDs[i] == 0)&#123;                    pthread_create(&amp;pool-&gt;threadIDs[i],NULL,worker,pool);                    count++;                    pool-&gt;liveNum++;                &#125;            &#125;             pthread_mutex_unlock(&amp;pool-&gt;mutexPool);        &#125;        //销毁线程        //自定义规则：忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程 &gt; 最小线程数        if(busyNum * 2 &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)&#123;            pthread_mutex_lock(&amp;pool-&gt;mutexPool);            pool-&gt;exitNum = NUMBER;            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);            // 让工作的线程自杀            for(int i = 0; i &lt; NUMBER; ++i)&#123;                // 唤醒工作线程                pthread_cond_signal(&amp;pool-&gt;notEmpty);            &#125;                &#125;    &#125;    return NULL;&#125;void threadExit(ThreadPool* pool)&#123;    pthread_t tid = pthread_self();    for(int i = 0; i &lt; pool-&gt;maxNum; ++i)&#123;        if(pool-&gt;threadIDs[i] == tid)&#123;            pool-&gt;threadIDs[i] = 0;            printf(&quot;threadExit() called, %ld exiting...\\n&quot;,tid);            break;        &#125;    &#125;    pthread_exit(NULL);&#125;\n\nthreadpool.h#ifndef _THREADPOOL_H#define _THREADPOOL_H#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;typedef struct ThreadPool ThreadPool;//  创建线程池并初始化ThreadPool* threadPoolCreate(int min,int max,int queueSize);//  销毁线程池int threadPoolDestory(ThreadPool* pool);//int threadPoolDestroy(ThreadPool* pool);//  给线程池添加任务void threadPoolAdd(ThreadPool* pool, void(*func)(void*),void* arg);//  获取线程池中工作的线程的个数int  threadPoolBusyNum(ThreadPool* pool);//  获取线程池中活着的线程的个数int threadPoolAliveNum(ThreadPool* pool);//////void* worker(void* arg);void* manager(void* arg);void threadExit(ThreadPool* pool);//////#endif\n\n2. c++版main.cpp#include&lt;iostream&gt;#include&lt;unistd.h&gt;#include &quot;ThreadPool.h&quot;#include &quot;ThreadPool.cpp&quot;using namespace std;void taskFunc(void* arg)&#123;    int num = *(int*)arg;    printf(&quot;thread is working, number = %d, tid = %ld\\n&quot;,num,pthread_self());    usleep(1000);&#125;int main()&#123;     // 创建线程池    ThreadPool&lt;int&gt; pool(3,10);    for(int i = 0; i &lt; 100; i++)&#123;                // threadPoolAdd(pool,taskFunc,&amp;i);        int* num = new int(i + 100);        pool.threadPoolAddTask(Task&lt;int&gt;(taskFunc,num));            &#125;    sleep(30);        return 0;&#125;\n\nTaskQueue.cpp#include &quot;TaskQueue.h&quot;template &lt;typename T&gt;TaskQueue&lt;T&gt;::TaskQueue()&#123;    pthread_mutex_init(&amp;m_mutex,NULL);&#125;template &lt;typename T&gt;TaskQueue&lt;T&gt;::~TaskQueue()&#123;    pthread_mutex_destroy(&amp;m_mutex);&#125;template &lt;typename T&gt;void TaskQueue&lt;T&gt;::addTask(Task&lt;T&gt;&amp; task)&#123;    pthread_mutex_lock(&amp;m_mutex);    m_taskQ.push(task);    pthread_mutex_unlock(&amp;m_mutex);&#125;template &lt;typename T&gt;void TaskQueue&lt;T&gt;::addTask(callback f, void* arg)&#123;    pthread_mutex_lock(&amp;m_mutex);    m_taskQ.push(Task&lt;T&gt;(f,arg));    pthread_mutex_unlock(&amp;m_mutex);&#125;template &lt;typename T&gt;Task&lt;T&gt; TaskQueue&lt;T&gt;::getTask()&#123;     Task&lt;T&gt; task;    pthread_mutex_lock(&amp;m_mutex);    if(m_taskQ.empty())&#123;        return task;    &#125;        task = m_taskQ.front();    m_taskQ.pop();    pthread_mutex_unlock(&amp;m_mutex);    return task;&#125;\n\nTaskQueue.h#pragma once#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;using callback = void (*)(void*);//  任务结构体template &lt;typename T&gt;struct  Task&#123;    Task&lt;T&gt;()&#123;        function = nullptr;        arg = nullptr;    &#125;    Task&lt;T&gt;(callback f, void* arg)&#123;        function = f;        this-&gt;arg = (T*)arg;    &#125;    callback function;    T* arg;&#125;;template &lt;typename T&gt;class TaskQueue&#123;public:    TaskQueue();    ~TaskQueue();    // 取出一个任务    Task&lt;T&gt; getTask();    // 添加一个任务    void addTask(Task&lt;T&gt;&amp; task);    void addTask(callback f, void* arg);    //重载    inline int taskNumber()&#123;        return m_taskQ.size();    &#125;private:    pthread_mutex_t m_mutex;    queue&lt;Task&lt;T&gt;&gt; m_taskQ; &#125;;\n\nThreadPool.cpp#include &quot;ThreadPool.h&quot;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;using namespace std;template &lt;typename T&gt;ThreadPool&lt;T&gt;::ThreadPool(int min, int max)&#123;       do&#123;        // 实例化任务对列        taskQ = new TaskQueue&lt;T&gt;;        if(taskQ == nullptr)&#123;            cout&lt;&lt;&quot;malloc taskQ fail...&quot;&lt;&lt;endl;            break;        &#125;        minNum = min;        maxNum = max;        busyNum = 0;        liveNum = min;    //与最小个数相等        exitNum = 0;        threadIDs = new pthread_t[max];        if(threadIDs == nullptr)&#123;            cout&lt;&lt;&quot;malloc threadIDS  fail...&quot;&lt;&lt;endl;            break;        &#125;        if(pthread_mutex_init(&amp;mutexPool,NULL) != 0 || pthread_cond_init(&amp;notEmpty,NULL)  != 0)&#123;            printf(&quot;mutex or condition init fail...\\n&quot;);            break;        &#125;        shutdown = false;         //创建线程        pthread_create(&amp;managerID,NULL,manager,this);        for(int i = 0; i &lt; min; i++)&#123;            pthread_create(&amp;threadIDs[i],NULL,worker,this);        &#125;    &#125;while(0);&#125;template &lt;typename T&gt;ThreadPool&lt;T&gt;::~ThreadPool()&#123;    // 关闭线程池    shutdown = 1;    // 阻塞回收管理者线程(销毁管理者线程)    pthread_join(managerID,NULL);    // 唤醒阻塞的消费者线程    for(int i = 0; i &lt; liveNum; i++)&#123;        pthread_cond_signal(&amp;notEmpty);    &#125;    if(taskQ)&#123;        delete taskQ;    &#125;    if(threadIDs)&#123;        delete[] threadIDs;    &#125;    // 销毁锁和条件变量    pthread_mutex_destroy(&amp;mutexPool);    pthread_cond_destroy(&amp;notEmpty);      &#125;template &lt;typename T&gt;void ThreadPool&lt;T&gt;::threadPoolAddTask(Task&lt;T&gt; task)&#123;    if(shutdown)&#123;        //pthread_mutex_unlock(&amp;mutexPool);        return ;    &#125;    // 添加任务    taskQ-&gt;addTask(task);    // 唤醒工作的线程    pthread_cond_signal(&amp;notEmpty);    &#125;template &lt;typename T&gt;int ThreadPool&lt;T&gt;::getBusyNum()&#123;    pthread_mutex_lock(&amp;mutexPool);    int busyNum = this-&gt;busyNum;    pthread_mutex_unlock(&amp;mutexPool);    return busyNum;&#125;template &lt;typename T&gt;int ThreadPool&lt;T&gt;::getAliveNum()&#123;    pthread_mutex_lock(&amp;mutexPool);    int liveNum = this-&gt;liveNum;    pthread_mutex_unlock(&amp;mutexPool);    return liveNum;&#125;template &lt;typename T&gt;// 消费者线程void* ThreadPool&lt;T&gt;::worker(void* arg)&#123;    ThreadPool* pool = (ThreadPool*)arg;    while(1)&#123;        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        // 当前任务队列是否为空        while (pool-&gt;taskQ-&gt;taskNumber() == 0 &amp;&amp; !pool-&gt;shutdown)        &#123;            // 阻塞工作线程（阻塞消费者）            pthread_cond_wait(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool);                    // 判断是不是要销毁线程            if(pool-&gt;exitNum &gt; 0)&#123;                pool-&gt;exitNum--;                if(pool-&gt;liveNum &gt; pool-&gt;minNum)&#123;                    pool-&gt;liveNum--;                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);    // 销毁前，先解锁，防止死锁                    pool-&gt;threadExit();                &#125;                                //pthread_exit(NULL);            &#125;        &#125;                // 判断线程池是否被关闭        if(pool-&gt;shutdown)&#123;            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);     //防止死锁            pool-&gt;threadExit();            //pthread_exit(NULL);        &#125;        // 从队列中取出一个任务        Task&lt;T&gt; task = pool-&gt;taskQ-&gt;getTask();                //解锁       // pthread_cond_signal(&amp;pool-&gt;notFull);    //唤醒生产者       //开始工作        printf(&quot;thread %ld  start working...\\n&quot;,pthread_self());       // pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        pool-&gt;busyNum++;       // pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);                //调用任务里的函数        task.function(task.arg);        //参数建议传堆内存        //(*task.function)(task.arg);   //另一种写法        delete task.arg;        task.arg = nullptr;        printf(&quot;thread %ld  end working...\\n&quot;,pthread_self());        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        pool-&gt;busyNum--;        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);    &#125;    return NULL;&#125;template &lt;typename T&gt;void* ThreadPool&lt;T&gt;::manager(void* arg)&#123;    ThreadPool* pool = (ThreadPool*)arg;    while(!pool-&gt;shutdown)&#123;        // 每3s检测一次        sleep(3);        // 取出线程池中日任务的数量和当前线程的数量        pthread_mutex_lock(&amp;pool-&gt;mutexPool);        int queueSize = pool-&gt;taskQ-&gt;taskNumber();        int liveNum = pool-&gt;liveNum;        // 取出忙的线程的数量        // pthread_mutex_lock(&amp;pool-&gt;mutexBusy);        int busyNum = pool-&gt;busyNum;        // pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);                               //添加线程        //自定义规则：任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程个数 &lt; 线程的最大个数        if(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)&#123;            pthread_mutex_lock(&amp;pool-&gt;mutexPool);            int count = 0;            for(int i = 0; i &lt; pool-&gt;maxNum &amp;&amp; count &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)&#123;                if(pool-&gt;threadIDs[i] == 0)&#123;                    pthread_create(&amp;pool-&gt;threadIDs[i],NULL,worker,pool);                    count++;                    pool-&gt;liveNum++;                &#125;            &#125;             pthread_mutex_unlock(&amp;pool-&gt;mutexPool);        &#125;        //销毁线程        //自定义规则：忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程 &gt; 最小线程数        if(busyNum * 2 &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)&#123;            pthread_mutex_lock(&amp;pool-&gt;mutexPool);            pool-&gt;exitNum = NUMBER;            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);            // 让工作的线程自杀            for(int i = 0; i &lt; NUMBER; ++i)&#123;                // 唤醒工作线程                pthread_cond_signal(&amp;pool-&gt;notEmpty);            &#125;                &#125;    &#125;    return NULL;&#125;template &lt;typename T&gt;// 线程退出void ThreadPool&lt;T&gt;::threadExit()&#123;    pthread_t tid = pthread_self();    for (int i = 0; i &lt; maxNum; ++i)    &#123;        if (threadIDs[i] == tid)        &#123;            cout &lt;&lt; &quot;threadExit() function: thread &quot;                 &lt;&lt; to_string(pthread_self()) &lt;&lt; &quot; exiting...&quot; &lt;&lt; endl;            threadIDs[i] = 0;            break;        &#125;    &#125;    pthread_exit(NULL);&#125;\n\nThreadPool.h#pragma once#include &quot;TaskQueue.h&quot;#include &quot;TaskQueue.cpp&quot;template &lt;typename T&gt;class ThreadPool&#123;   public:           //  创建线程池并初始化     ThreadPool(int min, int max);    //  销毁线程池    ~ThreadPool();    //  给线程池添加任务    void threadPoolAddTask(Task&lt;T&gt; task);    //  获取线程池中工作的线程的个数    int  getBusyNum();    //  获取线程池中活着的线程的个数    int getAliveNum();    //////private:    static void* worker(void* arg);    static void* manager(void* arg);    void threadExit();    //////private:    //任务队列    TaskQueue&lt;T&gt; *taskQ;    //管理者线程    pthread_t   managerID;  //管理者线程ID    //工作线程    pthread_t   *threadIDs; //工作的线程ID    int minNum;     //最小线程数量    int maxNum;     //最大线程数量    int busyNum;    //忙的线程个数    int liveNum;    //存活的线程个数    int exitNum;    //要销毁的线程个数    //互斥锁    pthread_mutex_t mutexPool;  //锁整个的线程池    //条件变量    pthread_cond_t notEmpty;    //任务队列是不是空了    bool shutdown = false;   //是不是要销毁线程池，销毁为1，不销毁为0    static const int NUMBER = 2;&#125;;\n\n","categories":["笔记"],"tags":["c++","linux","c","网络编程","线程池"]},{"title":"指针和引用的区别","url":"/2023/12/20/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"指针和引用的区别指针和引用是C++中的两个重要概念，它们都可以用于间接访问对象或变量。下面是它们的区别：\n\n定义和使用方式：指针使用*来声明和解引用，而引用使用&amp;来声明，不需要解引用。\n空值：指针可以为空（nullptr），表示没有指向任何对象或变量，而引用必须始终引用有效的对象。\n可变性：指针本身可以重新赋值为另一个地址，即改变所指向的对象或变量；而引用一旦初始化后就不能再改变所引用的对象。\n对象关系：指针可以指向多个不同类型的对象，并且可以通过运算符修改所指向对象的值；而引用始终与特定类型的对象相关联，并且无法更改为引用其他类型的对象。\n空间占用：通常情况下，指针需要占据内存空间来存储地址信息；而引用本质上只是原对象的一个别名，并不需要额外的空间。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"每日一题（汇总版）","url":"/2023/11/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E6%B1%87%E6%80%BB%E7%89%88%EF%BC%89/","content":"每日一题1. 虚函数1.1 什么是虚函数虚函数是在基类中声明的，而在派生类中进行重写的函数。通过使用virtual关键字声明一个函数为虚函数，它使得在运行时能够动态地确定调用的是哪个版本的函数。\nclass Base &#123;public:    virtual void show() &#123;        std::cout &lt;&lt; &quot;Base class\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    void show() override &#123;        std::cout &lt;&lt; &quot;Derived class\\n&quot;;    &#125;&#125;;\n\n1.2 虚函数的作用\n实现多态性（Polymorphism）：允许通过基类指针或引用调用派生类对象的函数，根据实际对象的类型选择相应的函数实现。\n运行时绑定（Runtime Binding）：虚函数通过表格（虚函数表）的方式实现，使得在运行时动态地绑定函数调用。\n\n1.3 虚函数表（vtable）每个含有虚函数的类都有一个虚函数表，其中存储了虚函数的地址。对象的内存布局中包含一个指向虚函数表的指针。派生类的虚函数表包含基类的虚函数表，并在适当的位置添加或替换新的虚函数地址。\n1.4 纯虚函数纯虚函数是一个在基类中声明但没有提供实现的虚函数，它通过在声明中使用 &#x3D; 0 来标识。类含有纯虚函数的类被称为抽象类，不能被实例化。派生类必须实现纯虚函数，否则也会变为抽象类。\nclass AbstractBase &#123;public:    virtual void pureVirtualFunction() = 0;&#125;;\n\n1.5 虚析构函数如果基类的析构函数是虚函数，当通过基类指针删除派生类对象时，会调用派生类的析构函数。这是为了确保正确的对象销毁。\nclass Base &#123;public:    virtual ~Base() &#123;        std::cout &lt;&lt; &quot;Base destructor\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    ~Derived() override &#123;        std::cout &lt;&lt; &quot;Derived destructor\\n&quot;;    &#125;&#125;;\n\n内存对齐什么是内存对齐内存对齐是指在分配内存时，数据存储在内存中的起始地址是按照一定的规则对齐的。\n假设现在CPU是按照每4个字节来访问内存，有地址0、和地址1，现在要存1个char变量（假设char变量占1字节）和1个int变量（假设int变量占4字节），那么可以有内存对齐和内存不对齐的存储方式，如下图：\n\n假如不采用内存对齐的方式存储数据，那么CPU需要访问地址0和地址1，再进行合并，才能得到最终的结果；采用内存对齐的方式进行存储数据的话，则只需访问地址1就可以得到最终的结果。因此，采用内存对齐的存储方式可以减少CPU的访问运行时间，缺点是没有充分利用存储空间。\n对齐规则数据是根据初始化的顺序存储的，先定义的先储存，存储地址需要是sizeof(数据变量)的整数倍。\n例如，假设sizeof(char) = 1，sizeof(int) = 4，sizeof(int) = 4，sizeof(double) = 8。结构的对齐规则是要先确定对齐字节数（对齐字节数&#x3D;结构体中的变量占用空间最大的那个字节数，下面的结构体t3、t4就是sizeof(double) = 8），然后再保证存储地址是sizeof(数据变量)的整数倍。\n#include &lt;iostream&gt;using namespace std;struct t1&#123;    char a;    short c;    int x;    char b;&#125;;struct t2&#123;    int x;    char b;    char c;    short a;&#125;;struct t3&#123;    short a;    double c;    int x;    char b;&#125;;struct t4&#123;    char a, b;    int x;    double c;&#125;;int main()&#123;        cout &lt;&lt; sizeof(t1) &lt;&lt; endl; //12    cout &lt;&lt; sizeof(t2) &lt;&lt; endl; //8    cout &lt;&lt; sizeof(t3) &lt;&lt; endl; //24    cout &lt;&lt; sizeof(t4) &lt;&lt; endl; //16    return 0;&#125;\n\n\n在C&#x2F;C++中，内存对齐是由编译器负责的。编译器会按照平台的要求为数据进行对齐，通常会将数据按照其自身大小对齐到特定字节的倍数。这个特定字节的倍数通常由平台决定，例如，在32位系统中可能是4字节，而在64位系统中可能是8字节。\nC&#x2F;C++中可以使用一些特殊的关键字或编译器指令来控制内存对齐，例如：alignas关键字：C++11引入了alignas关键字，用于指定对齐方式。\nalignas(16) struct MyStruct &#123;    // 结构体成员&#125;;\n\n作用\n提高访问速度：许多计算机体系结构要求数据按照特定的边界地址存储，而不是任意地址。当数据被按照这些边界对齐时，处理器能够更快地访问这些数据，提高数据存取速度。\n硬件要求：一些硬件平台对于特定类型的数据要求按照一定的对齐方式存储，不遵循这个规则可能导致硬件异常或性能下降。\n减少浪费：内存对齐可以减少内存碎片，提高内存利用率。\n\nstrlen 和 sizeof的区别sizeof是C语言中的一个单目运算符，用来计算数据类型所占空间的大小，单位为字节；而strlen是一个函数，用来计算字符串长度。简单来说，就是sizeof不包含\\0,而strlen包含\\0。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;\tchar arr1[]=&quot;abcd&quot;;//d的后面自动补上\\0;\tchar arr2[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;//以单个元素赋值，没有\\0的结束符\tprintf(&quot;strlen1=%d\\n&quot;,strlen(arr1));//strlen()计算\\0之前的字符长度\tprintf(&quot;strlen2=%d\\n&quot;,strlen(arr2));//该处计算结果应为随机值，因为arr2[]没定义元素个数，就无法知道在哪能遇到\\0;\tprintf(&quot;sizeof1=%d\\n&quot;,sizeof(arr1));//计算了包含\\0的数据空间大小\tprintf(&quot;sizeof2=%d\\n&quot;,sizeof(arr2));\treturn 0; &#125; \n\nstrlen1=4strlen2=8sizeof1=5sizeof2=4\n\nLinux中kill 、kill -15、kill -9 的区别kill（不加 -* 默认kill -15）命令\n系统会发送一个SIGTERM信号给对应的程序。当程序接收到该signal信号后，将会发生以下事情：\n\n程序立刻停止\n当程序释放相应资源后再停止\n程序可能仍然继续运行\n\n大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应），也就是说，**SIGTERM有可能是会被阻塞的**。\nkill -9命令\n系统给对应程序发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。\n\n在使用kill -9 前，应该先使用 kill -15，给目标进程一个清理善后工作的机会。如果没有，可能会留下一些不完整的文件或状态，从而影响服务的再次启动。\n\nkill -9这个信号可以捕获吗kill -9命令用于发送SIGKILL信号给指定的进程，强制终止该进程。SIGKILL是一个无法捕获或阻止的信号，它会立即终止目标进程，不给进程做清理或善后工作的机会。\nLinux中最大socket数量linux系统默认ulimit为1024个访问，用户最多可开启的程序数目。一般一个端口的最高连接为2的16次方65535。\n查看全局文件句柄数限制(系统支持的最大值)\ncat /proc/sys/fs/file-max\n\n查看每个进程文件句柄数限制\nulimit -n\n\n如何修改最大连接数量870-Linux下解决高并发socket最大连接数限制_socket 连接数_林林林ZEYU的博客-CSDN博客\nC++迭代器和指针的区别？\n范围：指针属于迭代器的一种（指针可以用来遍历容器[数组]），迭代器使用后就释放了，不能再继续使用，指针能；指针能指向函数，迭代器不行，只能指向容器\n功能：迭代器有着比指针更细的划分并对应能力不同的功能（重载不同的运算符）\n行为：迭代器比指针更统一和良好的用法（更轻易使用begin()和end()，不用担心越界）。\n\n为什么需要迭代器？\n抽象层次： 迭代器提供了对容器元素的高层次抽象，允许使用一致的方式遍历不同类型的容器，而不用关心底层实现。\n安全性： 使用迭代器可以减少指针错误的可能性，因为迭代器受到容器的保护，不容易越界访问或访问非法内存。\n容器封装： 迭代器为容器提供了一种封装，允许容器实现者更灵活地改变底层数据结构，而不会对使用容器的代码产生影响。\n\nsprintf与snprintf区别int sprintf(char *str, const char &amp;format, ...);\n\nsprintf是字符串格式化命令，主要功能是把格式化的数据写入字符串str中，返回值为写入str的字节数，结束字符\\0不计入内。其中， str是指要写入的缓冲区，format控制要写入str中数据的格式，例如%s、%d、%x等。\nint snprintf(char *str, size_t size, const char *format, ...);\n\nsnprintf是字符串格式化命令，主要功能是把格式化的数据写入字符串str中，最多写size个字节，包括自动添加在字符串末尾处的结束字符\\0;返回值为写入str的字节数，**包括结束字符\\0**。\nsprintf函数返回的是实际输出到字符串缓冲中的字符个数,而snprintf函数返回的是应该输出到字符串缓冲的字符个数\n#define snprintf_nowarn(...) (snprintf(__VA_ARGS__) &lt; 0 ? abort() : (void)0)\n\n该宏用于调用 snprintf 函数，并检查其返回值是否小于 0。snprintf 函数是一个安全的字符串格式化函数，用于将格式化的数据写入字符串。这里的目的是在调用 snprintf 时，如果返回值小于 0，就调用 abort() 函数，中止程序运行，以防止潜在的错误。\nC语言中”#”和”##”的用法#把宏参数变为一个字符串\n##把两个宏参数贴合在一起\n#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;#define STR(s)     #s#define CONS(a,b)  int(a##e##b)int main()&#123;   printf(STR(abc));           // 输出字符串&quot;abc&quot;   printf(&quot;\\n&quot;);   printf(&quot;%d\\n&quot;, CONS(2,3));  // 2e3 输出:2000   return 0;&#125;\n\nabc2000\n\n当宏参数是另一个宏的时候，需要注意的是凡宏定义里有用#或##的地方宏参数是不会再展开。 只有当前宏生效, 参数里的宏不会生效 ！！！\n\n\n当宏参数是另一个宏的时候，需要注意的是凡宏定义里有用`#`或`##`的地方宏参数是不会再展开。 只有当前宏生效, 参数里的宏不会生效 ！！！\n\n举例\n#define A          (2)#define STR(s)     #s#define CONS(a,b)  int(a##e##b)printf(&quot;int max: %s\\n&quot;,  STR(INT_MAX));    // INT_MAX ＃include&lt;climits&gt;printf(&quot;%s\\n&quot;, CONS(A, A));                // compile error --- int(AeA)\n\n两句printf会被展开为：\nprintf(&quot;int max: %s\\n&quot;,&quot;INT_MAX&quot;);printf(&quot;%s\\n&quot;, int(AeA));\n\n分析\n由于A和INT_MAX均是宏，且作为宏CONS和STR的参数，并且宏CONS和STR中均含有#或者##符号，所以A和INT_MAX均不能被解引用。导致不符合预期的情况出现。\n\n\n解决这个问题的方法很简单。 加多一层中间转换宏。 加这层宏的用意是把所有宏的参数在这层里全部展开,\n那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数。\n\n\n#define A           (2)#define _STR(s)     #s#define STR(s)      _STR(s)          // 转换宏#define _CONS(a,b)  int(a##e##b)#define CONS(a,b)   _CONS(a,b)       // 转换宏\n\n#include&lt;cstdio&gt;#include&lt;climits&gt;using namespace std;#define A           2#define _STR(s)     #s#define STR(s)      _STR(s)          // 转换宏#define _CONS(a,b)  int(a##e##b)#define CONS(a,b)   _CONS(a,b)       // 转换宏int main()&#123;   printf(STR(INT_MAX));           // 输出字符串&quot;abc&quot;   printf(&quot;\\n&quot;);   printf(&quot;%d\\n&quot;, CONS(A,A));  // 2e3 输出:2000   return 0;&#125;\n\n0x7fffffff200\n\nvector怎么扩容在 C++ 的标准库中，std::vector 是一个动态数组，其扩容是通过重新分配内存来实现的。当 std::vector 的元素数量达到当前分配的内存大小时，系统会为std::vector分配一块更大的内存，并将原来的元素复制到新的内存中。这个过程中原来的内存会被释放。\nstd::vector 扩容的基本步骤：\n\n分配新的内存：当 std::vector 中的元素个数达到当前分配的内存大小时，需要分配一块新的内存。新的内存大小通常是当前内存大小的两倍(Linux端），(Windows是1.5倍），这样做是为了保证std::vector的操作复杂度为平摊 O(1)。\n将元素复制到新内存：将原来的元素逐个复制到新分配的内存中。\n释放旧内存：释放原来的内存空间。\n\n信号量和互斥锁有什么区别信号量用于线程的同步，互斥锁用于线程的互斥。\n信号量值可以为非负整数，互斥锁值只能为0&#x2F;1。\n信号量可以由一个线程释放，另一个线程得到，互斥锁的加锁和解锁必须由同一线程分别对应使用。\n信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这个资源。\n\n\ndefine 和 const 区别对于 define 来说， 宏定义实际上是在预编译阶段进行处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进行字符串的展开，遇到多少次就展开多少次，而且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为define宏定义仅仅是展开，因此运行时系统并不为宏定义分配内存，（但是从汇编的角度来讲，define却以立即数的方式保留了多份数据的拷贝）。\n对于 const 来说， const 是在编译期间进行处理的，const 有类型，也有类型检查，程序运行时系统会为 const 常量分配内存，而且从汇编的角度讲，const 常量在出现的地方保留的是真正数据的内存地址，只保留了一份数据的拷贝，省去了不必要的内存空间。而且，有时编译器不会为普通的const常量分配内存，而是直接将const常量添加到符号表中，省去了读取和写入内存的操作，效率更高。\n野(wild)指针与悬空(dangling)指针有什么区别？如何避免？野指针(wild pointer)：就是没有被初始化过的指针。用 gcc -Wall 编译, 会出现 used uninitialized警告。\n悬空指针：是指针最初指向的内存已经被释放了的一种指针。\n无论是野指针还是悬空指针，都是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针。 访问”不安全可控”(invalid)的内存区域将导致”Undefined Behavior”。\n如何避免使用野指针？\n在平时的编码中，养成在定义指针后且在使用之前完成初始化的习惯或者使用智能指针。\n实现多态的方法多态其实一般就是指继承加虚函数实现的多态，对于重载来说，实际上基于的原理是，编译器为函数生成符号表时的不同规则，重载只是一种语言特性，与多态无关，与面向对象也无关，但这又是 C++中增加的新规则，所以也算属于 C++，所以如果非要说重载算是多态的一种，那就可以说：多态可以分为静态多态和动态多态。\n静态多态其实就是重载，因为静态多态是指在编译时期就决定了调用哪个函数，根据参数列表来决定；\n动态多态是指通过子类重写父类的虚函数来实现的，因为是在运行期间决定调用的函数，所以称为动态多态，\n一般情况下我们不区分这两个时所说的多态就是指动态多态。\n动态多态的实现与虚函数表，虚函数指针相关。\n子类是否要重写父类的虚函数？\n子类继承父类时， 父类的纯虚函数必须重写，否则子类也是一个虚类不可实例化。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。\n\n\nnew &#x2F; delete malloc &#x2F; free 区别都可以用来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。\n执行 new 实际上执行两个过程：\n\n分配未初始化的内存空间（malloc）；\n\n使用对象的构造函数对空间进行初始化；返回空间的首地址。\n\n\n如果在第一步分配空间中出现问题，则抛出std::bad_alloc异常，或被某个设定的异常处理函数捕获处理；如果在第二步构造对象时出现异常，则自动调用delete释放内存。\n\n\n执行 delete 实际上也有两个过程：\n\n使用析构函数对对象进行析构；\n回收内存空间（free）。\n\n以上也可以看出new和 malloc 的区别，new 得到的是经过初始化的空间，而malloc得到的是未初始化的空间。所以 new 是 new 一个类型，而 malloc 则是malloc一个字节长度的空间。delete 和 free同理，delete不仅释放空间还析构对象，delete 一个类型，free 一个字节长度的空间。\n\n\n为什么有了 malloc／free ,还需要 new／delete？ \n因为对于非内部数据类型而言，光用 malloc／free 无法满足动态对象的要求。对象在创建的同时需要自动执行构造函数，对象在消亡以前要自动执行析构函数。由于 mallo／free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于 malloc／free，所以有了new／delete操作符。\n内存泄漏的定义，如何检测与避免定义：内存泄漏简单的说就是申请了一块内存空间，使用完毕后没有释放掉。 它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。\n如何检测内存泄漏\n\n首先可以通过观察猜测是否可能发生内存泄漏，Linux 中使用swap 命令观察还有多少可用的交换空间，在一两分钟内键入该命令三到四次，看看可用的交换区是否在减少。\n还可以使用 其他一些 /usr/bin/stat 工具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，一个可能的解释就是有个进程出现了内存泄漏。\n当然也有用于内存调试，内存泄漏检测以及性能分析的软件开发工具 valgrind 这样的工具来进行内存泄漏的检测。\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"虚函数","url":"/2023/11/15/%E8%99%9A%E5%87%BD%E6%95%B0/","content":"1. 虚函数1.1 什么是虚函数虚函数是在基类中声明的，而在派生类中进行重写的函数。通过使用virtual关键字声明一个函数为虚函数，它使得在运行时能够动态地确定调用的是哪个版本的函数。\nclass Base &#123;public:    virtual void show() &#123;        std::cout &lt;&lt; &quot;Base class\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    void show() override &#123;        std::cout &lt;&lt; &quot;Derived class\\n&quot;;    &#125;&#125;;\n\n1.2 虚函数的作用\n实现多态性（Polymorphism）：允许通过基类指针或引用调用派生类对象的函数，根据实际对象的类型选择相应的函数实现。\n运行时绑定（Runtime Binding）：虚函数通过表格（虚函数表）的方式实现，使得在运行时动态地绑定函数调用。\n\n1.3 虚函数表（vtable）每个含有虚函数的类都有一个虚函数表，其中存储了虚函数的地址。对象的内存布局中包含一个指向虚函数表的指针。派生类的虚函数表包含基类的虚函数表，并在适当的位置添加或替换新的虚函数地址。\n1.4 纯虚函数纯虚函数是一个在基类中声明但没有提供实现的虚函数，它通过在声明中使用 &#x3D; 0 来标识。类含有纯虚函数的类被称为抽象类，不能被实例化。派生类必须实现纯虚函数，否则也会变为抽象类。\nclass AbstractBase &#123;public:    virtual void pureVirtualFunction() = 0;&#125;;\n\n1.5 虚析构函数如果基类的析构函数是虚函数，当通过基类指针删除派生类对象时，会调用派生类的析构函数。这是为了确保正确的对象销毁。\nclass Base &#123;public:    virtual ~Base() &#123;        std::cout &lt;&lt; &quot;Base destructor\\n&quot;;    &#125;&#125;;class Derived : public Base &#123;public:    ~Derived() override &#123;        std::cout &lt;&lt; &quot;Derived destructor\\n&quot;;    &#125;&#125;;\n\n","categories":["每日一题"],"tags":["c++"]},{"title":"解析Http协议","url":"/2023/10/20/%E8%A7%A3%E6%9E%90Http%E5%8D%8F%E8%AE%AE/","content":"在写webSever时了解了一点关于http协议的内容，更方便后面的学习\n\nHTTP(hypertext transport protocol 超文本传输协议）：一种无状态的，以请求&#x2F;应答方式运行的协议，它使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。\n1. http请求http请求消息分为四部分1. 请求行\t不管是get请求还是post请求，请求行分为三部分2. 请求头3. 空行4. 客户端想服务器提交的数据\n\nGET /doing HTTP/1.1Host: 10.1.18.4User-Agent: Mozilla/5.0 (Windows NT 6.2; rv:40.0) Gecko/20100101 Firefox/40.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://10.1.18.4/Connection: keep-alive\n\n1. 请求行\tGET /doing HTTP/1.1三部分：请求方式\t请求的资源（/不代表服务器根目录，是服务器给客户端提供的资源目录）\t        HTTP协议版本\t还有看不见的\\r\\n2. 请求头\t若干个键值对Host: 10.1.18.4User-Agent: Mozilla/5.0 (Windows NT 6.2; rv:40.0) Gecko/20100101 Firefox/40.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://10.1.18.4/Connection: keep-alive\n\n\nget\n\n提交的数据,不安全,提交的数据会显示到地址栏中，被别人看到之后，数据就泄露了\n图中的 userid和roomid 就是浏览器向服务器提交的数据地址栏中的数据会放到某块缓冲中，地址栏对应的缓存是有上限的,在几k左右\n\n\npost\n\n提交的数据并不会显示到地址栏中,完全不可见的，因此更安全\n\n\n\n\n请求行，用来说明请求类型，要访问的资源以及所使用的http版本。get说明请求类型为get，该行的最后一部分说明使用的是http 1.1版本\n\n请求头，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。从第二行起为请求头部，host将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它，它是客户端类型检测逻辑的重要基础。该信息由你的客户端来定义，并且在每个请求中自动发送等。\n\n空行，请求头部后面的空行是必须的。即使第四部分的请求数据为空，也必须有空行。\n\n请求数据也叫主体，可以添加任意的其他数据，上面的请求数据为空。\n\n\n1.2 http响应\n状态行，由http协议版本号， 状态码， 状态消息三部分组成。上面http版本号为http/1.1，状态码为200，状态消息为”OK”。\n消息报头，用来说明客户端要使用的一些附加信息。Date：生成响应的日期和时间；Content-Type：指定了MIME类型的html(text/html)，编码类型是UTF-8。\n空行，消息报头后面的空行是必须的。\n响应正文，服务器返回给客户端的文本信息，空行后面的html部分为响应正文。\n\n1.3 http状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:\n1xx:指示信息--表示请求已接收，继续处理2xx:成功--表示请求已被成功接收、理解、接受3xx:重定向--要完成请求必须进行更进—步的操作(网络地址的重新访问)4xx:客户端错误--请求有语法错误或请求无法实现5xx:服务器端错误--服务器未能实现合法的请求\n\n常见状态码\n200 OK\t客户端请求成功400 Bad Request客户端请求有语法错误，不能被服务器所理解401 Unauthorized请求未经授权，这个状态代码必须和Www-Authenticate报头域一起使用403 Forbidden 服务器收到请求，但是拒绝提供服务404 Not Found 请求资源不存在，eg:输入了错误的URL500 Internal Server Error服务器发生不可预期的错误503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常\n","categories":["笔记"],"tags":["http"]},{"title":"野(wild)指针与悬空(dangling)指针有什么区别？如何避免？","url":"/2023/11/24/%E9%87%8E-wild-%E6%8C%87%E9%92%88%E4%B8%8E%E6%82%AC%E7%A9%BA-dangling-%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F/","content":"野(wild)指针与悬空(dangling)指针有什么区别？如何避免？野指针(wild pointer)：就是没有被初始化过的指针。用 gcc -Wall 编译, 会出现 used uninitialized警告。\n悬空指针：是指针最初指向的内存已经被释放了的一种指针。\n无论是野指针还是悬空指针，都是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针。 访问”不安全可控”(invalid)的内存区域将导致”Undefined Behavior”。\n如何避免使用野指针？\n在平时的编码中，养成在定义指针后且在使用之前完成初始化的习惯或者使用智能指针。\n","categories":["每日一题"],"tags":["c++"]},{"title":"长连接和短连接的区别","url":"/2023/12/21/%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"长连接和短连接的区别长连接：客户端与服务端先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。\n短连接：客户端与服务端每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。\n短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接长连接的操作步骤是：建立连接——数据传输…（保持连接）…数据传输——关闭连接\n长连接多⽤于操作频繁，点对点的通讯，⽽且连接数不能太多情况。每个 TCP 连接都需要三步握⼿，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多， 所以每个操作完后都不断开，下次处理时直接发送数据包就 OK 了，不⽤建⽴ TCP 连接。\n例如： 数据库的连接⽤长连接， 如果⽤短连接频繁的通信会造成 socket 错误，⽽且频繁的 socket创建也是对资源的浪费。\n⽽像 WEB ⽹站的 http 服务⼀般都⽤短链接，因为长连接对于服务端来说会耗费⼀定的 资源，⽽像 WEB ⽹站这么频繁的成千上万甚⾄上亿客户端的连接⽤短连接会更省⼀些资源， 如果⽤长连接，⽽且同时有成千上万的⽤户，如果每个⽤户都占⽤⼀个连接的话，那可想⽽知吧。所以并发量⼤，但每个⽤户⽆需频繁操作情况下需⽤短连接。\n","categories":["每日一题"],"tags":["c++"]}]