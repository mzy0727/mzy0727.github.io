
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>使用Qt开发工作上的需求 | Hexo</title>
    <meta name="author" content="Mzy" />
    <meta name="description" content="mzy的成长历程" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>HEXO</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;HEXO</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>使用Qt开发工作上的需求</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/10/26
        </span>
        
        <span class="category">
            <a href="/categories/%E7%AC%94%E8%AE%B0/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                笔记
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/c/" style="color: #ffa2c4">c++</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Qt/" style="color: #ff7d73">Qt</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>记录最近工作设及到一些关于qt编程的相关内容</p>
<span id="more"></span>

<h3 id="功能1：鼠标点击图片显示坐标和像素"><a href="#功能1：鼠标点击图片显示坐标和像素" class="headerlink" title="功能1：鼠标点击图片显示坐标和像素"></a>功能1：鼠标点击图片显示坐标和像素</h3><p>最近工作设及到一些关于qt编程的工作，主要内容就是在一个<code>QGraphicsView</code>上显示了一个<code>QGraphicsPixmapItem</code>的相机监控的图片，并用鼠标点击图片显示坐标和像素。</p>
<p>最初在网上找到的解决方案是重写<code>mousePressEvent()</code>方法</p>
<pre><code class="c++">void ImgHelper::mousePressEvent(QGraphicsSceneMouseEvent* event)
&#123;
    std::cout &lt;&lt; &quot;Item: (&quot; &lt;&lt; event-&gt;scenePos().x() &lt;&lt; &quot;, &quot; &lt;&lt; event-&gt;scenePos().y() &lt;&lt; &#39;)&#39; &lt;&lt; std::endl; 
&#125;
</code></pre>
<p>测试发现未响应鼠标事件，网上找到说：重写鼠标点击事件函数时发现鼠标点击事件在子类化后的<code>QGraphicsScene</code>中被响应，但是子类化后的<code>QGraphicsPixmapItem</code>无法响应。<code>QGraphicsView</code>的事件传递机制的顺序是<code>View-&gt;Scene-&gt;Item</code>，也就是说事件被子类化的<code>QGraphicsScene</code>吞没了，没有传递到下一级的<code>item</code>。<br>解决方案，在子类化的<code>QGraphicsScene</code>中重写<code>mousePressEvent()</code>方法内部一定要要记得调用：</p>
<pre><code class="c++">QGraphicsScene::mousePressEvent(event);
</code></pre>
<p>注意，要想返回图像坐标系的位置，就需要在子类化的<code>QGraphicsPixmapItem</code>中调用<code>scenePos()</code>函数。即使放大图像，点击图像中相同位置也会返回相同坐标结果。</p>
<p>结果发现还是没有反应，还有一种说法就是加上下面这句话</p>
<pre><code class="c++">//使能QGraphcisView控件的鼠标跟踪
view-&gt;setMouseTracking(true);
</code></pre>
<p>最后尝试把<code>mousePressEvent</code>函数在最上层的<code>mainwindow</code>中重写并使能鼠标，有效果，但是坐标并不是我想要的效果，现在的坐标系是整个界面的，我想要的是图像的坐标，然后能通过图像控件的位置和长宽进行筛选，但是获得的图像是经过qt自适应缩放在<code>600X600</code>的容器里的。</p>
<p>在一筹莫展的时候，突然看到<code>eventFilter</code>事件过滤器。</p>
<p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/20210320141253167.png" alt="在这里插入图片描述"></p>
<p>原本事件应该直接发送给“组件对象”，但是现在却先将事件发送给“过滤器对象”，经过过滤的事件再发给“组件对象”。</p>
<p><strong>事件过滤器的操作：</strong></p>
<ol>
<li>首先给需要添加事件过滤器的部件<strong>注册监听对象</strong>；<br><code>对象名-&gt;installEventFilter(true);</code></li>
<li>重写<code>eventFilter(QObject *obj, QEvent *event)</code>函数进行处理。<!-- more -->
首先使用参数<code>obj</code>进行与绑定的控件对象进行判断，是否与其相等；然后在使用参数<code>event-&gt;type()</code>的返回值与枚举鼠标或者键盘进行判断；最后将<code>event</code>转换为鼠标事件对象或者键盘对象事件，就可以进行操作了。</li>
</ol>
<pre><code class="c++">bool ImgHelper::eventFilter(QObject *watched, QEvent *event)
&#123;
    //判断信号是不是来自QGraphicsView
    if(watched == view-&gt;viewport())&#123;
        switch (event-&gt;type()) &#123;
        //鼠标移动事件
        case  QEvent::MouseMove:
        &#123;
            QMouseEvent *m_event = (QMouseEvent*)event;


            if(pixmapItem == NULL)&#123;
                break;
            &#125;

           // QPoint point = m_event-&gt;pos();

            QPixmap pix= pixmapItem-&gt;pixmap();
            QImage img = pix.toImage();
          //  QSize size = pixmapItem-&gt;pixmap().size();


            QPoint point = m_event-&gt;pos();
           // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
            // 坐标系转换 - 视图 -&gt; 场景
            QPointF scenePoint = view-&gt;mapToScene(point);
            //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
            // 坐标系转换 - 场景 -&gt; 图元
            QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);
           // qDebug()&lt;&lt;&quot;itempoint:&quot;&lt;&lt;itempoint&lt;&lt;endl;
            QString str;
            // 判断所选点是否在图像范围内
            if(itempoint.x()&gt;=0 &amp;&amp;itempoint.x()&lt;=pix.width() &amp;&amp; itempoint.y()&gt;=0 &amp;&amp; itempoint.y()&lt;= pix.height())&#123;
                QRgb pixColor = img.pixel(itempoint.x(),itempoint.y());
               // qDebug()&lt;&lt;pixColor&lt;&lt;&quot; &quot;&lt;&lt;qRed(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qGreen(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qBlue(pixColor)&lt;&lt;endl;
                str = QString(&quot;X:%1\nY:%2\nR:%3\nG:%4\nB:%5\n&quot;).arg(QString::number(itempoint.x(),&#39;f&#39;,1))
                                                                .arg(QString::number(itempoint.y(),&#39;f&#39;,1))
                                                                .arg(qRed(pixColor))
                                                                .arg(qGreen(pixColor))
                                                                .arg(qBlue(pixColor)).toLocal8Bit();
            &#125;
            else&#123;
                str = &quot;&quot;;
            &#125;
            img_xy_pix-&gt;setText(str);
            img_xy_pix-&gt;setStyleSheet(&quot;color:red;&quot;);
            break;
        &#125;
        // 鼠标点击事件
        case QEvent::MouseButtonPress:
        &#123;
            if(pixmapItem == NULL)&#123;
                break;
            &#125;
            QMouseEvent *m_event = (QMouseEvent*)event;
            // 左键点击确定起点
            if(m_event-&gt;button() == Qt::LeftButton )&#123;

             //   QPixmap pix= pixmapItem-&gt;pixmap();
                QPainter painter(view-&gt;viewport());
                painter.setPen(QPen(Qt::blue,1));
              //  QImage img = pix.toImage();
              //  QSize size = pixmapItem-&gt;pixmap().size();
               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;
                QPoint point = m_event-&gt;pos();
               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
                QPointF scenePoint = view-&gt;mapToScene(point);
                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);
                startPoint = itempoint;
                break;
            &#125;
            break;
        &#125;
        // 送开鼠标，确定终点
        case QEvent::MouseButtonRelease:
        &#123;
            if(pixmapItem == NULL)&#123;
                break;
            &#125;
            QMouseEvent *m_event = (QMouseEvent*)event;
            if(m_event-&gt;button() == Qt::LeftButton )&#123;

//                QPixmap pix= pixmapItem-&gt;pixmap();
                QPainter painter(view-&gt;viewport());
                painter.setPen(QPen(Qt::blue,1));
              //  QImage img = pix.toImage();
              //  QSize size = pixmapItem-&gt;pixmap().size();
               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;
                QPoint point = m_event-&gt;pos();
               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
                QPointF scenePoint = view-&gt;mapToScene(point);
                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);
                QPointF endPoint = itempoint;
                if(startPoint.x() != 0 &amp;&amp; startPoint.y() != 0)&#123;
                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());
                    painter.drawRect(rectangle);
                    painter.setPen(QPen(Qt::red,1));
                    rects = scene-&gt;addRect(rectangle,rectPen);
//                    float rectInfo[8];
//                    rectcounts++;
//                    rectInfo[0] = rectcounts;
//                    float x = (endPoint.x()-startPoint.x()) / 2 + startPoint.x();
//                    float y = (endPoint.y()-startPoint.y()) / 2 + startPoint.y();
//                    float height;
//                    float width;
//                    if(endPoint.x()-startPoint.x() &gt; endPoint.y()-startPoint.y())&#123;
//                       height = endPoint.x()-startPoint.x();
//                       width = endPoint.y()-startPoint.y();
//                    &#125;else&#123;
//                        width = endPoint.x()-startPoint.x();
//                        height = endPoint.y()-startPoint.y();
//                    &#125;
                 //   rectInfo[1] = x;
                 //   rectInfo[2] = y;
                 //   rectInfo[3] = height;
                 //      rectInfo[4] = width;
                  //  float angle = -90;
                 //   rectInfo[5] = angle;
//                    CassUdpHelper* udpClient = new CassUdpHelper(localPort, this);
                    
//                     bool flag = false;
  
//                    int rectCountsAddr = 353345520;
//                    flag = udpClient-&gt;writeBytesByModbus(rectCountsAddr, (char*)&amp;rectcounts, sizeof(short), hostIpAddr, hostPort);
//                    if(!flag) &#123;
//                        delete udpClient;
//                         break;
//                    &#125;
//                    int startAddr = 427778712;
//                    flag = udpClient-&gt;writeBytesByModbus(startAddr + sizeof(float)*8 *(rectcounts - 1), (char*)rectInfo, sizeof(float)*8, hostIpAddr, hostPort);
//                    if(!flag) &#123;
//                        delete udpClient;
//                         break;
//                    &#125;
//                    delete udpClient;
                    
                &#125;
                break;
            &#125;
            break;
        &#125;

        default:
            break;
        &#125;

    &#125;



    return false;
&#125;
</code></pre>
<h3 id="功能2：Qt拖动鼠标画一个矩形"><a href="#功能2：Qt拖动鼠标画一个矩形" class="headerlink" title="功能2：Qt拖动鼠标画一个矩形"></a>功能2：Qt拖动鼠标画一个矩形</h3><p>想要画一个矩形就需要过滤鼠标点击事件，鼠标按下时确定矩形的起点，然后拖动一段距离，松开确定终点。</p>
<!-- more -->
<pre><code class="c++">// 鼠标点击事件
        case QEvent::MouseButtonPress:
        &#123;
            if(pixmapItem == NULL)&#123;
                break;
            &#125;
            QMouseEvent *m_event = (QMouseEvent*)event;
            // 左键点击确定起点
            if(m_event-&gt;button() == Qt::LeftButton )&#123;

             //   QPixmap pix= pixmapItem-&gt;pixmap();
                QPainter painter(view-&gt;viewport());
                painter.setPen(QPen(Qt::blue,1));
              //  QImage img = pix.toImage();
              //  QSize size = pixmapItem-&gt;pixmap().size();
               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;
                QPoint point = m_event-&gt;pos();
               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
                QPointF scenePoint = view-&gt;mapToScene(point);
                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);
                startPoint = itempoint;
                break;
            &#125;
            break;
        &#125;
        // 送开鼠标，确定终点
        case QEvent::MouseButtonRelease:
        &#123;
            if(pixmapItem == NULL)&#123;
                break;
            &#125;
            QMouseEvent *m_event = (QMouseEvent*)event;
            if(m_event-&gt;button() == Qt::LeftButton )&#123;

//                QPixmap pix= pixmapItem-&gt;pixmap();
                QPainter painter(view-&gt;viewport());
                painter.setPen(QPen(Qt::blue,1));
              //  QImage img = pix.toImage();
              //  QSize size = pixmapItem-&gt;pixmap().size();
               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;
                QPoint point = m_event-&gt;pos();
               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
                QPointF scenePoint = view-&gt;mapToScene(point);
                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);
                QPointF endPoint = itempoint;
                if(startPoint.x() != 0 &amp;&amp; startPoint.y() != 0)&#123;
                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());
                    painter.drawRect(rectangle);
                    painter.setPen(QPen(Qt::red,1));
                    rects = scene-&gt;addRect(rectangle,rectPen);
</code></pre>
<p>这是在网上看到其他人重写的一个<code>QGraphicsRectItem</code>类，画出来的矩形可以拖动，变形，旋转，使用时只需要导入这个类</p>
<ul>
<li><p>mygraphicrectitem.h</p>
<!-- more -->
<pre><code class="c++">#ifndef MYGRAPHICRECTITEM_H
#define MYGRAPHICRECTITEM_H
#include &lt;QObject&gt;
#include &lt;QWidget&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QGraphicsScene&gt;
#include &lt;QGraphicsRectItem&gt;
#include &lt;QGraphicsSceneMouseEvent&gt;
#include &lt;QRect&gt;
#include &lt;QPainter&gt;
#include &lt;QPolygon&gt;
#include &lt;QList&gt;
enum STATE_FLAG&#123;
    DEFAULT_FLAG=0,
    MOV_LEFT_LINE,//标记当前为用户按下矩形的左边界区域
    MOV_TOP_LINE,//标记当前为用户按下矩形的上边界区域
    MOV_RIGHT_LINE,//标记当前为用户按下矩形的右边界区域
    MOV_BOTTOM_LINE,//标记当前为用户按下矩形的下边界区域
    MOV_RIGHTBOTTOM_RECT,//标记当前为用户按下矩形的右下角
    MOV_RECT,//标记当前为鼠标拖动图片移动状态
    ROTATE//标记当前为旋转状态
&#125;;
class myGraphicRectItem:public QObject,public QGraphicsItem
&#123;
    Q_OBJECT
public:
    myGraphicRectItem(QGraphicsItem *parent = nullptr);
    //myGraphicRectItem(QRectF m_OriginRect = QRectF(0,0,100,100));
    QRectF  boundingRect() const;
    ~myGraphicRectItem();
    void setRectSize(QRectF mrect,bool bResetRotateCenter = true);
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);
    void mousePressEvent(QGraphicsSceneMouseEvent *event);
    void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
    void SetRotate(qreal RotateAngle,QPointF ptCenter=QPointF(-999,-999));
    QPointF getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle);//获取旋转后的点
    QList&lt;QPointF&gt; getRotatePoints(QPointF ptCenter,QList&lt;QPointF&gt; ptIns,qreal angle);//获取多个旋转后的点
    QPolygonF getRotatePolygonFromRect(QPointF ptCenter,QRectF rectIn,qreal angle);//将矩形旋转之后返回多边形
    QRectF getCrtPosRectToSceen();
    QRectF m_SmallRotateRect;//矩形顶部用来表示旋转的标记的矩形
    QPolygonF m_SmallRotatePolygon;//矩形顶部用来表示旋转的标记的矩形旋转后形成的多边形
    QPointF getSmallRotateRectCenter(QPointF ptA,QPointF ptB);//获取旋转时候矩形正上方的旋转标记矩形
    QRectF  getSmallRotateRect(QPointF ptA,QPointF ptB);
    bool    m_bRotate;
    qreal   m_RotateAngle;
    QPointF m_RotateCenter;

private:
    QRectF  m_oldRect;
    QPolygonF m_oldRectPolygon;
    QRectF  m_RotateAreaRect;
    bool    m_bResize;
    QPolygonF m_insicedPolygon;
    QRectF  m_insicedRectf;
    QPolygonF m_leftPolygon;
    QRectF  m_leftRectf;
    QPolygonF m_topPolygon;
    QRectF  m_topRectf;
    QPolygonF m_rightPolygon;
    QRectF  m_rightRectf;
    QPolygonF m_bottomPolygon;
    QRectF  m_bottomRectf;
//    QPolygonF m_rbPolygon;
//    QRectF  m_rbRectf;
    QPointF m_startPos;
    STATE_FLAG m_StateFlag;
    QPointF *pPointFofSmallRotateRect;
protected:

&#125;;
#endif // MYGRAPHICRECTITEM_H
</code></pre>
</li>
<li><p>mygraphicrectitem.cpp</p>
<!-- more -->
<pre><code class="c++">#include &quot;mygraphicrectitem.h&quot;
#include &lt;QtMath&gt;
#include &lt;QDebug&gt;

myGraphicRectItem::myGraphicRectItem(QGraphicsItem *parent):
    m_bResize(false),
    m_oldRect(0,0,100,100),
    m_bRotate(false),
    m_RotateAngle(0),
    m_StateFlag(DEFAULT_FLAG)
&#123;
    //setParent(parent);
    setRectSize(m_oldRect);
    setToolTip(&quot;Click and drag me!&quot;);  //提示
    setCursor(Qt::ArrowCursor);   //改变光标形状,手的形状
    setFlag(QGraphicsItem::ItemIsMovable);
    //    setAcceptDrops(true);
    pPointFofSmallRotateRect = new QPointF[4];
    SetRotate(0);
    setFlag(QGraphicsItem::ItemIsSelectable);//
&#125;

QRectF myGraphicRectItem::boundingRect() const
&#123;
    //return m_oldRectPolygon.boundingRect();
    QRectF boundingRectF = m_oldRectPolygon.boundingRect();
    return QRectF(boundingRectF.x()-40,boundingRectF.y()-40,boundingRectF.width()+80,boundingRectF.height()+80);
&#125;

myGraphicRectItem::~myGraphicRectItem()
&#123;
    delete []pPointFofSmallRotateRect;
    pPointFofSmallRotateRect = nullptr;
&#125;

void myGraphicRectItem::setRectSize(QRectF mrect, bool bResetRotateCenter)
&#123;
    m_oldRect = mrect;
    if(bResetRotateCenter)
    &#123;
        m_RotateCenter.setX(m_oldRect.x()+m_oldRect.width()/2);
        m_RotateCenter.setY(m_oldRect.y()+m_oldRect.height()/2);
    &#125;
    m_oldRectPolygon = getRotatePolygonFromRect(m_RotateCenter,m_oldRect,m_RotateAngle);

    m_insicedRectf = QRectF(m_oldRect.x()+8,m_oldRect.y()+8,m_oldRect.width()-16,m_oldRect.height()-16);
    m_insicedPolygon =getRotatePolygonFromRect(m_RotateCenter,m_insicedRectf,m_RotateAngle);

    m_leftRectf = QRectF(m_oldRect.x(),m_oldRect.y(),8,m_oldRect.height()-8);
    m_leftPolygon = getRotatePolygonFromRect(m_RotateCenter,m_leftRectf,m_RotateAngle);

    m_topRectf = QRectF(m_oldRect.x()+8,m_oldRect.y(),m_oldRect.width()-8,8);
    m_topPolygon = getRotatePolygonFromRect(m_RotateCenter,m_topRectf,m_RotateAngle);

    m_rightRectf = QRectF(m_oldRect.right()-8,m_oldRect.y()+8,8,m_oldRect.height()-16);
    m_rightPolygon = getRotatePolygonFromRect(m_RotateCenter,m_rightRectf,m_RotateAngle);

    m_bottomRectf = QRectF(m_oldRect.x(),m_oldRect.bottom()-8,m_oldRect.width()-8,8);
    m_bottomPolygon = getRotatePolygonFromRect(m_RotateCenter,m_bottomRectf,m_RotateAngle);

//    m_rbRectf = QRectF(m_oldRect.right()-8,m_oldRect.bottom()-8,8,8);
//    m_rbPolygon = getRotatePolygonFromRect(m_RotateCenter,m_rbRectf,m_RotateAngle);

    m_SmallRotateRect = getSmallRotateRect(mrect.topLeft(),mrect.topRight());//矩形正上方的旋转标记矩形
    m_SmallRotatePolygon = getRotatePolygonFromRect(m_RotateCenter,m_SmallRotateRect,m_RotateAngle);
&#125;

void myGraphicRectItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
&#123;
    QPen mPen = QPen(Qt::yellow);
    painter-&gt;setPen(mPen);
    //绘制旋转后的矩形
    painter-&gt;drawPolygon(m_oldRectPolygon);
    //绘制旋转圆形
    mPen.setWidth(2);
    mPen.setColor(Qt::green);
    painter-&gt;setPen(mPen);
    QPointF pf = getSmallRotateRectCenter(m_oldRectPolygon[0],m_oldRectPolygon[1]);
    QRectF rect = QRectF(pf.x()-10,pf.y()-10,20,20);
    painter-&gt;drawEllipse(rect);//绘制圆形
    painter-&gt;drawPoint(pf);//绘制点
&#125;

void myGraphicRectItem::mousePressEvent(QGraphicsSceneMouseEvent *event)
&#123;
    if(event-&gt;button()== Qt::LeftButton)
    &#123;
        m_startPos = event-&gt;pos();//鼠标左击时，获取当前鼠标在图片中的坐标，
        if(m_SmallRotatePolygon.containsPoint(m_startPos,Qt::WindingFill))//旋转矩形
        &#123;
            setCursor(Qt::PointingHandCursor);
            m_StateFlag = ROTATE;
        &#125;
        else if(m_insicedPolygon.containsPoint(m_startPos,Qt::WindingFill))//在矩形内框区域时按下鼠标，则可拖动图片
        &#123;
            setCursor(Qt::ClosedHandCursor);   //改变光标形状,手的形状
            m_StateFlag = MOV_RECT;//标记当前为鼠标拖动图片移动状态
        &#125;
        else if(m_leftPolygon.containsPoint(m_startPos,Qt::WindingFill))
        &#123;
            setCursor(Qt::SizeHorCursor);
            m_StateFlag = MOV_LEFT_LINE;//标记当前为用户按下矩形的左边界区域
        &#125;
        else if(m_rightPolygon.containsPoint(m_startPos,Qt::WindingFill))
        &#123;
            setCursor(Qt::SizeHorCursor);
            m_StateFlag = MOV_RIGHT_LINE;//标记当前为用户按下矩形的右边界区域
        &#125;
        else if(m_topPolygon.containsPoint(m_startPos,Qt::WindingFill))
        &#123;
            setCursor(Qt::SizeVerCursor);
            m_StateFlag = MOV_TOP_LINE;//标记当前为用户按下矩形的上边界区域
        &#125;
        else if(m_bottomPolygon.containsPoint(m_startPos,Qt::WindingFill))
        &#123;
            setCursor(Qt::SizeVerCursor);
            m_StateFlag = MOV_BOTTOM_LINE;//标记当前为用户按下矩形的下边界区域
        &#125;
//        else if(m_rbPolygon.containsPoint(m_startPos,Qt::WindingFill))
//        &#123;
//            setCursor(Qt::SizeFDiagCursor);
//            m_StateFlag = MOV_RIGHTBOTTOM_RECT;//标记当前为用户按下矩形的右下角
//        &#125;
        else
        &#123;
            m_StateFlag = DEFAULT_FLAG;
        &#125;
    &#125;
    else
    &#123;
        QGraphicsItem::mousePressEvent(event);
    &#125;
&#125;

void myGraphicRectItem::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
&#123;
    if(m_StateFlag == ROTATE)
    &#123;
       int nRotateAngle = atan2((event-&gt;pos().x()-m_RotateCenter.x()),(event-&gt;pos().y()-m_RotateCenter.y()))*180/M_PI;
       SetRotate(180-nRotateAngle);
       setRectSize(m_oldRect);
       //qDebug()&lt;&lt;nRotateAngle;
    &#125;
    else if(m_StateFlag == MOV_RECT)
    &#123;
        QPointF point = (event-&gt;pos() - m_startPos);
        moveBy(point.x(), point.y());
        setRectSize(m_oldRect);
        scene()-&gt;update();
    &#125;
    else if(m_StateFlag == MOV_LEFT_LINE)
    &#123;
        QPointF pf = QPointF((m_oldRectPolygon.at(1).x()+m_oldRectPolygon.at(2).x())/2,((m_oldRectPolygon.at(1).y()+m_oldRectPolygon.at(2).y())/2));
        //计算到右侧边中点的距离
        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));
        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));
        qreal dis2RT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));
        if(dis&lt;16||dis2LT&gt;dis2RT)
        &#123;
            return;
        &#125;
        else
        &#123;
            QRectF newRect(m_oldRect);
            newRect.setLeft(m_oldRect.right()-dis);
            newRect.setRight(m_oldRect.right());
            setRectSize(newRect,false);
            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);
            m_oldRect.moveCenter(m_RotateCenter);
            setRectSize(m_oldRect);
            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影
        &#125;
    &#125;
    else if(m_StateFlag == MOV_TOP_LINE)
    &#123;
        //底边中点
        QPointF pf = QPointF((m_oldRectPolygon.at(2).x()+m_oldRectPolygon.at(3).x())/2,((m_oldRectPolygon.at(2).y()+m_oldRectPolygon.at(3).y())/2));
        //计算到底边中点的距离
        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));
        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));
        qreal dis2LB = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));
        if(dis&lt;16||dis2LT&gt;dis2LB)
        &#123;
            return;
        &#125;
        else
        &#123;
            QRectF newRect(m_oldRect);
            newRect.setTop(m_oldRect.bottom()-dis);
            newRect.setBottom(m_oldRect.bottom());
            setRectSize(newRect,false);
            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);
            m_oldRect.moveCenter(m_RotateCenter);
            setRectSize(m_oldRect);
            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影
        &#125;
    &#125;
    else if(m_StateFlag == MOV_RIGHT_LINE)
    &#123;
        QPointF pf = QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(3).x())/2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(3).y())/2));
        //计算到左侧边中点的距离
        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));
        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));
        qreal dis2RT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));
        if(dis&lt;16||dis2LT&lt;dis2RT)
        &#123;
            return;
        &#125;
        else
        &#123;
            QRectF newRect(m_oldRect);
            newRect.setLeft(m_oldRect.left());
            newRect.setRight(m_oldRect.left()+dis);
            setRectSize(newRect,false);
            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);
            m_oldRect.moveCenter(m_RotateCenter);
            setRectSize(m_oldRect);
            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影
        &#125;
    &#125;
    else if(m_StateFlag == MOV_BOTTOM_LINE)
    &#123;
        //顶边中点
        QPointF pf = QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(1).x())/2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(1).y())/2));
        //计算到底边中点的距离
        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));
        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));
        qreal dis2LB = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));
        if(dis&lt;16||dis2LT&lt;dis2LB)
        &#123;
            return;
        &#125;
        else
        &#123;
            QRectF newRect(m_oldRect);
            newRect.setTop(m_oldRect.top());
            newRect.setBottom(m_oldRect.top()+dis);
            setRectSize(newRect,false);
            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);
            m_oldRect.moveCenter(m_RotateCenter);
            setRectSize(m_oldRect);
            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影
        &#125;
    &#125;
&#125;

void myGraphicRectItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
&#123;
    setCursor(Qt::ArrowCursor);
    if(m_StateFlag == MOV_RECT)
    &#123;
        m_StateFlag = DEFAULT_FLAG;
    &#125;
    else &#123;
        QGraphicsItem::mouseReleaseEvent(event);
    &#125;
&#125;

void myGraphicRectItem::SetRotate(qreal RotateAngle, QPointF ptCenter)
&#123;
    m_bRotate = true;
    if(ptCenter.x()==-999 &amp;&amp; ptCenter.y()==-999)
    &#123;
        m_RotateCenter = QPointF(m_oldRect.x()+m_oldRect.width()/2,m_oldRect.y()+m_oldRect.height()/2);
    &#125;
    else
    &#123;
        m_RotateCenter = ptCenter;
    &#125;
    m_RotateAngle = RotateAngle;
    this-&gt;update();
&#125;

QPointF myGraphicRectItem::getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle)
&#123;
    double dx = ptCenter.x();
    double dy = ptCenter.y();
    double x = ptIn.x();
    double y = ptIn.y();
    double xx,yy;
    xx = (x-dx)*cos(angle*M_PI/180)-(y-dy)*sin(angle*M_PI/180)+dx;
    yy = (x-dx)*sin(angle*M_PI/180)+(y-dy)*cos(angle*M_PI/180)+dy;

    return QPointF(xx,yy);
&#125;

QList&lt;QPointF&gt; myGraphicRectItem::getRotatePoints(QPointF ptCenter, QList&lt;QPointF&gt; ptIns, qreal angle)
&#123;
    QList&lt;QPointF&gt; lstPt;
    for(int i = 0;i&lt;ptIns.count();i++)
    &#123;
        lstPt.append(getRotatePoint(ptCenter,ptIns.at(i),angle));
    &#125;
    return lstPt;
&#125;

QPolygonF myGraphicRectItem::getRotatePolygonFromRect(QPointF ptCenter, QRectF rectIn, qreal angle)
&#123;
    QVector&lt;QPointF&gt; vpt;
    QPointF pf = getRotatePoint(ptCenter,rectIn.topLeft(),angle);
    vpt.append(pf);
    pf = getRotatePoint(ptCenter,rectIn.topRight(),angle);
    vpt.append(pf);
    pf = getRotatePoint(ptCenter,rectIn.bottomRight(),angle);
    vpt.append(pf);
    pf = getRotatePoint(ptCenter,rectIn.bottomLeft(),angle);
    vpt.append(pf);
    pf = getRotatePoint(ptCenter,rectIn.topLeft(),angle);
    vpt.append(pf);
    return QPolygonF(vpt);
&#125;

QRectF myGraphicRectItem::getCrtPosRectToSceen()
&#123;
    QRectF retRect = QRectF(m_oldRect.x()+pos().x(),m_oldRect.y()+pos().y(),m_oldRect.width(),m_oldRect.height());
    return retRect;
&#125;
QRectF myGraphicRectItem::getSmallRotateRect(QPointF ptA,QPointF ptB)
&#123;
    QPointF pt = getSmallRotateRectCenter(ptA,ptB);
    return QRectF(pt.x()-10,pt.y()-10,20,20);
&#125;
QPointF myGraphicRectItem::getSmallRotateRectCenter(QPointF ptA,QPointF ptB)
&#123;
    QPointF ptCenter = QPointF((ptA.x()+ptB.x())/2,(ptA.y()+ptB.y())/2);//A,B点的中点C
    //中垂线方程式为 y=x*k + b;
    qreal x,y;//旋转图标矩形的中心
    if(abs(ptB.y()-ptA.y())&lt;0.1)
    &#123;
        if(ptA.x()&lt;ptB.x())//矩形左上角在上方
        &#123;
            x = ptCenter.x();
            y = ptCenter.y()-20;
        &#125;
        else//矩形左上角在下方
        &#123;
            x = ptCenter.x();
            y = ptCenter.y()+20;
        &#125;
    &#125;
    else if(ptB.y()&gt;ptA.y())//顺时针旋转0-180
    &#123;
        qreal k = (ptA.x()-ptB.x())/(ptB.y()-ptA.y());//中垂线斜率
        qreal b = (ptA.y()+ptB.y())/2-k*(ptA.x()+ptB.x())/2;
        //求AB线中垂线上离AB中点20个像素的点C的坐标
        x = 20*cos(atan(k))+ptCenter.x();
        y = k*x+b;
    &#125;
    else if(ptB.y()&lt;ptA.y())//顺时针旋转180-360
    &#123;
        qreal k = (ptA.x()-ptB.x())/(ptB.y()-ptA.y());//中垂线斜率
        qreal b = (ptA.y()+ptB.y())/2-k*(ptA.x()+ptB.x())/2;
        //求AB线中垂线上离AB中点20个像素的点C的坐标
        x = -20*cos(atan(k))+ptCenter.x();
        y = k*x+b;
    &#125;
    return QPointF(x,y);
&#125;
</code></pre>
</li>
</ul>
<h3 id="功能3：Qt中设置QGraphicsView的背景色为透明且无边框"><a href="#功能3：Qt中设置QGraphicsView的背景色为透明且无边框" class="headerlink" title="功能3：Qt中设置QGraphicsView的背景色为透明且无边框"></a>功能3：Qt中设置<code>QGraphicsView</code>的背景色为透明且无边框</h3><ol>
<li>设置背景色为透明：在<code>QGraphicsView</code>上调用<code>setStyleSheet()</code>方法，并将背景色样式设置为透明。示例代码如下：</li>
</ol>
<pre><code class="c++">QGraphicsView* view = new QGraphicsView;
view-&gt;setStyleSheet(&quot;background-color: transparent;&quot;);
</code></pre>
<ol start="2">
<li>设置边框：在<code>QGraphicsView</code>上调用<code>setFrameStyle()</code>方法，并将边框样式设置为无边框。示例代码如下：</li>
</ol>
<pre><code class="c++">QGraphicsView* view = new QGraphicsView;
view-&gt;setFrameStyle(QFrame::NoFrame);
</code></pre>
<p>在Qt中使用一个按钮清除<code>QGraphicsView</code>上监控的图片<code>QGraphicsPixmapItem</code>上画出来不需要的矩形<code>QGraphicsRectItem</code></p>
<ol>
<li><p>首先，在<code>QGraphicsView</code>上绑定一个按钮<code>QPushButton</code></p>
<pre><code class="c++">QPushButton* clearBtn = new QPushButton(view);
# 将按钮放置在view的左下角
btn.setGeometry(0,view.geometry().height()-40,40,20);
btn.setText(&quot;clear&quot;);
</code></pre>
</li>
<li><p>给按钮绑定槽函数，用于清除矩形</p>
<pre><code class="c++">#在.h文件中定义槽函数
private slots:
    void on_btn_clicked();
</code></pre>
<pre><code class="c++"># 在构造函数中绑定槽函数
connect(clearBtn,SIGNAL(clicked()),this,SLOT(on_btn_clicked()));
</code></pre>
<pre><code class="c++"># 槽函数的具体实现
void ImgHelper::on_btn_clicked()&#123;
    rectcounts = 0;	#设矩形个数为0
    scene-&gt;clear();	# 清空scene
    imgUpdated(cloneImage);	# 将直接保存的监控图片重新添加进scene
&#125;
</code></pre>
</li>
</ol>
<h3 id="功能4：保存错误图片"><a href="#功能4：保存错误图片" class="headerlink" title="功能4：保存错误图片"></a>功能4：保存错误图片</h3><p>当发现监控的图片有问题时，就可以一键保存监控的图片，按日期创建文件夹，方便查看问题</p>
<pre><code class="c++">void ImgHelper::onSaveErrorImage()
&#123;
    //20230908
    QString currentPath = QDir::currentPath();

    QString filedir = currentPath + QDir::separator() + &quot;errorImg&quot;;
    QDir dir(filedir);
    if(!dir.exists())&#123;
       if(dir.mkdir(filedir))&#123;

       &#125;else&#123;
           qDebug()&lt;&lt;&quot;创建目录失败&quot;;
       &#125;
    &#125;
    QString nowDate = QDateTime::QDateTime::currentDateTime().toString(&quot;yyyy-MM-dd&quot;) ;
    QString filedirdate = filedir + QDir::separator() + nowDate;
    QDir dirdate(filedirdate);
    if(!dirdate.exists())&#123;
       if(dirdate.mkdir(filedirdate))&#123;

       &#125;else&#123;
           qDebug()&lt;&lt;&quot;创建目录失败&quot;;
       &#125;
    &#125;
    for(int i = 1; i &lt;= 8; i++)&#123;
        QString imgpath = filedirdate + QDir::separator() + &quot;tt&quot; + QString::number(i) +&quot;.bmp&quot;;
        QFile file(imgpath);
        //判断文件是否存在
        if(file.exists())&#123;
           continue;
        &#125;
        if(pixmapItem != NULL)&#123;
            pixmapItem-&gt;pixmap().save(imgpath);
        &#125;
        break;
    &#125;
&#125;
</code></pre>
<h3 id="功能5：修复图片通道异常"><a href="#功能5：修复图片通道异常" class="headerlink" title="功能5：修复图片通道异常"></a>功能5：修复图片通道异常</h3><pre><code class="c++">//2023926加  修复PLC查看图片出现的通道异常
        for(int x = 0 ; x &lt; image.height(); x++)&#123;
                    for(int y = 0 ; y &lt; image.width(); y++)&#123;
                        QRgb pixel = image.pixel(x,y);
                        int red = qBlue(pixel);
                        int green =qRed(pixel);
                        int blue = qGreen(pixel);
                        QRgb newpixel = qRgb(red,green,blue);
                        image.setPixel(x,y,newpixel);

                    &#125;
                &#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Hexo
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Mzy
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    

    <canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>
<canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>
<div id="cursor"></div>
<link rel="stylesheet" href="/css/cursor.min.css" />
<script src="/js/cursor.min.js"></script>

</body>
</html>
