<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="mzy的成长历程">
    <meta name="author" content="Keep Team">
    
    <title>
        
            使用Qt开发工作上的需求 |
        
        Keep Theme
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"dybil.top","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"Keep Theme","author":"Keep Team","avatar":"/images/avatar.svg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"Archives":"/archives","Tags":"/tags","Categories":"/categories","Links":"/links","About":"/about","Photos":"/photos"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"category":false,"tag":false,"announcement":null},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"toc":{"enable":false,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":false,"preload":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"jsdelivr"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":false,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","version":"4.0.5"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Keep Theme
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    <li class="menu-item">
                        <a class=""
                           href="/"
                        >首页</a>
                    </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >归档</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >标签</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >分类</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >友链</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >关于</a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/photos"
                            >相册</a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            <li class="drawer-menu-item flex-center">
                <a class=""
                   href="/"
                >首页</a>
            </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags"
                    >标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links"
                    >友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about"
                    >关于</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/photos"
                    >相册</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        使用Qt开发工作上的需求
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Keep Team</span>
                                
                                    <span class="author-badge">Lv4</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-check"></i>&nbsp;
                <span class="pc">2023-10-26 16:03:35</span>
                <span class="mobile">2023-10-26 16:03</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="pc" data-updated="Tue Oct 31 2023 14:49:27 GMT+0800">2023-10-31 14:49:27</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <i class="icon fas fa-tags"></i>&nbsp;
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/c/">c++</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Qt/">Qt</a></li>
                        
                    
                </ul>
            </span>
        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <p>记录最近工作设及到一些关于qt编程的相关内容</p>
<span id="more"></span>

<h3 id="功能1：鼠标点击图片显示坐标和像素"><a href="#功能1：鼠标点击图片显示坐标和像素" class="headerlink" title="功能1：鼠标点击图片显示坐标和像素"></a>功能1：鼠标点击图片显示坐标和像素</h3><p>最近工作设及到一些关于qt编程的工作，主要内容就是在一个<code>QGraphicsView</code>上显示了一个<code>QGraphicsPixmapItem</code>的相机监控的图片，并用鼠标点击图片显示坐标和像素。</p>
<p>最初在网上找到的解决方案是重写<code>mousePressEvent()</code>方法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ImgHelper::mousePressEvent(QGraphicsSceneMouseEvent* event)
&#123;
    std::cout &lt;&lt; &quot;Item: (&quot; &lt;&lt; event-&gt;scenePos().x() &lt;&lt; &quot;, &quot; &lt;&lt; event-&gt;scenePos().y() &lt;&lt; &#39;)&#39; &lt;&lt; std::endl; 
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试发现未响应鼠标事件，网上找到说：重写鼠标点击事件函数时发现鼠标点击事件在子类化后的<code>QGraphicsScene</code>中被响应，但是子类化后的<code>QGraphicsPixmapItem</code>无法响应。<code>QGraphicsView</code>的事件传递机制的顺序是<code>View-&gt;Scene-&gt;Item</code>，也就是说事件被子类化的<code>QGraphicsScene</code>吞没了，没有传递到下一级的<code>item</code>。<br>解决方案，在子类化的<code>QGraphicsScene</code>中重写<code>mousePressEvent()</code>方法内部一定要要记得调用：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">QGraphicsScene::mousePressEvent(event);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意，要想返回图像坐标系的位置，就需要在子类化的<code>QGraphicsPixmapItem</code>中调用<code>scenePos()</code>函数。即使放大图像，点击图像中相同位置也会返回相同坐标结果。</p>
<p>结果发现还是没有反应，还有一种说法就是加上下面这句话</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;使能QGraphcisView控件的鼠标跟踪
view-&gt;setMouseTracking(true);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>最后尝试把<code>mousePressEvent</code>函数在最上层的<code>mainwindow</code>中重写并使能鼠标，有效果，但是坐标并不是我想要的效果，现在的坐标系是整个界面的，我想要的是图像的坐标，然后能通过图像控件的位置和长宽进行筛选，但是获得的图像是经过qt自适应缩放在<code>600X600</code>的容器里的。</p>
<p>在一筹莫展的时候，突然看到<code>eventFilter</code>事件过滤器。</p>
<p><img   src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/20210320141253167.png"  alt="在这里插入图片描述"></p>
<p>原本事件应该直接发送给“组件对象”，但是现在却先将事件发送给“过滤器对象”，经过过滤的事件再发给“组件对象”。</p>
<p><strong>事件过滤器的操作：</strong></p>
<ol>
<li>首先给需要添加事件过滤器的部件<strong>注册监听对象</strong>；<br><code>对象名-&gt;installEventFilter(true);</code></li>
<li>重写<code>eventFilter(QObject *obj, QEvent *event)</code>函数进行处理。<!-- more -->
首先使用参数<code>obj</code>进行与绑定的控件对象进行判断，是否与其相等；然后在使用参数<code>event-&gt;type()</code>的返回值与枚举鼠标或者键盘进行判断；最后将<code>event</code>转换为鼠标事件对象或者键盘对象事件，就可以进行操作了。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool ImgHelper::eventFilter(QObject *watched, QEvent *event)
&#123;
    &#x2F;&#x2F;判断信号是不是来自QGraphicsView
    if(watched &#x3D;&#x3D; view-&gt;viewport())&#123;
        switch (event-&gt;type()) &#123;
        &#x2F;&#x2F;鼠标移动事件
        case  QEvent::MouseMove:
        &#123;
            QMouseEvent *m_event &#x3D; (QMouseEvent*)event;


            if(pixmapItem &#x3D;&#x3D; NULL)&#123;
                break;
            &#125;

           &#x2F;&#x2F; QPoint point &#x3D; m_event-&gt;pos();

            QPixmap pix&#x3D; pixmapItem-&gt;pixmap();
            QImage img &#x3D; pix.toImage();
          &#x2F;&#x2F;  QSize size &#x3D; pixmapItem-&gt;pixmap().size();


            QPoint point &#x3D; m_event-&gt;pos();
           &#x2F;&#x2F; qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
            &#x2F;&#x2F; 坐标系转换 - 视图 -&gt; 场景
            QPointF scenePoint &#x3D; view-&gt;mapToScene(point);
            &#x2F;&#x2F;qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
            &#x2F;&#x2F; 坐标系转换 - 场景 -&gt; 图元
            QPointF itempoint &#x3D; pixmapItem-&gt;mapFromScene(scenePoint);
           &#x2F;&#x2F; qDebug()&lt;&lt;&quot;itempoint:&quot;&lt;&lt;itempoint&lt;&lt;endl;
            QString str;
            &#x2F;&#x2F; 判断所选点是否在图像范围内
            if(itempoint.x()&gt;&#x3D;0 &amp;&amp;itempoint.x()&lt;&#x3D;pix.width() &amp;&amp; itempoint.y()&gt;&#x3D;0 &amp;&amp; itempoint.y()&lt;&#x3D; pix.height())&#123;
                QRgb pixColor &#x3D; img.pixel(itempoint.x(),itempoint.y());
               &#x2F;&#x2F; qDebug()&lt;&lt;pixColor&lt;&lt;&quot; &quot;&lt;&lt;qRed(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qGreen(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qBlue(pixColor)&lt;&lt;endl;
                str &#x3D; QString(&quot;X:%1\nY:%2\nR:%3\nG:%4\nB:%5\n&quot;).arg(QString::number(itempoint.x(),&#39;f&#39;,1))
                                                                .arg(QString::number(itempoint.y(),&#39;f&#39;,1))
                                                                .arg(qRed(pixColor))
                                                                .arg(qGreen(pixColor))
                                                                .arg(qBlue(pixColor)).toLocal8Bit();
            &#125;
            else&#123;
                str &#x3D; &quot;&quot;;
            &#125;
            img_xy_pix-&gt;setText(str);
            img_xy_pix-&gt;setStyleSheet(&quot;color:red;&quot;);
            break;
        &#125;
        &#x2F;&#x2F; 鼠标点击事件
        case QEvent::MouseButtonPress:
        &#123;
            if(pixmapItem &#x3D;&#x3D; NULL)&#123;
                break;
            &#125;
            QMouseEvent *m_event &#x3D; (QMouseEvent*)event;
            &#x2F;&#x2F; 左键点击确定起点
            if(m_event-&gt;button() &#x3D;&#x3D; Qt::LeftButton )&#123;

             &#x2F;&#x2F;   QPixmap pix&#x3D; pixmapItem-&gt;pixmap();
                QPainter painter(view-&gt;viewport());
                painter.setPen(QPen(Qt::blue,1));
              &#x2F;&#x2F;  QImage img &#x3D; pix.toImage();
              &#x2F;&#x2F;  QSize size &#x3D; pixmapItem-&gt;pixmap().size();
               &#x2F;&#x2F; qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;
                QPoint point &#x3D; m_event-&gt;pos();
               &#x2F;&#x2F; qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
                QPointF scenePoint &#x3D; view-&gt;mapToScene(point);
                &#x2F;&#x2F;qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
                QPointF itempoint &#x3D; pixmapItem-&gt;mapFromScene(scenePoint);
                startPoint &#x3D; itempoint;
                break;
            &#125;
            break;
        &#125;
        &#x2F;&#x2F; 送开鼠标，确定终点
        case QEvent::MouseButtonRelease:
        &#123;
            if(pixmapItem &#x3D;&#x3D; NULL)&#123;
                break;
            &#125;
            QMouseEvent *m_event &#x3D; (QMouseEvent*)event;
            if(m_event-&gt;button() &#x3D;&#x3D; Qt::LeftButton )&#123;

&#x2F;&#x2F;                QPixmap pix&#x3D; pixmapItem-&gt;pixmap();
                QPainter painter(view-&gt;viewport());
                painter.setPen(QPen(Qt::blue,1));
              &#x2F;&#x2F;  QImage img &#x3D; pix.toImage();
              &#x2F;&#x2F;  QSize size &#x3D; pixmapItem-&gt;pixmap().size();
               &#x2F;&#x2F; qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;
                QPoint point &#x3D; m_event-&gt;pos();
               &#x2F;&#x2F; qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
                QPointF scenePoint &#x3D; view-&gt;mapToScene(point);
                &#x2F;&#x2F;qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
                QPointF itempoint &#x3D; pixmapItem-&gt;mapFromScene(scenePoint);
                QPointF endPoint &#x3D; itempoint;
                if(startPoint.x() !&#x3D; 0 &amp;&amp; startPoint.y() !&#x3D; 0)&#123;
                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());
                    painter.drawRect(rectangle);
                    painter.setPen(QPen(Qt::red,1));
                    rects &#x3D; scene-&gt;addRect(rectangle,rectPen);
&#x2F;&#x2F;                    float rectInfo[8];
&#x2F;&#x2F;                    rectcounts++;
&#x2F;&#x2F;                    rectInfo[0] &#x3D; rectcounts;
&#x2F;&#x2F;                    float x &#x3D; (endPoint.x()-startPoint.x()) &#x2F; 2 + startPoint.x();
&#x2F;&#x2F;                    float y &#x3D; (endPoint.y()-startPoint.y()) &#x2F; 2 + startPoint.y();
&#x2F;&#x2F;                    float height;
&#x2F;&#x2F;                    float width;
&#x2F;&#x2F;                    if(endPoint.x()-startPoint.x() &gt; endPoint.y()-startPoint.y())&#123;
&#x2F;&#x2F;                       height &#x3D; endPoint.x()-startPoint.x();
&#x2F;&#x2F;                       width &#x3D; endPoint.y()-startPoint.y();
&#x2F;&#x2F;                    &#125;else&#123;
&#x2F;&#x2F;                        width &#x3D; endPoint.x()-startPoint.x();
&#x2F;&#x2F;                        height &#x3D; endPoint.y()-startPoint.y();
&#x2F;&#x2F;                    &#125;
                 &#x2F;&#x2F;   rectInfo[1] &#x3D; x;
                 &#x2F;&#x2F;   rectInfo[2] &#x3D; y;
                 &#x2F;&#x2F;   rectInfo[3] &#x3D; height;
                 &#x2F;&#x2F;      rectInfo[4] &#x3D; width;
                  &#x2F;&#x2F;  float angle &#x3D; -90;
                 &#x2F;&#x2F;   rectInfo[5] &#x3D; angle;
&#x2F;&#x2F;                    CassUdpHelper* udpClient &#x3D; new CassUdpHelper(localPort, this);
                    
&#x2F;&#x2F;                     bool flag &#x3D; false;
  
&#x2F;&#x2F;                    int rectCountsAddr &#x3D; 353345520;
&#x2F;&#x2F;                    flag &#x3D; udpClient-&gt;writeBytesByModbus(rectCountsAddr, (char*)&amp;rectcounts, sizeof(short), hostIpAddr, hostPort);
&#x2F;&#x2F;                    if(!flag) &#123;
&#x2F;&#x2F;                        delete udpClient;
&#x2F;&#x2F;                         break;
&#x2F;&#x2F;                    &#125;
&#x2F;&#x2F;                    int startAddr &#x3D; 427778712;
&#x2F;&#x2F;                    flag &#x3D; udpClient-&gt;writeBytesByModbus(startAddr + sizeof(float)*8 *(rectcounts - 1), (char*)rectInfo, sizeof(float)*8, hostIpAddr, hostPort);
&#x2F;&#x2F;                    if(!flag) &#123;
&#x2F;&#x2F;                        delete udpClient;
&#x2F;&#x2F;                         break;
&#x2F;&#x2F;                    &#125;
&#x2F;&#x2F;                    delete udpClient;
                    
                &#125;
                break;
            &#125;
            break;
        &#125;

        default:
            break;
        &#125;

    &#125;



    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="功能2：Qt拖动鼠标画一个矩形"><a href="#功能2：Qt拖动鼠标画一个矩形" class="headerlink" title="功能2：Qt拖动鼠标画一个矩形"></a>功能2：Qt拖动鼠标画一个矩形</h3><p>想要画一个矩形就需要过滤鼠标点击事件，鼠标按下时确定矩形的起点，然后拖动一段距离，松开确定终点。</p>
<!-- more -->
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 鼠标点击事件
        case QEvent::MouseButtonPress:
        &#123;
            if(pixmapItem &#x3D;&#x3D; NULL)&#123;
                break;
            &#125;
            QMouseEvent *m_event &#x3D; (QMouseEvent*)event;
            &#x2F;&#x2F; 左键点击确定起点
            if(m_event-&gt;button() &#x3D;&#x3D; Qt::LeftButton )&#123;

             &#x2F;&#x2F;   QPixmap pix&#x3D; pixmapItem-&gt;pixmap();
                QPainter painter(view-&gt;viewport());
                painter.setPen(QPen(Qt::blue,1));
              &#x2F;&#x2F;  QImage img &#x3D; pix.toImage();
              &#x2F;&#x2F;  QSize size &#x3D; pixmapItem-&gt;pixmap().size();
               &#x2F;&#x2F; qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;
                QPoint point &#x3D; m_event-&gt;pos();
               &#x2F;&#x2F; qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
                QPointF scenePoint &#x3D; view-&gt;mapToScene(point);
                &#x2F;&#x2F;qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
                QPointF itempoint &#x3D; pixmapItem-&gt;mapFromScene(scenePoint);
                startPoint &#x3D; itempoint;
                break;
            &#125;
            break;
        &#125;
        &#x2F;&#x2F; 送开鼠标，确定终点
        case QEvent::MouseButtonRelease:
        &#123;
            if(pixmapItem &#x3D;&#x3D; NULL)&#123;
                break;
            &#125;
            QMouseEvent *m_event &#x3D; (QMouseEvent*)event;
            if(m_event-&gt;button() &#x3D;&#x3D; Qt::LeftButton )&#123;

&#x2F;&#x2F;                QPixmap pix&#x3D; pixmapItem-&gt;pixmap();
                QPainter painter(view-&gt;viewport());
                painter.setPen(QPen(Qt::blue,1));
              &#x2F;&#x2F;  QImage img &#x3D; pix.toImage();
              &#x2F;&#x2F;  QSize size &#x3D; pixmapItem-&gt;pixmap().size();
               &#x2F;&#x2F; qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;
                QPoint point &#x3D; m_event-&gt;pos();
               &#x2F;&#x2F; qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;
                QPointF scenePoint &#x3D; view-&gt;mapToScene(point);
                &#x2F;&#x2F;qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;
                QPointF itempoint &#x3D; pixmapItem-&gt;mapFromScene(scenePoint);
                QPointF endPoint &#x3D; itempoint;
                if(startPoint.x() !&#x3D; 0 &amp;&amp; startPoint.y() !&#x3D; 0)&#123;
                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());
                    painter.drawRect(rectangle);
                    painter.setPen(QPen(Qt::red,1));
                    rects &#x3D; scene-&gt;addRect(rectangle,rectPen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这是在网上看到其他人重写的一个<code>QGraphicsRectItem</code>类，画出来的矩形可以拖动，变形，旋转，使用时只需要导入这个类</p>
<ul>
<li><p>mygraphicrectitem.h</p>
<!-- more -->
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef MYGRAPHICRECTITEM_H
#define MYGRAPHICRECTITEM_H
#include &lt;QObject&gt;
#include &lt;QWidget&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QGraphicsScene&gt;
#include &lt;QGraphicsRectItem&gt;
#include &lt;QGraphicsSceneMouseEvent&gt;
#include &lt;QRect&gt;
#include &lt;QPainter&gt;
#include &lt;QPolygon&gt;
#include &lt;QList&gt;
enum STATE_FLAG&#123;
    DEFAULT_FLAG&#x3D;0,
    MOV_LEFT_LINE,&#x2F;&#x2F;标记当前为用户按下矩形的左边界区域
    MOV_TOP_LINE,&#x2F;&#x2F;标记当前为用户按下矩形的上边界区域
    MOV_RIGHT_LINE,&#x2F;&#x2F;标记当前为用户按下矩形的右边界区域
    MOV_BOTTOM_LINE,&#x2F;&#x2F;标记当前为用户按下矩形的下边界区域
    MOV_RIGHTBOTTOM_RECT,&#x2F;&#x2F;标记当前为用户按下矩形的右下角
    MOV_RECT,&#x2F;&#x2F;标记当前为鼠标拖动图片移动状态
    ROTATE&#x2F;&#x2F;标记当前为旋转状态
&#125;;
class myGraphicRectItem:public QObject,public QGraphicsItem
&#123;
    Q_OBJECT
public:
    myGraphicRectItem(QGraphicsItem *parent &#x3D; nullptr);
    &#x2F;&#x2F;myGraphicRectItem(QRectF m_OriginRect &#x3D; QRectF(0,0,100,100));
    QRectF  boundingRect() const;
    ~myGraphicRectItem();
    void setRectSize(QRectF mrect,bool bResetRotateCenter &#x3D; true);
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);
    void mousePressEvent(QGraphicsSceneMouseEvent *event);
    void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
    void SetRotate(qreal RotateAngle,QPointF ptCenter&#x3D;QPointF(-999,-999));
    QPointF getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle);&#x2F;&#x2F;获取旋转后的点
    QList&lt;QPointF&gt; getRotatePoints(QPointF ptCenter,QList&lt;QPointF&gt; ptIns,qreal angle);&#x2F;&#x2F;获取多个旋转后的点
    QPolygonF getRotatePolygonFromRect(QPointF ptCenter,QRectF rectIn,qreal angle);&#x2F;&#x2F;将矩形旋转之后返回多边形
    QRectF getCrtPosRectToSceen();
    QRectF m_SmallRotateRect;&#x2F;&#x2F;矩形顶部用来表示旋转的标记的矩形
    QPolygonF m_SmallRotatePolygon;&#x2F;&#x2F;矩形顶部用来表示旋转的标记的矩形旋转后形成的多边形
    QPointF getSmallRotateRectCenter(QPointF ptA,QPointF ptB);&#x2F;&#x2F;获取旋转时候矩形正上方的旋转标记矩形
    QRectF  getSmallRotateRect(QPointF ptA,QPointF ptB);
    bool    m_bRotate;
    qreal   m_RotateAngle;
    QPointF m_RotateCenter;

private:
    QRectF  m_oldRect;
    QPolygonF m_oldRectPolygon;
    QRectF  m_RotateAreaRect;
    bool    m_bResize;
    QPolygonF m_insicedPolygon;
    QRectF  m_insicedRectf;
    QPolygonF m_leftPolygon;
    QRectF  m_leftRectf;
    QPolygonF m_topPolygon;
    QRectF  m_topRectf;
    QPolygonF m_rightPolygon;
    QRectF  m_rightRectf;
    QPolygonF m_bottomPolygon;
    QRectF  m_bottomRectf;
&#x2F;&#x2F;    QPolygonF m_rbPolygon;
&#x2F;&#x2F;    QRectF  m_rbRectf;
    QPointF m_startPos;
    STATE_FLAG m_StateFlag;
    QPointF *pPointFofSmallRotateRect;
protected:

&#125;;
#endif &#x2F;&#x2F; MYGRAPHICRECTITEM_H
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>mygraphicrectitem.cpp</p>
<!-- more -->
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;mygraphicrectitem.h&quot;
#include &lt;QtMath&gt;
#include &lt;QDebug&gt;

myGraphicRectItem::myGraphicRectItem(QGraphicsItem *parent):
    m_bResize(false),
    m_oldRect(0,0,100,100),
    m_bRotate(false),
    m_RotateAngle(0),
    m_StateFlag(DEFAULT_FLAG)
&#123;
    &#x2F;&#x2F;setParent(parent);
    setRectSize(m_oldRect);
    setToolTip(&quot;Click and drag me!&quot;);  &#x2F;&#x2F;提示
    setCursor(Qt::ArrowCursor);   &#x2F;&#x2F;改变光标形状,手的形状
    setFlag(QGraphicsItem::ItemIsMovable);
    &#x2F;&#x2F;    setAcceptDrops(true);
    pPointFofSmallRotateRect &#x3D; new QPointF[4];
    SetRotate(0);
    setFlag(QGraphicsItem::ItemIsSelectable);&#x2F;&#x2F;
&#125;

QRectF myGraphicRectItem::boundingRect() const
&#123;
    &#x2F;&#x2F;return m_oldRectPolygon.boundingRect();
    QRectF boundingRectF &#x3D; m_oldRectPolygon.boundingRect();
    return QRectF(boundingRectF.x()-40,boundingRectF.y()-40,boundingRectF.width()+80,boundingRectF.height()+80);
&#125;

myGraphicRectItem::~myGraphicRectItem()
&#123;
    delete []pPointFofSmallRotateRect;
    pPointFofSmallRotateRect &#x3D; nullptr;
&#125;

void myGraphicRectItem::setRectSize(QRectF mrect, bool bResetRotateCenter)
&#123;
    m_oldRect &#x3D; mrect;
    if(bResetRotateCenter)
    &#123;
        m_RotateCenter.setX(m_oldRect.x()+m_oldRect.width()&#x2F;2);
        m_RotateCenter.setY(m_oldRect.y()+m_oldRect.height()&#x2F;2);
    &#125;
    m_oldRectPolygon &#x3D; getRotatePolygonFromRect(m_RotateCenter,m_oldRect,m_RotateAngle);

    m_insicedRectf &#x3D; QRectF(m_oldRect.x()+8,m_oldRect.y()+8,m_oldRect.width()-16,m_oldRect.height()-16);
    m_insicedPolygon &#x3D;getRotatePolygonFromRect(m_RotateCenter,m_insicedRectf,m_RotateAngle);

    m_leftRectf &#x3D; QRectF(m_oldRect.x(),m_oldRect.y(),8,m_oldRect.height()-8);
    m_leftPolygon &#x3D; getRotatePolygonFromRect(m_RotateCenter,m_leftRectf,m_RotateAngle);

    m_topRectf &#x3D; QRectF(m_oldRect.x()+8,m_oldRect.y(),m_oldRect.width()-8,8);
    m_topPolygon &#x3D; getRotatePolygonFromRect(m_RotateCenter,m_topRectf,m_RotateAngle);

    m_rightRectf &#x3D; QRectF(m_oldRect.right()-8,m_oldRect.y()+8,8,m_oldRect.height()-16);
    m_rightPolygon &#x3D; getRotatePolygonFromRect(m_RotateCenter,m_rightRectf,m_RotateAngle);

    m_bottomRectf &#x3D; QRectF(m_oldRect.x(),m_oldRect.bottom()-8,m_oldRect.width()-8,8);
    m_bottomPolygon &#x3D; getRotatePolygonFromRect(m_RotateCenter,m_bottomRectf,m_RotateAngle);

&#x2F;&#x2F;    m_rbRectf &#x3D; QRectF(m_oldRect.right()-8,m_oldRect.bottom()-8,8,8);
&#x2F;&#x2F;    m_rbPolygon &#x3D; getRotatePolygonFromRect(m_RotateCenter,m_rbRectf,m_RotateAngle);

    m_SmallRotateRect &#x3D; getSmallRotateRect(mrect.topLeft(),mrect.topRight());&#x2F;&#x2F;矩形正上方的旋转标记矩形
    m_SmallRotatePolygon &#x3D; getRotatePolygonFromRect(m_RotateCenter,m_SmallRotateRect,m_RotateAngle);
&#125;

void myGraphicRectItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
&#123;
    QPen mPen &#x3D; QPen(Qt::yellow);
    painter-&gt;setPen(mPen);
    &#x2F;&#x2F;绘制旋转后的矩形
    painter-&gt;drawPolygon(m_oldRectPolygon);
    &#x2F;&#x2F;绘制旋转圆形
    mPen.setWidth(2);
    mPen.setColor(Qt::green);
    painter-&gt;setPen(mPen);
    QPointF pf &#x3D; getSmallRotateRectCenter(m_oldRectPolygon[0],m_oldRectPolygon[1]);
    QRectF rect &#x3D; QRectF(pf.x()-10,pf.y()-10,20,20);
    painter-&gt;drawEllipse(rect);&#x2F;&#x2F;绘制圆形
    painter-&gt;drawPoint(pf);&#x2F;&#x2F;绘制点
&#125;

void myGraphicRectItem::mousePressEvent(QGraphicsSceneMouseEvent *event)
&#123;
    if(event-&gt;button()&#x3D;&#x3D; Qt::LeftButton)
    &#123;
        m_startPos &#x3D; event-&gt;pos();&#x2F;&#x2F;鼠标左击时，获取当前鼠标在图片中的坐标，
        if(m_SmallRotatePolygon.containsPoint(m_startPos,Qt::WindingFill))&#x2F;&#x2F;旋转矩形
        &#123;
            setCursor(Qt::PointingHandCursor);
            m_StateFlag &#x3D; ROTATE;
        &#125;
        else if(m_insicedPolygon.containsPoint(m_startPos,Qt::WindingFill))&#x2F;&#x2F;在矩形内框区域时按下鼠标，则可拖动图片
        &#123;
            setCursor(Qt::ClosedHandCursor);   &#x2F;&#x2F;改变光标形状,手的形状
            m_StateFlag &#x3D; MOV_RECT;&#x2F;&#x2F;标记当前为鼠标拖动图片移动状态
        &#125;
        else if(m_leftPolygon.containsPoint(m_startPos,Qt::WindingFill))
        &#123;
            setCursor(Qt::SizeHorCursor);
            m_StateFlag &#x3D; MOV_LEFT_LINE;&#x2F;&#x2F;标记当前为用户按下矩形的左边界区域
        &#125;
        else if(m_rightPolygon.containsPoint(m_startPos,Qt::WindingFill))
        &#123;
            setCursor(Qt::SizeHorCursor);
            m_StateFlag &#x3D; MOV_RIGHT_LINE;&#x2F;&#x2F;标记当前为用户按下矩形的右边界区域
        &#125;
        else if(m_topPolygon.containsPoint(m_startPos,Qt::WindingFill))
        &#123;
            setCursor(Qt::SizeVerCursor);
            m_StateFlag &#x3D; MOV_TOP_LINE;&#x2F;&#x2F;标记当前为用户按下矩形的上边界区域
        &#125;
        else if(m_bottomPolygon.containsPoint(m_startPos,Qt::WindingFill))
        &#123;
            setCursor(Qt::SizeVerCursor);
            m_StateFlag &#x3D; MOV_BOTTOM_LINE;&#x2F;&#x2F;标记当前为用户按下矩形的下边界区域
        &#125;
&#x2F;&#x2F;        else if(m_rbPolygon.containsPoint(m_startPos,Qt::WindingFill))
&#x2F;&#x2F;        &#123;
&#x2F;&#x2F;            setCursor(Qt::SizeFDiagCursor);
&#x2F;&#x2F;            m_StateFlag &#x3D; MOV_RIGHTBOTTOM_RECT;&#x2F;&#x2F;标记当前为用户按下矩形的右下角
&#x2F;&#x2F;        &#125;
        else
        &#123;
            m_StateFlag &#x3D; DEFAULT_FLAG;
        &#125;
    &#125;
    else
    &#123;
        QGraphicsItem::mousePressEvent(event);
    &#125;
&#125;

void myGraphicRectItem::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
&#123;
    if(m_StateFlag &#x3D;&#x3D; ROTATE)
    &#123;
       int nRotateAngle &#x3D; atan2((event-&gt;pos().x()-m_RotateCenter.x()),(event-&gt;pos().y()-m_RotateCenter.y()))*180&#x2F;M_PI;
       SetRotate(180-nRotateAngle);
       setRectSize(m_oldRect);
       &#x2F;&#x2F;qDebug()&lt;&lt;nRotateAngle;
    &#125;
    else if(m_StateFlag &#x3D;&#x3D; MOV_RECT)
    &#123;
        QPointF point &#x3D; (event-&gt;pos() - m_startPos);
        moveBy(point.x(), point.y());
        setRectSize(m_oldRect);
        scene()-&gt;update();
    &#125;
    else if(m_StateFlag &#x3D;&#x3D; MOV_LEFT_LINE)
    &#123;
        QPointF pf &#x3D; QPointF((m_oldRectPolygon.at(1).x()+m_oldRectPolygon.at(2).x())&#x2F;2,((m_oldRectPolygon.at(1).y()+m_oldRectPolygon.at(2).y())&#x2F;2));
        &#x2F;&#x2F;计算到右侧边中点的距离
        qreal dis &#x3D; sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));
        qreal dis2LT &#x3D; sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));
        qreal dis2RT &#x3D; sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));
        if(dis&lt;16||dis2LT&gt;dis2RT)
        &#123;
            return;
        &#125;
        else
        &#123;
            QRectF newRect(m_oldRect);
            newRect.setLeft(m_oldRect.right()-dis);
            newRect.setRight(m_oldRect.right());
            setRectSize(newRect,false);
            m_RotateCenter&#x3D;QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())&#x2F;2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())&#x2F;2);
            m_oldRect.moveCenter(m_RotateCenter);
            setRectSize(m_oldRect);
            scene()-&gt;update();&#x2F;&#x2F;必须要用scene()-&gt;update()，不能用update();否则会出现重影
        &#125;
    &#125;
    else if(m_StateFlag &#x3D;&#x3D; MOV_TOP_LINE)
    &#123;
        &#x2F;&#x2F;底边中点
        QPointF pf &#x3D; QPointF((m_oldRectPolygon.at(2).x()+m_oldRectPolygon.at(3).x())&#x2F;2,((m_oldRectPolygon.at(2).y()+m_oldRectPolygon.at(3).y())&#x2F;2));
        &#x2F;&#x2F;计算到底边中点的距离
        qreal dis &#x3D; sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));
        qreal dis2LT &#x3D; sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));
        qreal dis2LB &#x3D; sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));
        if(dis&lt;16||dis2LT&gt;dis2LB)
        &#123;
            return;
        &#125;
        else
        &#123;
            QRectF newRect(m_oldRect);
            newRect.setTop(m_oldRect.bottom()-dis);
            newRect.setBottom(m_oldRect.bottom());
            setRectSize(newRect,false);
            m_RotateCenter&#x3D;QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())&#x2F;2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())&#x2F;2);
            m_oldRect.moveCenter(m_RotateCenter);
            setRectSize(m_oldRect);
            scene()-&gt;update();&#x2F;&#x2F;必须要用scene()-&gt;update()，不能用update();否则会出现重影
        &#125;
    &#125;
    else if(m_StateFlag &#x3D;&#x3D; MOV_RIGHT_LINE)
    &#123;
        QPointF pf &#x3D; QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(3).x())&#x2F;2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(3).y())&#x2F;2));
        &#x2F;&#x2F;计算到左侧边中点的距离
        qreal dis &#x3D; sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));
        qreal dis2LT &#x3D; sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));
        qreal dis2RT &#x3D; sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));
        if(dis&lt;16||dis2LT&lt;dis2RT)
        &#123;
            return;
        &#125;
        else
        &#123;
            QRectF newRect(m_oldRect);
            newRect.setLeft(m_oldRect.left());
            newRect.setRight(m_oldRect.left()+dis);
            setRectSize(newRect,false);
            m_RotateCenter&#x3D;QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())&#x2F;2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())&#x2F;2);
            m_oldRect.moveCenter(m_RotateCenter);
            setRectSize(m_oldRect);
            scene()-&gt;update();&#x2F;&#x2F;必须要用scene()-&gt;update()，不能用update();否则会出现重影
        &#125;
    &#125;
    else if(m_StateFlag &#x3D;&#x3D; MOV_BOTTOM_LINE)
    &#123;
        &#x2F;&#x2F;顶边中点
        QPointF pf &#x3D; QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(1).x())&#x2F;2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(1).y())&#x2F;2));
        &#x2F;&#x2F;计算到底边中点的距离
        qreal dis &#x3D; sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));
        qreal dis2LT &#x3D; sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));
        qreal dis2LB &#x3D; sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));
        if(dis&lt;16||dis2LT&lt;dis2LB)
        &#123;
            return;
        &#125;
        else
        &#123;
            QRectF newRect(m_oldRect);
            newRect.setTop(m_oldRect.top());
            newRect.setBottom(m_oldRect.top()+dis);
            setRectSize(newRect,false);
            m_RotateCenter&#x3D;QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())&#x2F;2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())&#x2F;2);
            m_oldRect.moveCenter(m_RotateCenter);
            setRectSize(m_oldRect);
            scene()-&gt;update();&#x2F;&#x2F;必须要用scene()-&gt;update()，不能用update();否则会出现重影
        &#125;
    &#125;
&#125;

void myGraphicRectItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
&#123;
    setCursor(Qt::ArrowCursor);
    if(m_StateFlag &#x3D;&#x3D; MOV_RECT)
    &#123;
        m_StateFlag &#x3D; DEFAULT_FLAG;
    &#125;
    else &#123;
        QGraphicsItem::mouseReleaseEvent(event);
    &#125;
&#125;

void myGraphicRectItem::SetRotate(qreal RotateAngle, QPointF ptCenter)
&#123;
    m_bRotate &#x3D; true;
    if(ptCenter.x()&#x3D;&#x3D;-999 &amp;&amp; ptCenter.y()&#x3D;&#x3D;-999)
    &#123;
        m_RotateCenter &#x3D; QPointF(m_oldRect.x()+m_oldRect.width()&#x2F;2,m_oldRect.y()+m_oldRect.height()&#x2F;2);
    &#125;
    else
    &#123;
        m_RotateCenter &#x3D; ptCenter;
    &#125;
    m_RotateAngle &#x3D; RotateAngle;
    this-&gt;update();
&#125;

QPointF myGraphicRectItem::getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle)
&#123;
    double dx &#x3D; ptCenter.x();
    double dy &#x3D; ptCenter.y();
    double x &#x3D; ptIn.x();
    double y &#x3D; ptIn.y();
    double xx,yy;
    xx &#x3D; (x-dx)*cos(angle*M_PI&#x2F;180)-(y-dy)*sin(angle*M_PI&#x2F;180)+dx;
    yy &#x3D; (x-dx)*sin(angle*M_PI&#x2F;180)+(y-dy)*cos(angle*M_PI&#x2F;180)+dy;

    return QPointF(xx,yy);
&#125;

QList&lt;QPointF&gt; myGraphicRectItem::getRotatePoints(QPointF ptCenter, QList&lt;QPointF&gt; ptIns, qreal angle)
&#123;
    QList&lt;QPointF&gt; lstPt;
    for(int i &#x3D; 0;i&lt;ptIns.count();i++)
    &#123;
        lstPt.append(getRotatePoint(ptCenter,ptIns.at(i),angle));
    &#125;
    return lstPt;
&#125;

QPolygonF myGraphicRectItem::getRotatePolygonFromRect(QPointF ptCenter, QRectF rectIn, qreal angle)
&#123;
    QVector&lt;QPointF&gt; vpt;
    QPointF pf &#x3D; getRotatePoint(ptCenter,rectIn.topLeft(),angle);
    vpt.append(pf);
    pf &#x3D; getRotatePoint(ptCenter,rectIn.topRight(),angle);
    vpt.append(pf);
    pf &#x3D; getRotatePoint(ptCenter,rectIn.bottomRight(),angle);
    vpt.append(pf);
    pf &#x3D; getRotatePoint(ptCenter,rectIn.bottomLeft(),angle);
    vpt.append(pf);
    pf &#x3D; getRotatePoint(ptCenter,rectIn.topLeft(),angle);
    vpt.append(pf);
    return QPolygonF(vpt);
&#125;

QRectF myGraphicRectItem::getCrtPosRectToSceen()
&#123;
    QRectF retRect &#x3D; QRectF(m_oldRect.x()+pos().x(),m_oldRect.y()+pos().y(),m_oldRect.width(),m_oldRect.height());
    return retRect;
&#125;
QRectF myGraphicRectItem::getSmallRotateRect(QPointF ptA,QPointF ptB)
&#123;
    QPointF pt &#x3D; getSmallRotateRectCenter(ptA,ptB);
    return QRectF(pt.x()-10,pt.y()-10,20,20);
&#125;
QPointF myGraphicRectItem::getSmallRotateRectCenter(QPointF ptA,QPointF ptB)
&#123;
    QPointF ptCenter &#x3D; QPointF((ptA.x()+ptB.x())&#x2F;2,(ptA.y()+ptB.y())&#x2F;2);&#x2F;&#x2F;A,B点的中点C
    &#x2F;&#x2F;中垂线方程式为 y&#x3D;x*k + b;
    qreal x,y;&#x2F;&#x2F;旋转图标矩形的中心
    if(abs(ptB.y()-ptA.y())&lt;0.1)
    &#123;
        if(ptA.x()&lt;ptB.x())&#x2F;&#x2F;矩形左上角在上方
        &#123;
            x &#x3D; ptCenter.x();
            y &#x3D; ptCenter.y()-20;
        &#125;
        else&#x2F;&#x2F;矩形左上角在下方
        &#123;
            x &#x3D; ptCenter.x();
            y &#x3D; ptCenter.y()+20;
        &#125;
    &#125;
    else if(ptB.y()&gt;ptA.y())&#x2F;&#x2F;顺时针旋转0-180
    &#123;
        qreal k &#x3D; (ptA.x()-ptB.x())&#x2F;(ptB.y()-ptA.y());&#x2F;&#x2F;中垂线斜率
        qreal b &#x3D; (ptA.y()+ptB.y())&#x2F;2-k*(ptA.x()+ptB.x())&#x2F;2;
        &#x2F;&#x2F;求AB线中垂线上离AB中点20个像素的点C的坐标
        x &#x3D; 20*cos(atan(k))+ptCenter.x();
        y &#x3D; k*x+b;
    &#125;
    else if(ptB.y()&lt;ptA.y())&#x2F;&#x2F;顺时针旋转180-360
    &#123;
        qreal k &#x3D; (ptA.x()-ptB.x())&#x2F;(ptB.y()-ptA.y());&#x2F;&#x2F;中垂线斜率
        qreal b &#x3D; (ptA.y()+ptB.y())&#x2F;2-k*(ptA.x()+ptB.x())&#x2F;2;
        &#x2F;&#x2F;求AB线中垂线上离AB中点20个像素的点C的坐标
        x &#x3D; -20*cos(atan(k))+ptCenter.x();
        y &#x3D; k*x+b;
    &#125;
    return QPointF(x,y);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="功能3：Qt中设置QGraphicsView的背景色为透明且无边框"><a href="#功能3：Qt中设置QGraphicsView的背景色为透明且无边框" class="headerlink" title="功能3：Qt中设置QGraphicsView的背景色为透明且无边框"></a>功能3：Qt中设置<code>QGraphicsView</code>的背景色为透明且无边框</h3><ol>
<li>设置背景色为透明：在<code>QGraphicsView</code>上调用<code>setStyleSheet()</code>方法，并将背景色样式设置为透明。示例代码如下：</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">QGraphicsView* view &#x3D; new QGraphicsView;
view-&gt;setStyleSheet(&quot;background-color: transparent;&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="2">
<li>设置边框：在<code>QGraphicsView</code>上调用<code>setFrameStyle()</code>方法，并将边框样式设置为无边框。示例代码如下：</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">QGraphicsView* view &#x3D; new QGraphicsView;
view-&gt;setFrameStyle(QFrame::NoFrame);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在Qt中使用一个按钮清除<code>QGraphicsView</code>上监控的图片<code>QGraphicsPixmapItem</code>上画出来不需要的矩形<code>QGraphicsRectItem</code></p>
<ol>
<li><p>首先，在<code>QGraphicsView</code>上绑定一个按钮<code>QPushButton</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">QPushButton* clearBtn &#x3D; new QPushButton(view);
# 将按钮放置在view的左下角
btn.setGeometry(0,view.geometry().height()-40,40,20);
btn.setText(&quot;clear&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>给按钮绑定槽函数，用于清除矩形</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#在.h文件中定义槽函数
private slots:
	void on_btn_clicked();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"># 在构造函数中绑定槽函数
connect(clearBtn,SIGNAL(clicked()),this,SLOT(on_btn_clicked()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"># 槽函数的具体实现
void ImgHelper::on_btn_clicked()&#123;
	rectcounts &#x3D; 0;	#设矩形个数为0
	scene-&gt;clear();	# 清空scene
	imgUpdated(cloneImage);	# 将直接保存的监控图片重新添加进scene
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="功能4：保存错误图片"><a href="#功能4：保存错误图片" class="headerlink" title="功能4：保存错误图片"></a>功能4：保存错误图片</h3><p>当发现监控的图片有问题时，就可以一键保存监控的图片，按日期创建文件夹，方便查看问题</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ImgHelper::onSaveErrorImage()
&#123;
    &#x2F;&#x2F;20230908
    QString currentPath &#x3D; QDir::currentPath();

    QString filedir &#x3D; currentPath + QDir::separator() + &quot;errorImg&quot;;
    QDir dir(filedir);
    if(!dir.exists())&#123;
       if(dir.mkdir(filedir))&#123;

       &#125;else&#123;
           qDebug()&lt;&lt;&quot;创建目录失败&quot;;
       &#125;
    &#125;
    QString nowDate &#x3D; QDateTime::QDateTime::currentDateTime().toString(&quot;yyyy-MM-dd&quot;) ;
    QString filedirdate &#x3D; filedir + QDir::separator() + nowDate;
    QDir dirdate(filedirdate);
    if(!dirdate.exists())&#123;
       if(dirdate.mkdir(filedirdate))&#123;

       &#125;else&#123;
           qDebug()&lt;&lt;&quot;创建目录失败&quot;;
       &#125;
    &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; 8; i++)&#123;
        QString imgpath &#x3D; filedirdate + QDir::separator() + &quot;tt&quot; + QString::number(i) +&quot;.bmp&quot;;
        QFile file(imgpath);
        &#x2F;&#x2F;判断文件是否存在
        if(file.exists())&#123;
           continue;
        &#125;
        if(pixmapItem !&#x3D; NULL)&#123;
            pixmapItem-&gt;pixmap().save(imgpath);
        &#125;
        break;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="功能5：修复图片通道异常"><a href="#功能5：修复图片通道异常" class="headerlink" title="功能5：修复图片通道异常"></a>功能5：修复图片通道异常</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;2023926加  修复PLC查看图片出现的通道异常
        for(int x &#x3D; 0 ; x &lt; image.height(); x++)&#123;
                    for(int y &#x3D; 0 ; y &lt; image.width(); y++)&#123;
                        QRgb pixel &#x3D; image.pixel(x,y);
                        int red &#x3D; qBlue(pixel);
                        int green &#x3D;qRed(pixel);
                        int blue &#x3D; qGreen(pixel);
                        QRgb newpixel &#x3D; qRgb(red,green,blue);
                        image.setPixel(x,y,newpixel);

                    &#125;
                &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/c/">c++</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Qt/">Qt</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2023/10/28/%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8-C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/"
                                   title="基于epoll的web服务器(C语言版本)"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">基于epoll的web服务器(C语言版本)</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2023/10/20/%E8%A7%A3%E6%9E%90Http%E5%8D%8F%E8%AE%AE/"
                                   title="解析Http协议"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">解析Http协议</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2023
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Keep Team</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            

            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        

        <!-- PC go comment -->
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->


<!-- lazyload -->


<div class="">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- category-page -->
    

    <!-- links-page -->
    

    <!-- photos-page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
