<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++11新特性（I）</title>
      <link href="/2023/10/31/C-11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88I%EF%BC%89/"/>
      <url>/2023/10/31/C-11%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88I%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><h3 id="1-auto-自动推导类型"><a href="#1-auto-自动推导类型" class="headerlink" title="1. auto 自动推导类型"></a>1. auto 自动推导类型</h3><p><code>auto</code>可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型</p><pre><code class="c++">int a = 10;auto b = a;//自动推断类型，b为 int类型auto c = 1.9;//自动推断类型，c为double类型auto d = 1.2e12L;//自动推断类型，d 是 long double</code></pre><h3 id="2-using-定义别名"><a href="#2-using-定义别名" class="headerlink" title="2. using 定义别名"></a>2. using 定义别名</h3><p>之前在 C++中可以通过<code> typedef</code> 重定义一个类型，语法格式如下：</p><pre><code class="c++">typedef 旧的类型名 新的类型名;// 使用举例typedef unsigned int uint_t;</code></pre><p>关键字<code>using</code>作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。<strong>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用<code>typedef</code>定义的别名和使用<code>using</code>定义的别名在语义上是等效的。</strong></p><pre><code class="c++">using 新的类型 = 旧的类型;// 使用举例using uint_t = int;</code></pre><p>定义函数指针</p><pre><code class="c++">// 使用typedef定义函数指针typedef int(*func_ptr)(int, double);// 使用using定义函数指针using func_ptr1 = int(*)(int, double);</code></pre><p>在C++11中，新增了一个特性就是可以通过使用<code>using</code>来为一个模板定义别名，但是<code>typedef</code>不行</p><pre><code class="c++">template &lt;typename T&gt;using mymap = map&lt;int, T&gt;;</code></pre><p><code>using</code>语法和<code>typedef</code>一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。<code>using</code>相较于<code>typedef</code>的优势在于<strong>定义函数指针别名时看起来更加直观，并且可以给模板定义别名</strong>。</p><h3 id="3-右值引用"><a href="#3-右值引用" class="headerlink" title="3. &amp;&amp; 右值引用"></a>3. &amp;&amp; 右值引用</h3><ol><li><strong>左值是指存储在内存中、有明确存储地址（可取地址）的数据；</strong></li><li><strong>右值是指可以提供数据值的数据（不可取地址）；</strong></li></ol><p>右值分两种：</p><ol><li>纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等</li><li>将亡值：与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值、 std::move 的返回值等。</li></ol><ul><li><p><strong>右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高C++应用程序的性能。</strong></p></li><li><p><strong>移动构造中使用了右值引用，会将临时对象中的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。</strong></p></li></ul><ol><li>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</li><li>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</li><li>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。</li><li>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。</li></ol><h3 id="4-nullptr-标识空指针"><a href="#4-nullptr-标识空指针" class="headerlink" title="4. nullptr 标识空指针"></a>4. nullptr 标识空指针</h3><p>在C++中<code>NULL</code>和<code>0</code>是等价的，C++11 标准并没有对 NULL 的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字<code>nullptr</code>。<code>nullptr </code>专用于初始化空类型指针，不同类型的指针变量都可以使用 <code>nullptr </code>来初始化。</p><pre><code class="c++">int*    ptr1 = nullptr;char*   ptr2 = nullptr;double* ptr3 = nullptr;</code></pre><p><code>NULL</code>底层源码</p><pre><code class="c++">#ifndef NULL    #ifdef __cplusplus        #define NULL 0    #else        #define NULL ((void *)0)    #endif#endif</code></pre><p>C++ 中，<code>void * </code>类型无法隐式转换为其他类型的指针，此时使用 <code>0 </code>代替 <code>(void *)0)</code>，用于解决空指针的问题。</p><p><strong><code>nullptr</code> 无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11 标准下，相比 <code>NULL</code> 和<code> 0</code>，使用 <code>nullptr</code> 初始化空指针可以令我们编写的程序更加健壮</strong></p><h3 id="5-decltype-类型推导"><a href="#5-decltype-类型推导" class="headerlink" title="5. decltype 类型推导"></a>5. decltype 类型推导</h3><p><code>decltype</code>类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 </p><pre><code class="c++">int getSize();int main(void)&#123;    int tempA = 2;        /*1.dclTempA为int*/    decltype(tempA) dclTempA;    /*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize，*/    decltype(getSize()) dclTempB;    return 0;&#125;</code></pre><p> <code>decltype</code>和<code>auto</code>都可以用来推断类型，但是二者有几处明显的差异： </p><ol><li><p><code>auto</code>忽略顶层<code>const</code>，<code>decltype</code>保留顶层<code>const</code>；</p></li><li><p>对引用操作，<code>auto</code>推断出原有类型，<code>decltype</code>推断出引用； </p></li><li><p>对解引用操作，<code>auto</code>推断出原有类型，<code>decltype</code>推断出引用； </p></li><li><p><code>auto</code> 推断时会实际执行，<code>ecltype</code>不会执行，只做分析。 总之在使用中过程中和<code>const</code>、引用和指针结合时需要特别小心。</p></li></ol><h3 id="6-委托构造"><a href="#6-委托构造" class="headerlink" title="6. 委托构造"></a>6. 委托构造</h3><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的</p><pre><code class="c++">class Base &#123;public:    int value1;    int value2;    Base() &#123;        value1 = 1;    &#125;    Base(int value) : Base() &#123;  // 委托 Base() 构造函数        value2 = 2;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于epoll的web服务器(C语言版本)</title>
      <link href="/2023/10/28/%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8-C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/"/>
      <url>/2023/10/28/%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8-C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>记录学习使用epoll实现web服务器</p><span id="more"></span><h2 id="基于epoll的web服务器-C语言版本"><a href="#基于epoll的web服务器-C语言版本" class="headerlink" title="基于epoll的web服务器(C语言版本)"></a>基于epoll的web服务器(C语言版本)</h2><h3 id="1-初始化监听套接字"><a href="#1-初始化监听套接字" class="headerlink" title="1. 初始化监听套接字"></a>1. 初始化监听套接字</h3><p>包括创建监听套接字，设置端口复用，绑定，设置监听等步骤</p><h4 id="1-1-创建监听套接字（socket函数）"><a href="#1-1-创建监听套接字（socket函数）" class="headerlink" title="1.1 创建监听套接字（socket函数）"></a>1.1 创建监听套接字（socket函数）</h4><p><code>socket()</code>打开一个网络通讯端口，如果成功的话，就像<code>open()</code>一样返回一个文件描述符，应用程序可以像读写文件一样用<code>read/write</code>在网络上收发数据，如果<code>socket()</code>调用出错则返回<code>-1</code>。对于<code>IPv4</code>，<code>domain</code>参数指定为<code>AF_INET</code>。对于<code>TCP</code>协议，<code>type</code>参数指定为<code>SOCK_STREAM</code>，表示面向流的传输协议。如果是<code>UDP</code>协议，则<code>type</code>参数指定为<code>SOCK_DGRAM</code>，表示面向数据报的传输协议。<code>protocol</code>参数的介绍从略，指定为0即可。</p><pre><code class="txt">#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);domain:    AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址    AF_INET6 与上面类似，不过是来用IPv6的地址    AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用type:    SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。    SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。    SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。    SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）    SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序protocol:    传0 表示使用默认协议。返回值：    成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</code></pre><h4 id="1-2-设置端口复用（setsockopt函数）"><a href="#1-2-设置端口复用（setsockopt函数）" class="headerlink" title="1.2 设置端口复用（setsockopt函数）"></a>1.2 设置端口复用（setsockopt函数）</h4><p>在<code>server</code>的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是<code>connfd</code>（127.0.0.1:6666）没有完全断开，而我们重新监听的是<code>listenfd</code>（0.0.0.0:6666），虽然是占用同一个端口，但<code>IP</code>地址不同，<code>connfd</code>对应的是与某个客户端通讯的一个具体的<code>IP</code>地址，而<code>listenfd</code>对应的是<code>wildcard address</code>。解决这个问题的方法是使用<code>setsockopt()</code>设置<code>socket</code>描述符的选项<code>SO_REUSEADDR</code>为1，表示允许创建端口号相同但<code>IP</code>地址不同的多个<code>socket</code>描述符。</p><p>在server代码的socket()和bind()调用之间插入如下代码：</p><pre><code class="c">int opt = 1;setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</code></pre><h4 id="1-3-绑定（bind函数）"><a href="#1-3-绑定（bind函数）" class="headerlink" title="1.3 绑定（bind函数）"></a>1.3 绑定（bind函数）</h4><p>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用<code>bind</code>绑定一个固定的网络地址和端口号。</p><pre><code class="txt">#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockfd：    socket文件描述符addr:    构造出IP地址加端口号addrlen:    sizeof(addr)长度返回值：    成功返回0，失败返回-1, 设置errno</code></pre><p><code>bind()</code>的作用是将参数<code>sockfd</code>和<code>addr</code>绑定在一起，使<code>sockfd</code>这个用于网络通讯的文件描述符监听<code>addr</code>所描述的地址和端口号。前面讲过，<code>struct sockaddr *</code>是一个通用指针类型，<code>addr</code>参数实际上可以接受多种协议的<code>sockaddr</code>结构体，而它们的长度各不相同，所以需要第三个参数<code>addrlen</code>指定结构体的长度。如：</p><pre><code class="c">struct sockaddr_in addr;bzero(&amp;addr, sizeof(addr));servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY = 0servaddr.sin_port = htons(8888);</code></pre><p>首先将整个结构体清零，然后设置地址类型为<code>AF_INET</code>，<strong>网络地址为</strong><code>INADDR_ANY</code>**，这个宏表示本地的任意<code>IP</code><strong>地址</strong>，因为服务器可能有多个网卡，每个网卡也可能绑定多个<code>IP</code>地址，这样设置可以在所有的<code>IP</code>地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个<code>IP</code>地址，端口号为8888。</p><h4 id="1-4-设置监听-（listen函数）"><a href="#1-4-设置监听-（listen函数）" class="headerlink" title="1.4 设置监听 （listen函数）"></a>1.4 设置监听 （listen函数）</h4><pre><code class="txt">#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);sockfd:    socket文件描述符backlog:    排队建立3次握手队列和刚刚建立3次握手队列的链接数和(现在只表示建立链接队列的数量)</code></pre><p>查看系统默认<code>backlog</code></p><pre><code class="shell">cat /proc/sys/net/ipv4/tcp_max_syn_backlog</code></pre><p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的<code>accept()</code>返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未<code>accept</code>的客户端就处于连接等待状态，<code>listen()</code>声明<code>sockfd</code>处于监听状态，并且最多允许有<code>backlog</code>个客户端处于连接待状态，如果接收到更多的连接请求就忽略。<code>listen()</code>成功返回0，失败返回-1。</p><h4 id="1-5-初始化监听套接字（initListenFd函数）"><a href="#1-5-初始化监听套接字（initListenFd函数）" class="headerlink" title="1.5 初始化监听套接字（initListenFd函数）"></a>1.5 初始化监听套接字（initListenFd函数）</h4><pre><code class="c">// 初始化监听套接字int initListenFd(port)&#123;    // 1. 创建监听套接字    int lfd = socket(AF_INET,SOCK_STREAM,0);    if(lfd == -1)&#123;        perror(&quot;socket error&quot;);        return -1;    &#125;    // 2. 设置端口复用    int opt = 1;    int ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt));    if(ret == -1)&#123;        perror(&quot;setsockopt error&quot;);        return -1;    &#125;    // 3. 绑定    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = 0;    int ret = bind(lfd,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ret == -1)&#123;        perror(&quot;bind error&quot;);        return -1;    &#125;    // 4.设置监听    ret = listen(lfd,128);    if(ret == -1)&#123;        perror(&quot;listen error&quot;);        return -1;    &#125;    // 5. 返回fd    return lfd;&#125;</code></pre><h3 id="2-启动epoll"><a href="#2-启动epoll" class="headerlink" title="2. 启动epoll"></a>2. 启动epoll</h3><p><code>epoll</code>是<code>Linux</code>下<strong>IO多路复用</strong>接口<code>select/poll</code>的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入<code>Ready</code>队列的描述符集合就行了。</p><p><code>epoll</code>除了提供<code>select/poll</code>那种IO事件的水平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少<code>epoll_wait/epoll_pwait</code>的调用，提高应用程序效率。</p><h4 id="2-1-创建epoll树-epoll-create"><a href="#2-1-创建epoll树-epoll-create" class="headerlink" title="2.1 创建epoll树  (epoll_create)"></a>2.1 创建epoll树  (epoll_create)</h4><p> 创建一个<code>epoll</code>句柄，参数<code>size</code>用来告诉内核监听的文件描述符的个数，跟内存大小有关。(<strong>参数size已经弃用，只需提供大于0的数字就行</strong>)</p><pre><code class="txt">#include &lt;sys/epoll.h&gt;int epoll_create(int size)size：监听数目（内核参考值）返回值：成功：非负文件描述符；失败：-1，设置相应的errno</code></pre><p>可以使用cat命令查看一个进程可以打开的socket描述符上限。</p><pre><code class="shell">cat /proc/sys/fs/file-max806425</code></pre><p>如有需要，可以通过修改配置文件的方式修改该上限值。</p><pre><code class="txt">sudo vi /etc/security/limits.conf在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。* soft nofile 65536* hard nofile 100000</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20231026200903197.png" alt="image-20231026200903197"></p><h4 id="2-2-上树（epoll-ctl函数）"><a href="#2-2-上树（epoll-ctl函数）" class="headerlink" title="2.2 上树（epoll_ctl函数）"></a>2.2 上树（epoll_ctl函数）</h4><p>控制某个<code>epoll</code>监控的文件描述符上的事件：注册、修改、删除。</p><pre><code class="txt">#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)    epfd：为epoll_creat的句柄    op：表示动作，用3个宏来表示：    EPOLL_CTL_ADD (注册新的fd到epfd)，    EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，    EPOLL_CTL_DEL (从epfd删除一个fd)；    event：告诉内核需要监听的事件struct epoll_event &#123;    __uint32_t events; /* Epoll events */    epoll_data_t data; /* User data variable */&#125;;typedef union epoll_data &#123;    void *ptr;    int fd;    uint32_t u32;    uint64_t u64;&#125; epoll_data_t;EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）EPOLLOUT：表示对应的文件描述符可以写EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）EPOLLERR：表示对应的文件描述符发生错误EPOLLHUP：表示对应的文件描述符被挂断；EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里返回值：成功：0；失败：-1，设置相应的errno</code></pre><h4 id="2-3-检测（epoll-wait函数）"><a href="#2-3-检测（epoll-wait函数）" class="headerlink" title="2.3 检测（epoll_wait函数）"></a>2.3 检测（epoll_wait函数）</h4><p>等待所监控文件描述符上有事件的产生，类似于<code>select()</code>调用。</p><pre><code class="txt">#include &lt;sys/epoll.h&gt;    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)    events：用来存内核得到事件的集合，可简单看作数组。    maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，    timeout：是超时时间    -1：阻塞    0：立即返回，非阻塞    &gt;0：指定毫秒    返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</code></pre><h4 id="2-4-启动epoll-epollrun函数"><a href="#2-4-启动epoll-epollrun函数" class="headerlink" title="2.4 启动epoll(epollrun函数)"></a>2.4 启动epoll(epollrun函数)</h4><pre><code class="c">//启动epollvoid epollrun(int lfd)&#123;    // 1. 创建epoll树    int epfd = epoll_create(1);    if(epfd == -1)&#123;        perror(&quot;epoll_create error&quot;);        return -1;    &#125;    // 2. lfd上树    struct epoll_event ev;    ev.data.fd = lfd;    ev.events = EPOLLIN;    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    // 3. 检测(委托内核检测添加到树上的节点)    struct epoll_event evs[1024];    int size = siezof(evs) / sizeof(struct epoll_event);    while(1)&#123;        int num = epoll_wait(epfd,evs,size,-1);        if(num == -1) &#123;            perror(&quot;epoll_wait error&quot;);            return -1;        &#125;        // 遍历发生变化的节点        for(int i = 0; i &lt; num; ++i)&#123;            if(!(evs[i].events &amp; EPOLLIN)) &#123;                // 不是读事件                continue;            &#125;            int fd = evs[i].data.fd;            if(fd == lfd)&#123;                // 建立新连接 accept                acceptClient(lfd,epfd);            &#125;else&#123;                // 主要是接受对端的数据(读数据)                recvHttpRequest(fd,epfd);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="3-建立连接"><a href="#3-建立连接" class="headerlink" title="3. 建立连接"></a>3. 建立连接</h3><h4 id="3-1-建立连接-（accept函数）"><a href="#3-1-建立连接-（accept函数）" class="headerlink" title="3.1 建立连接 （accept函数）"></a>3.1 建立连接 （accept函数）</h4><p><strong>三方握手完成后，服务器调用<code>accept()</code>接受连接</strong>，如果服务器调用<code>accept()</code>时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。<code>addr</code>是一个传出参数，<code>accept()</code>返回时传出客户端的地址和端口号。<code>addrlen</code>参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区<code>addr</code>的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给<code>addr</code>参数传<code>NULL</code>，表示不关心客户端的地址。</p><pre><code class="txt">#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);sockdf:    socket文件描述符addr:    传出参数，返回链接客户端地址信息，含IP地址和端口号addrlen:    传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小返回值：    成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</code></pre><p>我们的服务器程序结构是这样的：</p><pre><code class="c">while (1) &#123;    cliaddr_len = sizeof(cliaddr);    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);    n = read(connfd, buf, MAXLINE);    ......    close(connfd);&#125;</code></pre><p>整个是一个while死循环，每次循环处理一个客户端连接。由于<code>cliaddr_len</code>是传入传出参数，每次调用<code>accept()</code>之前应该重新赋初值。<code>accept()</code>的参数<code>listenfd</code>是先前的监听文件描述符，而<code>accept()</code>的返回值是另外一个文件描述符<code>connfd</code>，之后与客户端之间就通过这个<code>connfd</code>通讯，最后关闭<code>connfd</code>断开连接，而不关闭<code>listenfd</code>，再次回到循环开头<code>listenfd</code>仍然用作<code>accept</code>的参数。<code>accept()</code>成功返回一个文件描述符，出错返回-1。</p><h4 id="3-2-epoll事件模型"><a href="#3-2-epoll事件模型" class="headerlink" title="3.2 epoll事件模型"></a>3.2 epoll事件模型</h4><p><code>EPOLL</code>事件有两种模型：</p><ul><li><p><code>Edge Triggered (ET) </code>边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p></li><li><p><code>Level Triggered (LT) </code>水平触发只要有数据都会触发。</p></li></ul><pre><code class="txt">思考如下步骤：1.假定我们已经把一个用来从管道中读取数据的文件描述符(rfd)添加到epoll描述符。2.管道的另一端写入了2KB的数据3.调用epoll_wait，并且它会返回rfd，说明它已经准备好读取操作4.读取1KB的数据5.调用epoll_wait……</code></pre><p><strong>ET模式 即Edge Triggered工作模式（边沿触发）</strong></p><p>如果我们在第1步将<code>rfd</code>添加到<code>epoll</code>描述符的时候使用了<code>EPOLLET</code>标志，那么在第5步调用<code>epoll_wait</code>之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 <code>ET</code> 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。<code>epoll</code>工作在<code>ET</code>模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用<code>ET</code>模式的<code>epoll</code>接口，在后面会介绍避免可能的缺陷。</p><ul><li><p>基于非阻塞文件句柄</p></li><li><p>只有当<code>read</code>或者<code>write</code>返回<code>EAGAIN</code>(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次<code>read</code>时都需要循环读，直到读到产生一个<code>EAGAIN</code>才认为此次事件处理完成，当<code>read</code>返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</p></li></ul><p><strong>LT模式即Level Triggered工作模式(水平触发)</strong></p><p>与<code>ET</code>模式不同的是，以<code>LT</code>方式调用<code>epoll</code>接口的时候，它就相当于一个速度比较快的<code>poll</code>，无论后面的数据是否被使用。</p><p><strong>比较</strong></p><p><code>LT(level triggered)</code>：<code>LT</code>是<strong>缺省</strong>的工作方式，并且同时支持<code>block</code>和<code>no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的<code>fd</code>进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。**传统的<code>select/poll</code>**都是这种模型的代表。</p><p><code>ET(edge-triggered)</code>：**<code>ET</code>是高速工作方式，只支持<code>no-block socket</code>**。在这种模式下，当描述符从未就绪变为就绪时，内核通过<code>epoll</code>告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个<code>fd</code>作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知<code>**(only once)**</code>.</p><h4 id="3-3-阻塞与非阻塞"><a href="#3-3-阻塞与非阻塞" class="headerlink" title="3.3 阻塞与非阻塞"></a>3.3 阻塞与非阻塞</h4><ul><li>非阻塞模式可以理解为，执行此套接字的网络调用时，不管是否执行成功，都会立即返回。</li></ul><p>​如调用<code>recv( )</code>函数读取网络缓冲区中的数据时，不管是否读到数据都立即返回，而不会一直挂在此函数的调用上。</p><ul><li>阻塞模式为只有接收到数据后才会返回，套接字默认的会创建堵塞模式。</li></ul><h4 id="3-4-建立连接（accpetClient函数）"><a href="#3-4-建立连接（accpetClient函数）" class="headerlink" title="3.4 建立连接（accpetClient函数）"></a>3.4 建立连接（accpetClient函数）</h4><pre><code class="c">int accpetClient(int lfd,int epfd)&#123;    // 1. 建立连接    struct sockaddr_in cliaddr;    socklen_t len = sizeof(cliaddr);    cliaddr.sin_family = AF_INET;    int cfd = accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len);    if(cfd == -1)&#123;        perror(&quot;accept error&quot;);        return -1;    &#125;    char ip[16]=&quot;&quot;;    printf(&quot;new client ip=%s port=%d\n&quot;,    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));        // 2. 设置非阻塞    int flag = fcntl(cfd,F_GETFL);    flag |= O_NONBLOCK;    fcntl(cfd,F_SETFL,flag);    // 3. cfd添加到epoll    struct epoll_event ev;    ev.data.fd = cfd;    ev.events = EPOLLIN | EPOLLET;      //边沿模式    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    return 0;&#125;</code></pre><h3 id="4-接收客户端发来的http请求"><a href="#4-接收客户端发来的http请求" class="headerlink" title="4. 接收客户端发来的http请求"></a>4. 接收客户端发来的http请求</h3><h4 id="4-1-接收数据-（recv函数）"><a href="#4-1-接收数据-（recv函数）" class="headerlink" title="4.1 接收数据 （recv函数）"></a>4.1 接收数据 （recv函数）</h4><p>接收来自<code>socket</code>缓冲区的数据，当缓冲区没有数据可取时，<code>recv</code>会一直处于阻塞状态()，直到缓冲区至少又一个字节数据可读取，或者对端关闭，并读取所有数据后返回。</p><pre><code class="txt">#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;int recv(int sockfd, char * buf, int len, int flags);sockfd：连接的fdbuf：用于接收数据的缓冲区len：缓冲区长度flags：指定调用方式返回值：成功返回实际读到的字节数。如果recv在copy时出错，那么它返回err，err小于0；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</code></pre><p><strong>read</strong></p><p><code>read</code>函数从文件描述符（包括<code>TCP Socket</code>）中读取数据，并将读取的数据存储到指定的缓冲区中。</p><pre><code class="txt">ssize_t read(int fd, void *buf, size_t count);fd：要读取数据的文件描述符，可以是TCP Socket。buf：存储读取数据的缓冲区。count：要读取的字节数。返回值：成功时返回实际读取的字节数，失败时返回-1，并设置errno变量来指示错误的原因。</code></pre><p><code>read</code>函数和<code>recv</code>函数都是阻塞调用，即在没有数据可读时会一直阻塞等待。它们的主要区别在于<code>recv</code>函数可以通过<code>flags</code>参数控制一些特殊的行为，如设置<code>MSG_PEEK</code>标志来预览数据而不将其从缓冲区中移除。</p><h4 id="4-2-EAGAIN错误"><a href="#4-2-EAGAIN错误" class="headerlink" title="4.2 EAGAIN错误"></a>4.2 EAGAIN错误</h4><p>以<code>O_NONBLOCK</code>的标志打开文件<code>/socket/FIFO</code>，如果你连续做<code>read</code>或者<code>recv</code>操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，<code>read</code>函数会返回一个错误<code>EAGAIN</code>，提示你的应用程序现在没有数据可读请稍后再试。</p><pre><code class="txt">（epoll的ET模式下设置recv，对应的fd文件描述符设置为非阻塞）下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。</code></pre><h4 id="4-3-接受http请求（recvHttpRequest函数）"><a href="#4-3-接受http请求（recvHttpRequest函数）" class="headerlink" title="4.3 接受http请求（recvHttpRequest函数）"></a>4.3 接受http请求（recvHttpRequest函数）</h4><pre><code class="c">int recvHttpRequest(int cfd,int epfd)&#123;    char buf[4096] = &#123; 0 &#125;;    char tmp[1024] = &#123; 0 &#125;;    int len = 0;    int total = 0;    // 1. 接收数据    while((len = recv(cfd,tmp,sizeof(tmp),0)) &gt; 0)&#123;        if(total + len &lt; sizeof(buf))&#123;            memcpy(buf + total,tmp,len);        &#125;        total += len;    &#125;    // 2. 判断数据是否接受完毕    if(len == -1 &amp;&amp; errno == EAGAIN)&#123;        // 解析请求行           /*        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19        G E T   / 1 . t x t H  T  T  P  /  1  .  1  /r /n        */        char* pt = strstr(buf,&quot;\r\n&quot;);  //大字符串找小字符串        int reqLen = pt - buf;        buf[reqLen] = &#39;\0&#39;;    &#125;    else if(len == 0)&#123;        // 客户端断开连接        epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);    &#125;    else&#123;        perror(&quot;recv error&quot;);    &#125;    return 0;&#125;</code></pre><h3 id="5-解析请求行"><a href="#5-解析请求行" class="headerlink" title="5. 解析请求行"></a>5. 解析请求行</h3><h4 id="5-1-格式化拆分字符串-（sscanf函数）"><a href="#5-1-格式化拆分字符串-（sscanf函数）" class="headerlink" title="5.1 格式化拆分字符串 （sscanf函数）"></a>5.1 格式化拆分字符串 （sscanf函数）</h4><pre><code class="txt">sprintf（）是把格式化数据输出成（存储到）字符串。sscanf（）是从字符串中读取格式化的数据。</code></pre><pre><code class="txt">// 函数原型// 将参数str的字符串根据参数format字符串来转换并格式化数据，转换后的结果存于对应的参数内。sscanf(const char *str, const char *format, ...)。具体功能如下：（1）根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。（2）取指定长度的字符串（3）取到指定字符为止的字符串（4）取仅包含指定字符集的字符串（5）取到指定字符集为止的字符串// 可以使用正则表达式进行字符串的拆分// shell脚本的时候, 会将正则表达式, 其实就是字符串的匹配规则, 用特殊字符来描述一类字符串/*正则匹配规则:    [1-9]: 匹配一个字符, 这个字符在 1-9 范围内就满足条件    [2-7]: 匹配一个字符, 这个字符在 2-7 范围内就满足条件    [a-z]: 匹配一个字符, 这个字符在 a-z 范围内就满足条件    [A,b,c,D, e, f]: 匹配一个字符, 这个字符是集合中任意一个就满足条件    [1-9, f-x]: 匹配一个字符, 这个字符是1-9, 或者f-x 集合中的任意一个就满足条件    [^1]: ^代表否定, 匹配一个字符,这个字符只要不是1就满足条件    [^2-8]: 匹配一个字符,这个字符只要不在 2-8 范围内就满足条件    [^a-f]: 匹配一个字符,这个字符只要不在 a-f 范围内就满足条件    [^ ]: 匹配一个字符,这个字符只要不是空格就满足条件使用正则表达式如何取匹配字符串:举例:     字符串 ==&gt; abcdefg12345AABBCCDD890    正则表达式: [1-9][a-z], 可以匹配两个字符    匹配方式: 从原始字符串开始位置遍历, 每遍历一个字符都需要和正则表达式进行匹配,         满足条件继续向后匹配, 不满足条件, 匹配结束        从新开始: 从正则表达式的第一个字符重新开始向后一次匹配            当整个大字符串被匹配一遍, 就结束了    abcdefg12345AABBCCDD893b        - 匹配到一个子字符串: 3b    1a2b3c4d5e6f7g12345AABBCCDD893b     - 1a     - 2b     - 3c     - 4d     - 5e     - 6f     - 7g     - 3b*/sscanf可以支持格式字符%[]：(1)-: 表示范围，如：%[1-9]表示只读取1-9这几个数字 %[a-z]表示只读取a-z小写字母，类似地 %[A-Z]只读取大写字母(2)^: 表示不取，如：%[^1]表示读取除&#39;1&#39;以外的所有字符 %[^/]表示除/以外的所有字符(3),: 范围可以用&quot;,&quot;相连接 如%[1-9,a-z]表示同时取1-9数字和a-z小写字母 (4)原则：从第一个在指定范围内的数字开始读取，到第一个不在范围内的数字结束%s 可以看成%[] 的一个特例 %[^ ](注意^后面有一个空格！)</code></pre><h4 id="5-2-转码"><a href="#5-2-转码" class="headerlink" title="5.2 转码"></a>5.2 转码</h4><pre><code class="txt">假设浏览器访问的文件名中有中文: Linux内核.jpg    - 浏览器在给服务器发送请求的时候, 会自动将中文进制转换: Linux%E5%86%85%E6%A0%B8.jpg    - 为什么要转换?        - 在http请求的请求行中不支持中文字符, 如果有中文, 浏览器就会自动将中文进行转换        - 在服务器端收到的文件名就不是原来的名字了, 因此服务器端就不能识别了        - 如果服务器端想要正确的处理, 需要将特殊字符串解析成原来的汉字        $ unicode 内UTF-8: e5 86 85 $ unicode 核UTF-8: e6 a0 b8</code></pre><h4 id="5-3-获取文件信息（stat）"><a href="#5-3-获取文件信息（stat）" class="headerlink" title="5.3 获取文件信息（stat）"></a>5.3 获取文件信息（stat）</h4><p><code>Linux</code> 下可以使用<code>stat </code>命令查看文件的属性，其实这个命令内部就是通过调用<code> stat()</code>函数来获取文件属性的，<code>stat </code>函数是 <code>Linux </code>中的系统调用，用于获取文件相关的信息。</p><pre><code class="txt">#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int stat(const char *pathname, struct stat *buf);</code></pre><pre><code class="txt">struct stat&#123;     dev_t st_dev; /* 文件所在设备的 ID */     ino_t st_ino; /* 文件对应 inode 节点编号 */     mode_t st_mode; /* 文件对应的模式 */     nlink_t st_nlink; /* 文件的链接数 */     uid_t st_uid; /* 文件所有者的用户 ID */     gid_t st_gid; /* 文件所有者的组 ID */     dev_t st_rdev; /* 设备号（指针对设备文件） */     off_t st_size; /* 文件大小（以字节为单位） */     blksize_t st_blksize; /* 文件内容存储的块大小 */     blkcnt_t st_blocks; /* 文件内容所占块数 */     struct timespec st_atim; /* 文件最后被访问的时间 */     struct timespec st_mtim; /* 文件内容最后被修改的时间 */     struct timespec st_ctim; /* 文件状态最后被改变的时间 */&#125;;st_dev：该字段用于描述此文件所在的设备。不常用，可以不用理会。st_ino：文件的 inode 编号。st_mode：该字段用于描述文件的模式，譬如文件类型、文件权限都记录在该变量中。st_nlink：该字段用于记录文件的硬链接数，也就是为该文件创建了多少个硬链接文件。链接文件可以分为软链接（符号链接）文件和硬链接文件。st_uid、st_gid：此两个字段分别用于描述文件所有者的用户 ID 以及文件所有者的组 ID。st_rdev：该字段记录了设备号，设备号只针对于设备文件，包括字符设备文件和块设备文件，不用理会。st_size：该字段记录了文件的大小（逻辑大小），以字节为单位。st_atim、st_mtim、st_ctim：此三个字段分别用于记录文件最后被访问的时间、文件内容最后被修改的时间以及文件状态最后被改变的时间，都是 struct timespec 类型变量。</code></pre><h4 id="5-3-解析请求行（parseRequestLine函数）"><a href="#5-3-解析请求行（parseRequestLine函数）" class="headerlink" title="5.3 解析请求行（parseRequestLine函数）"></a>5.3 解析请求行（parseRequestLine函数）</h4><pre><code class="c">int parseRequestLine(const char* line,int cfd)&#123;    // 1. 拆分http请求行   get /xxx/1.jpg http/1.1    char method[12];    // 方法    char path[1024];    // 路径    char protocol[12];  // 协议    sscanf(line,&quot;%[^ ] %[^ ] %[^ ]&quot;,method,path,protocol);    printf(&quot;method = %s, path = %s, protocol = %s\n&quot;, method, path, protocol);    // 判断是否是get请求    if(strcasecmp(method,&quot;get&quot;) != 0)&#123;     //不区分大小写        return -1;    &#125;    // 转码 将不能识别的中文乱码 -&gt; 中文    // 解码 %23 %34 %5f    decode_str(path, path);    // 2. 处理客户端请求的静态资源    char* file = NULL;    // 如果没有指定访问的资源, 默认显示资源目录中的内容    if(strcmp(path,&quot;/&quot;) == 0)&#123;        // file的值, 资源目录的当前位置        file = &quot;./&quot;;    &#125;else&#123;        // 去掉path中的/ 获取访问文件名        file = path + 1;    &#125;        // 3. 获取文件属性    struct stat st;    int ret = stat(file,&amp;st);    if(ret == -1)&#123;        // 文件不存在--回复404        return 0;    &#125;    // 判断文件类型（判断是目录还是文件）    if(S_ISDIR(st.st_mode))&#123;    // 目录        // 把目录发给客户端    &#125;else&#123;        // 把文件内容发给客户端    &#125;    return 0;&#125;</code></pre><h3 id="6-发送响应头"><a href="#6-发送响应头" class="headerlink" title="6. 发送响应头"></a>6. 发送响应头</h3><pre><code class="c">int sendHeadMsg(int cfd,int status,const char* desrc,const char* type,int length)&#123;    // 状态行    char buf[4096] = &#123; 0 &#125;;    sprintf(buf,&quot;http/1.1 %d %s \r\n&quot;,status,desrc);    // 消息报头    sprintf(buf + strlen(buf),&quot;Content-Type: %s\r\n&quot;,type);    sprintf(buf + strlen(buf),&quot;Content-Length: %d\r\n&quot;,length);    send(cfd,buf,strlen(buf),0);     // 空行    send(cfd, &quot;\r\n&quot;, 2, 0);    return 0;&#125;</code></pre><h3 id="7-通过文件名获取文件的类型"><a href="#7-通过文件名获取文件的类型" class="headerlink" title="7. 通过文件名获取文件的类型"></a>7. 通过文件名获取文件的类型</h3><pre><code class="c">// 通过文件名获取文件的类型const char *get_file_type(const char *name)&#123;    char* dot;    // 自右向左查找‘.’字符, 如不存在返回NULL    dot = strrchr(name, &#39;.&#39;);       if (dot == NULL)        return &quot;text/plain; charset=utf-8&quot;;    if (strcmp(dot, &quot;.html&quot;) == 0 || strcmp(dot, &quot;.htm&quot;) == 0)        return &quot;text/html; charset=utf-8&quot;;    if (strcmp(dot, &quot;.jpg&quot;) == 0 || strcmp(dot, &quot;.jpeg&quot;) == 0)        return &quot;image/jpeg&quot;;    if (strcmp(dot, &quot;.gif&quot;) == 0)        return &quot;image/gif&quot;;    if (strcmp(dot, &quot;.png&quot;) == 0)        return &quot;image/png&quot;;    if (strcmp(dot, &quot;.css&quot;) == 0)        return &quot;text/css&quot;;    if (strcmp(dot, &quot;.au&quot;) == 0)        return &quot;audio/basic&quot;;    if (strcmp( dot, &quot;.wav&quot; ) == 0)        return &quot;audio/wav&quot;;    if (strcmp(dot, &quot;.avi&quot;) == 0)        return &quot;video/x-msvideo&quot;;    if (strcmp(dot, &quot;.mov&quot;) == 0 || strcmp(dot, &quot;.qt&quot;) == 0)        return &quot;video/quicktime&quot;;    if (strcmp(dot, &quot;.mpeg&quot;) == 0 || strcmp(dot, &quot;.mpe&quot;) == 0)        return &quot;video/mpeg&quot;;    if (strcmp(dot, &quot;.vrml&quot;) == 0 || strcmp(dot, &quot;.wrl&quot;) == 0)        return &quot;model/vrml&quot;;    if (strcmp(dot, &quot;.midi&quot;) == 0 || strcmp(dot, &quot;.mid&quot;) == 0)        return &quot;audio/midi&quot;;    if (strcmp(dot, &quot;.mp3&quot;) == 0)        return &quot;audio/mpeg&quot;;    if (strcmp(dot, &quot;.ogg&quot;) == 0)        return &quot;application/ogg&quot;;    if (strcmp(dot, &quot;.pac&quot;) == 0)        return &quot;application/x-ns-proxy-autoconfig&quot;;    return &quot;text/plain; charset=utf-8&quot;;&#125;</code></pre><h3 id="8-发送文件"><a href="#8-发送文件" class="headerlink" title="8. 发送文件"></a>8. 发送文件</h3><h4 id="8-1-断言（assert函数）"><a href="#8-1-断言（assert函数）" class="headerlink" title="8.1 断言（assert函数）"></a>8.1 断言（assert函数）</h4><p>编译期<code>assert</code>函数的目的在于当条件不满足时，阻止编译，从而防止错误的逻辑通过编辑。而运行期<code>assert</code>的目的在于运行时发现条件不满足时，产生一个<code>Debug</code>事件(<code>DebugBreak</code>)，从而让调试器停下来方便用户检查原因。<code>assert </code>是一个宏，不是函数。</p><pre><code>//表达式可以是任何有效的 C 语言表达式，很多时候它是一个条件。void assert(int expression or variable);</code></pre><h4 id="8-2-光标函数（lseek函数）"><a href="#8-2-光标函数（lseek函数）" class="headerlink" title="8.2 光标函数（lseek函数）"></a>8.2 光标函数（lseek函数）</h4><pre><code class="txt">#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;off_t lseek(int handle, off_t offset, int fromwhere);1) 欲将读写位置移到文件开头时:lseek（int fildes,0,SEEK_SET）；2) 欲将读写位置移到文件尾时:lseek（int fildes，0,SEEK_END）；3) 想要取得目前文件位置时:lseek（int fildes，0,SEEK_CUR）；</code></pre><h4 id="8-3-发送文件（sendFile函数）"><a href="#8-3-发送文件（sendFile函数）" class="headerlink" title="8.3 发送文件（sendFile函数）"></a>8.3 发送文件（sendFile函数）</h4><pre><code class="c">int sendFile(const char* filename,int cfd)&#123;    // 1. 打开文件    int fd = open(filename,O_RDONLY);    assert(fd &gt; 0);     // 断言    // if(fd == -1)&#123;    //     perror(&quot;open error&quot;);    // &#125;    // 2. 循环读文件#if 1    char buf[4096] = &#123; 0 &#125;;    int len = 0, ret = 0;    while((len = read(fd,buf,sizeof(buf))) &gt; 0)&#123;        // 发送读出的数据        ret = send(cfd,buf,len,0);        if(ret == -1)&#123;            if(errno = EAGAIN)&#123;                perror(&quot;send error:&quot;);                continue;            &#125;else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;    &#125;#else    off_t offset = 0;    int size = lseek(fd,0,SEEK_END);    lseek(fd,0,SEEK_SET);    while(offset &lt; size)&#123;        int ret = sendfile(cfd,fd,&amp;offset,size);        printf(&quot;ret value: %d\n&quot;,ret);        if(ret == -1 &amp;&amp; errno == EAGAIN)&#123;            printf(&quot;没数据。。。\n&quot;);            perror(&quot;snedfile&quot;);                    &#125;    &#125;#endif    close(fd);    return 0;&#125;</code></pre><h3 id="9-发送目录"><a href="#9-发送目录" class="headerlink" title="9. 发送目录"></a>9. 发送目录</h3><h4 id="9-1-目录扫描函数（scandir函数）"><a href="#9-1-目录扫描函数（scandir函数）" class="headerlink" title="9.1 目录扫描函数（scandir函数）"></a>9.1 目录扫描函数（scandir函数）</h4><p><code>scandir()</code>会扫描参数<code>dir</code>指定的目录文件，经由参数<code>select</code>指定的函数来挑选目录结构至参数<code>namelist</code>数组中，最后再调用参数<code>compar</code>指定的函数来排序<code>namelist</code>数组中的目录数据。每次从目录文件中读取一个目录结构后便将此结构传给参数<code>select</code>所指的函数，<code>select</code>函数若不想要将此目录结构复制到<code>namelis</code>t数组就返回0，若<code>select</code>为空指针则代表选择所有的目录结构。<code>scandir()</code>会调用<code>qsort()</code>来排序数据，参数<code>compar</code>则为<code>qsort()</code>的参数，若是要排列目录名称字母则可使用<code>alphasort()</code>。</p><pre><code class="txt">#include &lt;dirent.h&gt;int scandir(const char *dir,             struct dirent ***namelist,            int (*select)(const struct dirent *),            int (*compar)(const struct dirent **,             const struct dirent **));dir:指定扫描的目录namelist:struct dirent结构体类型的三级指针，用于获取该函数内部为存放返回结果的分配的动态内存select:函数指针，指向过滤模式函数,当selectr指针设置为NULL时，扫描dir目录下的所有顶层文件.该函数有一个参数const struct dirent *是指在遍历过程中所遍历到的每一个子目录dirent，select可以根据dirent的类型、名称等信息来判定当前的dirent是否为合法的子目录，合法则函数返回0，则该子目录的名称会被存储在namelist中；否则返回非0，则该子目录被过滤掉。compar:函数指针，指向对遍历结果进行排序函数，alphasort函数和versionsort是经常用到的函数</code></pre><h4 id="9-2-发送目录（sendDir函数）"><a href="#9-2-发送目录（sendDir函数）" class="headerlink" title="9.2 发送目录（sendDir函数）"></a>9.2 发送目录（sendDir函数）</h4><pre><code class="c">// 发送目录内容int sendDir(const char* dirname, int cfd)&#123;      // 拼接一个html页面&lt;table&gt;&lt;/table&gt;   char buf[4096] = &#123; 0 &#125;;      sprintf(buf,&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;,dirname);   //sprintf(buf + strlen(buf),&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;,dirname);    // 目录项二级指针    struct dirent** ptr;    int num = scandir(dirname,&amp;ptr,NULL,alphasort);    // 遍历目录    for(int i = 0; i &lt; num; i++)&#123;        // 取出文件名 namelist 指向的是一个指针数组 struct dirent* tmp[]        char* name = ptr[i]-&gt;d_name;        char subPath[1024] = &#123; 0 &#125;;        // 拼接文件袋完整路径        sprintf(subPath,&quot;%s/%s&quot;,dirname,name);                struct stat st;        stat(subPath,&amp;st);        char enstr[1024] = &#123;0&#125;;        // 编码生成 %E5 %A7 之类的东西        encode_str(enstr, sizeof(enstr), name);        // 如果是文件        if(S_ISREG(st.st_mode)) &#123;                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125; else if(S_ISDIR(st.st_mode)) &#123;// 如果是目录                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125;        int ret = send(cfd, buf, strlen(buf), 0);        if (ret == -1) &#123;            if (errno == EAGAIN) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;        memset(buf, 0, sizeof(buf));        // 字符串拼接        free(ptr[i]);    &#125;          // 字符串拼接    //memset(buf, 0, sizeof(buf));    sprintf(buf, &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);    send(cfd, buf, strlen(buf), 0);    printf(&quot;dir message send OK!!!!\n&quot;); #if 0    // 打开目录    DIR* dir = opendir(dirname);    if(dir == NULL)    &#123;        perror(&quot;opendir error&quot;);        exit(1);    &#125;    // 读目录    struct dirent* ptr = NULL;    while( (ptr = readdir(dir)) != NULL )    &#123;        char* name = ptr-&gt;d_name;    &#125;    closedir(dir);#endif    free(ptr);    return 0;&#125;</code></pre><h3 id="10-完整代码"><a href="#10-完整代码" class="headerlink" title="10. 完整代码"></a>10. 完整代码</h3><h4 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h4><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20231028135200278.png" alt="image-20231028135200278"></p><pre><code class="c">/*客户端: 浏览器    - 通过浏览器访问服务器:        - 访问方式: 服务器的IP地址:端口    - 应用层协议使用: http, 数据需要在浏览器端使用该协议进行包装    - 响应消息的处理也是浏览器完成的 =&gt; 程序猿不需要管    - 客户端通过url访问服务器资源        - 客户端访问的路径:        1. http://192.168.1.100:8989/  或者  http://192.168.1.100:8989            - 访问服务器提供的资源目录的根目录                - 并不是服务器上的 / 目录                  - 这个目录根据服务器端的描述应该是: /home/robin/luffy 目录            - 请求行:                GET / HTTP/1.1        2. http://192.168.1.100:8989/a.txt            - 端口后边的/代表服务器的资源根目录                - 在服务器端路径: /home/robin/luffy 目录            - 客户端要访问服务器上的a.txt的文件            - a.txt 这个文件在服务器提供的资源目录中                - 服务器上的路径: /home/robin/luffy/a.txt            - 请求行:                GET /a.txt HTTP/1.1        3. http://192.168.1.100:8989/hello/a.txt            - http://192.168.1.100:8989: 服务器地址            - /hello/a.txt                - /: 服务器端提供的资源根目录                - hello: 资源根目录的子目录                - a.txt: 在hello目录中            - 请求行:                GET /hello/a.txt HTTP/1.1        4. http://192.168.1.100:8989/hello/wrold/            - http://192.168.1.100:8989: 服务器地址            - /hello/world/                - /: 服务器端提供的资源根目录                - hello: 资源根目录的子目录                - world/: 如果world后边有/代表这是一个目录, 这个目录在hello目录中            - 请求行:                GET /hello/world/ HTTP/1.1*//*服务器端: 提供服务器, 让客户端访问    - 支持多客户端访问        - 使用IO多路转接 =&gt; epoll    - 客户端发送给的请求消息是基于http的        - 需要能够解析http请求    - 服务器回复客户端数据, 使用http协议封装回复的数据 ==&gt; http响应    - 服务器端需要提供一个资源目录, 目录中的文件可以供客户端访问        - 客户端访问的文件没有在资源目录中, 就不能访问了            - 假设服务器提供个资源目录: /home/robin/luffy 目录*/</code></pre><pre><code class="c">// 服务器端处理的伪代码int main()&#123;    // 1. 创建监听的fd    socket();    // 2. 绑定    bind();    // 3. 设置监听    listen();        // 4. 创建epoll模型    epoll_create();    epoll_ctl();    // 5. 检测    while(1)    &#123;        epoll_wait();        // 监听的文件描述符        accept();        // 通信的        // 接收数据-&gt;http请求消息        recvAndParseHttp();    &#125;    return 0;&#125;// 基于边沿非阻塞模型接收数据int recvAndParseHttp()&#123;    // 循环接收数据    // 解析http请求消息    // http请求由两种:get / post    // 只处理get请求, 浏览器向服务器请求访问的文件都是静态资源, 因此使用get就可以    // 判断是不是get请求  ==&gt; 在请求行中 ==&gt; 请求行的第一部分    // 客户端向服务器请求的静态资源是什么? =&gt; 请求行的第二部分    // 找到服务器上的静态资源        - 文件 -&gt; 读文件内容        - 目录 -&gt; 遍历目录    // 将文件内容或者目录内容打包到http响应协议中    // 将整条协议发送回给客户端即可&#125;</code></pre><h4 id="epoll-web-c"><a href="#epoll-web-c" class="headerlink" title="epoll_web.c"></a><strong>epoll_web.c</strong></h4><!-- more --><pre><code class="c">#include &quot;epoll_web.h&quot;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;#include &lt;assert.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;dirent.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#include &lt;sys/types.h&gt;// 初始化监听套接字int initListenFd(unsigned int port)&#123;    // 1. 创建监听套接字    int lfd = socket(AF_INET,SOCK_STREAM,0);    if(lfd == -1)&#123;        perror(&quot;socket error&quot;);        return -1;    &#125;    // 2. 设置端口复用    int opt = 1;    int ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt));    if(ret == -1)&#123;        perror(&quot;setsockopt error&quot;);        return -1;    &#125;    // 3. 绑定    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = 0;    ret = bind(lfd,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ret == -1)&#123;        perror(&quot;bind error&quot;);        return -1;    &#125;    // 4.设置监听    ret = listen(lfd,128);    if(ret == -1)&#123;        perror(&quot;listen error&quot;);        return -1;    &#125;    // 5. 返回fd    return lfd;&#125;//启动epollint epollrun(int lfd)&#123;    // 1. 创建epoll树    int epfd = epoll_create(1);    if(epfd == -1)&#123;        perror(&quot;epoll_create error&quot;);        return -1;    &#125;    // 2. lfd上树    struct epoll_event ev;    ev.data.fd = lfd;    ev.events = EPOLLIN;    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    // 3. 检测(委托内核检测添加到树上的节点)    struct epoll_event evs[1024];    int size = sizeof(evs) / sizeof(struct epoll_event);    while(1)&#123;        int num = epoll_wait(epfd,evs,size,-1);        if(num == -1) &#123;            perror(&quot;epoll_wait error&quot;);            return -1;        &#125;        // 遍历发生变化的节点        for(int i = 0; i &lt; num; ++i)&#123;            if(!(evs[i].events &amp; EPOLLIN)) &#123;                // 不是读事件                continue;            &#125;            int fd = evs[i].data.fd;            if(fd == lfd)&#123;                //建立新连接accept                accpetClient(lfd,epfd);            &#125;else&#123;                // 读数据                printf(&quot;=============before recvHttpRequest=============\n&quot;);                recvHttpRequest(fd,epfd);                printf(&quot;=============after recvHttpRequest=============\n&quot;);            &#125;        &#125;    &#125;    return 0;&#125;int accpetClient(int lfd,int epfd)&#123;    // 1. 建立连接    struct sockaddr_in cliaddr;    socklen_t len = sizeof(cliaddr);    cliaddr.sin_family = AF_INET;    int cfd = accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len);    if(cfd == -1)&#123;        perror(&quot;accept error&quot;);        return -1;    &#125;    char ip[16]=&quot;&quot;;    printf(&quot;new client ip=%s port=%d\n&quot;,    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));        // 2. 设置cfd为非阻塞    int flag = fcntl(cfd,F_GETFL);    flag |= O_NONBLOCK;    fcntl(cfd,F_SETFL,flag);    // 3. cfd添加到epoll    struct epoll_event ev;    ev.data.fd = cfd;    // 边沿非阻塞模式    ev.events = EPOLLIN | EPOLLET;      //边沿模式    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);    if(ret == -1)&#123;        perror(&quot;epoll_ctl error&quot;);        return -1;    &#125;    return 0;&#125;int recvHttpRequest(int cfd,int epfd)&#123;    char buf[4096] = &#123; 0 &#125;;    char tmp[1024] = &#123; 0 &#125;;    int len = 0;    int total = 0;    // 1. 接收数据    while((len = recv(cfd,tmp,sizeof(tmp),0)) &gt; 0)&#123;        if(total + len &lt; sizeof(buf))&#123;            memcpy(buf + total,tmp,len);        &#125;        total += len;    &#125;    // 2. 判断数据是否接受完毕    if(len == -1 &amp;&amp; errno == EAGAIN)&#123;        // 解析请求行           /*        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19        G E T   / 1 . t x t H  T  T  P  /  1  .  1  /r /n        */        char* pt = strstr(buf,&quot;\r\n&quot;);  //大字符串找小字符串        int reqLen = pt - buf;        buf[reqLen] = &#39;\0&#39;;        parseRequestLine(buf,cfd);    &#125;    else if(len == 0)&#123;        // 客户端断开连接        epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);        close(cfd);    &#125;    else&#123;        perror(&quot;recv error&quot;);    &#125;    return 0;&#125;int parseRequestLine(const char* line,int cfd)&#123;    // 1. 拆分http请求行   get /xxx/1.jpg http/1.1    char method[12];    // 方法    char path[1024];    // 路径    char protocol[12];  // 协议    sscanf(line,&quot;%[^ ] %[^ ] %[^ ]&quot;,method,path,protocol);    printf(&quot;method = %s, path = %s, protocol = %s\n&quot;, method, path, protocol);    // 判断是否是get请求    if(strcasecmp(method,&quot;get&quot;) != 0)&#123;     //不区分大小写        return -1;    &#125;    // 转码 将不能识别的中文乱码 -&gt; 中文    // 解码 %23 %34 %5f    decode_str(path, path);    // 2. 处理客户端请求的静态资源    char* file = NULL;    // 如果没有指定访问的资源, 默认显示资源目录中的内容    if(strcmp(path,&quot;/&quot;) == 0)&#123;        // file的值, 资源目录的当前位置        file = &quot;./&quot;;    &#125;else&#123;        // 去掉path中的/ 获取访问文件名        file = path + 1;    &#125;        // 3. 获取文件属性    struct stat st;    int ret = stat(file,&amp;st);    if(ret == -1)&#123;        // 文件不存在--回复404        sendHeadMsg(cfd,404,&quot;Not Found&quot;,get_file_type(&quot;.html&quot;),-1);        sendFile(&quot;404.html&quot;,cfd);        return 0;    &#125;    // 判断文件类型（判断是目录还是文件）    if(S_ISDIR(st.st_mode))&#123;    // 目录        // 把目录发给客户端         sendHeadMsg(cfd,200,&quot;OK&quot;,get_file_type(&quot;.html&quot;),-1);         sendDir(file,cfd);    &#125;else&#123;        // 把文件内容发给客户端        sendHeadMsg(cfd,200,&quot;OK&quot;,get_file_type(file),st.st_size);        sendFile(file,cfd);    &#125;    return 0;&#125;int sendHeadMsg(int cfd,int status,const char* desrc,const char* type,int length)&#123;    // 状态行    char buf[4096] = &#123; 0 &#125;;    sprintf(buf,&quot;http/1.1 %d %s \r\n&quot;,status,desrc);    // 消息报头    sprintf(buf + strlen(buf),&quot;Content-Type: %s\r\n&quot;,type);    sprintf(buf + strlen(buf),&quot;Content-Length: %d\r\n&quot;,length);    send(cfd,buf,strlen(buf),0);     // 空行    send(cfd, &quot;\r\n&quot;, 2, 0);    return 0;&#125;int sendFile(const char* filename,int cfd)&#123;    // 1. 打开文件    int fd = open(filename,O_RDONLY);    assert(fd &gt; 0);     // 断言    // if(fd == -1)&#123;    //     perror(&quot;open error&quot;);    // &#125;    // 2. 循环读文件#if 1    char buf[4096] = &#123; 0 &#125;;    int len = 0, ret = 0;    while((len = read(fd,buf,sizeof(buf))) &gt; 0)&#123;        // 发送读出的数据        ret = send(cfd,buf,len,0);        if(ret == -1)&#123;            if(errno = EAGAIN)&#123;                perror(&quot;send error:&quot;);                continue;            &#125;else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;    &#125;#else    off_t offset = 0;    int size = lseek(fd,0,SEEK_END);    lseek(fd,0,SEEK_SET);    while(offset &lt; size)&#123;        int ret = sendfile(cfd,fd,&amp;offset,size);        printf(&quot;ret value: %d\n&quot;,ret);        if(ret == -1 &amp;&amp; errno == EAGAIN)&#123;            printf(&quot;没数据。。。\n&quot;);            perror(&quot;snedfile&quot;);                    &#125;    &#125;#endif    close(fd);    return 0;&#125;// 发送目录内容int sendDir(const char* dirname, int cfd)&#123;      // 拼接一个html页面&lt;table&gt;&lt;/table&gt;   char buf[4096] = &#123; 0 &#125;;      sprintf(buf,&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;,dirname);   //sprintf(buf + strlen(buf),&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;,dirname);    // 目录项二级指针    struct dirent** ptr;    int num = scandir(dirname,&amp;ptr,NULL,alphasort);    // 遍历目录    for(int i = 0; i &lt; num; i++)&#123;        // 取出文件名 namelist 指向的是一个指针数组 struct dirent* tmp[]        char* name = ptr[i]-&gt;d_name;        char subPath[1024] = &#123; 0 &#125;;        // 拼接文件袋完整路径        sprintf(subPath,&quot;%s/%s&quot;,dirname,name);                struct stat st;        stat(subPath,&amp;st);        char enstr[1024] = &#123;0&#125;;        // 编码生成 %E5 %A7 之类的东西        encode_str(enstr, sizeof(enstr), name);        // 如果是文件        if(S_ISREG(st.st_mode)) &#123;                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125; else if(S_ISDIR(st.st_mode)) &#123;// 如果是目录                   sprintf(buf+strlen(buf),                     &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,                    enstr, name, (long)st.st_size);        &#125;        int ret = send(cfd, buf, strlen(buf), 0);        if (ret == -1) &#123;            if (errno == EAGAIN) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else if (errno == EINTR) &#123;                perror(&quot;send error:&quot;);                continue;            &#125; else &#123;                perror(&quot;send error:&quot;);                return -1;            &#125;        &#125;        memset(buf, 0, sizeof(buf));        // 字符串拼接        free(ptr[i]);    &#125;          // 字符串拼接    //memset(buf, 0, sizeof(buf));    sprintf(buf, &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);    send(cfd, buf, strlen(buf), 0);    printf(&quot;dir message send OK!!!!\n&quot;); #if 0    // 打开目录    DIR* dir = opendir(dirname);    if(dir == NULL)    &#123;        perror(&quot;opendir error&quot;);        exit(1);    &#125;    // 读目录    struct dirent* ptr = NULL;    while( (ptr = readdir(dir)) != NULL )    &#123;        char* name = ptr-&gt;d_name;    &#125;    closedir(dir);#endif    free(ptr);    return 0;&#125;/* *  这里的内容是处理%20之类的东西！是&quot;解码&quot;过程。 *  %20 URL编码中的‘ ’(space) *  %21 &#39;!&#39; %22 &#39;&quot;&#39; %23 &#39;#&#39; %24 &#39;$&#39; *  %25 &#39;%&#39; %26 &#39;&amp;&#39; %27 &#39;&#39;&#39; %28 &#39;(&#39;...... *  相关知识html中的‘ ’(space)是&amp;nbsp */// 16进制数转化为10进制int hexit(char c)&#123;    if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)        return c - &#39;0&#39;;    if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;)        return c - &#39;a&#39; + 10;    if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;)        return c - &#39;A&#39; + 10;    return 0;&#125;void encode_str(char* to, int tosize, const char* from)&#123;    int tolen;    for (tolen = 0; *from != &#39;\0&#39; &amp;&amp; tolen + 4 &lt; tosize; ++from) &#123;            if (isalnum(*from) || strchr(&quot;/_.-~&quot;, *from) != (char*)0) &#123;                  *to = *from;            ++to;            ++tolen;        &#125; else &#123;            sprintf(to, &quot;%%%02x&quot;, (int) *from &amp; 0xff);            to += 3;            tolen += 3;        &#125;    &#125;    *to = &#39;\0&#39;;&#125;void decode_str(char *to, char *from)&#123;    for ( ; *from != &#39;\0&#39;; ++to, ++from  ) &#123;             if (from[0] == &#39;%&#39; &amp;&amp; isxdigit(from[1]) &amp;&amp; isxdigit(from[2])) &#123;                   *to = hexit(from[1])*16 + hexit(from[2]);            from += 2;                              &#125; else &#123;            *to = *from;        &#125;    &#125;    *to = &#39;\0&#39;;&#125;// 通过文件名获取文件的类型const char *get_file_type(const char *name)&#123;    char* dot;    // 自右向左查找‘.’字符, 如不存在返回NULL    dot = strrchr(name, &#39;.&#39;);       if (dot == NULL)        return &quot;text/plain; charset=utf-8&quot;;    if (strcmp(dot, &quot;.html&quot;) == 0 || strcmp(dot, &quot;.htm&quot;) == 0)        return &quot;text/html; charset=utf-8&quot;;    if (strcmp(dot, &quot;.jpg&quot;) == 0 || strcmp(dot, &quot;.jpeg&quot;) == 0)        return &quot;image/jpeg&quot;;    if (strcmp(dot, &quot;.gif&quot;) == 0)        return &quot;image/gif&quot;;    if (strcmp(dot, &quot;.png&quot;) == 0)        return &quot;image/png&quot;;    if (strcmp(dot, &quot;.css&quot;) == 0)        return &quot;text/css&quot;;    if (strcmp(dot, &quot;.au&quot;) == 0)        return &quot;audio/basic&quot;;    if (strcmp( dot, &quot;.wav&quot; ) == 0)        return &quot;audio/wav&quot;;    if (strcmp(dot, &quot;.avi&quot;) == 0)        return &quot;video/x-msvideo&quot;;    if (strcmp(dot, &quot;.mov&quot;) == 0 || strcmp(dot, &quot;.qt&quot;) == 0)        return &quot;video/quicktime&quot;;    if (strcmp(dot, &quot;.mpeg&quot;) == 0 || strcmp(dot, &quot;.mpe&quot;) == 0)        return &quot;video/mpeg&quot;;    if (strcmp(dot, &quot;.vrml&quot;) == 0 || strcmp(dot, &quot;.wrl&quot;) == 0)        return &quot;model/vrml&quot;;    if (strcmp(dot, &quot;.midi&quot;) == 0 || strcmp(dot, &quot;.mid&quot;) == 0)        return &quot;audio/midi&quot;;    if (strcmp(dot, &quot;.mp3&quot;) == 0)        return &quot;audio/mpeg&quot;;    if (strcmp(dot, &quot;.ogg&quot;) == 0)        return &quot;application/ogg&quot;;    if (strcmp(dot, &quot;.pac&quot;) == 0)        return &quot;application/x-ns-proxy-autoconfig&quot;;    return &quot;text/plain; charset=utf-8&quot;;&#125;</code></pre><h4 id="epoll-web-h"><a href="#epoll-web-h" class="headerlink" title="epoll_web.h"></a><strong>epoll_web.h</strong></h4><pre><code class="c">#ifndef _EPOLL_SEVER_H#define _EPOLL_SEVER_H// 初始化监听的套接字int initListenFd(unsigned int port);//启动epollint epollrun(int lfd);// 建立新连接int accpetClient(int lfd,int epfd);// 读数据int recvHttpRequest(int fd,int epfd);// 解析请求行int parseRequestLine(const char* line,int cfd);// 发送响应头（状态行+响应头）int sendHeadMsg(int cfd,int status,const char* desrc,const char* type,int length);// 发送文件int sendFile(const char* filename,int cfd);// 发送目录int sendDir(const char* dirName,int cfd);// 通过文件名获取文件的类型const char *get_file_type(const char *name);int hexit(char c);void encode_str(char* to, int tosize, const char* from);void decode_str(char *to, char *from);#endif</code></pre><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include &quot;epoll_web.h&quot;int main(int argc, char* argv[])&#123;    if(argc &lt; 3)&#123;        printf(&quot;./a.out port path\n&quot;);        exit(1);    &#125;    // 采用指定端口    unsigned int port = atoi(argv[1]);    // 修改进程工作目录，方便后续操作    int ret = chdir(argv[2]);    if(ret == -1)&#123;        perror(&quot;chdir error&quot;);    &#125;    // 初始化监听套接字    int lfd = initListenFd(port);    // 启动epoll模型    epollrun(lfd);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Qt开发工作上的需求</title>
      <link href="/2023/10/26/%E4%BD%BF%E7%94%A8Qt%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E4%B8%8A%E7%9A%84%E9%9C%80%E6%B1%82/"/>
      <url>/2023/10/26/%E4%BD%BF%E7%94%A8Qt%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E4%B8%8A%E7%9A%84%E9%9C%80%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>记录最近工作设及到一些关于qt编程的相关内容</p><span id="more"></span><h3 id="功能1：鼠标点击图片显示坐标和像素"><a href="#功能1：鼠标点击图片显示坐标和像素" class="headerlink" title="功能1：鼠标点击图片显示坐标和像素"></a>功能1：鼠标点击图片显示坐标和像素</h3><p>最近工作设及到一些关于qt编程的工作，主要内容就是在一个<code>QGraphicsView</code>上显示了一个<code>QGraphicsPixmapItem</code>的相机监控的图片，并用鼠标点击图片显示坐标和像素。</p><p>最初在网上找到的解决方案是重写<code>mousePressEvent()</code>方法</p><pre><code class="c++">void ImgHelper::mousePressEvent(QGraphicsSceneMouseEvent* event)&#123;    std::cout &lt;&lt; &quot;Item: (&quot; &lt;&lt; event-&gt;scenePos().x() &lt;&lt; &quot;, &quot; &lt;&lt; event-&gt;scenePos().y() &lt;&lt; &#39;)&#39; &lt;&lt; std::endl; &#125;</code></pre><p>测试发现未响应鼠标事件，网上找到说：重写鼠标点击事件函数时发现鼠标点击事件在子类化后的<code>QGraphicsScene</code>中被响应，但是子类化后的<code>QGraphicsPixmapItem</code>无法响应。<code>QGraphicsView</code>的事件传递机制的顺序是<code>View-&gt;Scene-&gt;Item</code>，也就是说事件被子类化的<code>QGraphicsScene</code>吞没了，没有传递到下一级的<code>item</code>。<br>解决方案，在子类化的<code>QGraphicsScene</code>中重写<code>mousePressEvent()</code>方法内部一定要要记得调用：</p><pre><code class="c++">QGraphicsScene::mousePressEvent(event);</code></pre><p>注意，要想返回图像坐标系的位置，就需要在子类化的<code>QGraphicsPixmapItem</code>中调用<code>scenePos()</code>函数。即使放大图像，点击图像中相同位置也会返回相同坐标结果。</p><p>结果发现还是没有反应，还有一种说法就是加上下面这句话</p><pre><code class="c++">//使能QGraphcisView控件的鼠标跟踪view-&gt;setMouseTracking(true);</code></pre><p>最后尝试把<code>mousePressEvent</code>函数在最上层的<code>mainwindow</code>中重写并使能鼠标，有效果，但是坐标并不是我想要的效果，现在的坐标系是整个界面的，我想要的是图像的坐标，然后能通过图像控件的位置和长宽进行筛选，但是获得的图像是经过qt自适应缩放在<code>600X600</code>的容器里的。</p><p>在一筹莫展的时候，突然看到<code>eventFilter</code>事件过滤器。</p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/20210320141253167.png" alt="在这里插入图片描述"></p><p>原本事件应该直接发送给“组件对象”，但是现在却先将事件发送给“过滤器对象”，经过过滤的事件再发给“组件对象”。</p><p><strong>事件过滤器的操作：</strong></p><ol><li>首先给需要添加事件过滤器的部件<strong>注册监听对象</strong>；<br><code>对象名-&gt;installEventFilter(true);</code></li><li>重写<code>eventFilter(QObject *obj, QEvent *event)</code>函数进行处理。<!-- more -->首先使用参数<code>obj</code>进行与绑定的控件对象进行判断，是否与其相等；然后在使用参数<code>event-&gt;type()</code>的返回值与枚举鼠标或者键盘进行判断；最后将<code>event</code>转换为鼠标事件对象或者键盘对象事件，就可以进行操作了。</li></ol><pre><code class="c++">bool ImgHelper::eventFilter(QObject *watched, QEvent *event)&#123;    //判断信号是不是来自QGraphicsView    if(watched == view-&gt;viewport())&#123;        switch (event-&gt;type()) &#123;        //鼠标移动事件        case  QEvent::MouseMove:        &#123;            QMouseEvent *m_event = (QMouseEvent*)event;            if(pixmapItem == NULL)&#123;                break;            &#125;           // QPoint point = m_event-&gt;pos();            QPixmap pix= pixmapItem-&gt;pixmap();            QImage img = pix.toImage();          //  QSize size = pixmapItem-&gt;pixmap().size();            QPoint point = m_event-&gt;pos();           // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;            // 坐标系转换 - 视图 -&gt; 场景            QPointF scenePoint = view-&gt;mapToScene(point);            //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;            // 坐标系转换 - 场景 -&gt; 图元            QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);           // qDebug()&lt;&lt;&quot;itempoint:&quot;&lt;&lt;itempoint&lt;&lt;endl;            QString str;            // 判断所选点是否在图像范围内            if(itempoint.x()&gt;=0 &amp;&amp;itempoint.x()&lt;=pix.width() &amp;&amp; itempoint.y()&gt;=0 &amp;&amp; itempoint.y()&lt;= pix.height())&#123;                QRgb pixColor = img.pixel(itempoint.x(),itempoint.y());               // qDebug()&lt;&lt;pixColor&lt;&lt;&quot; &quot;&lt;&lt;qRed(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qGreen(pixColor)&lt;&lt;&quot; &quot;&lt;&lt;qBlue(pixColor)&lt;&lt;endl;                str = QString(&quot;X:%1\nY:%2\nR:%3\nG:%4\nB:%5\n&quot;).arg(QString::number(itempoint.x(),&#39;f&#39;,1))                                                                .arg(QString::number(itempoint.y(),&#39;f&#39;,1))                                                                .arg(qRed(pixColor))                                                                .arg(qGreen(pixColor))                                                                .arg(qBlue(pixColor)).toLocal8Bit();            &#125;            else&#123;                str = &quot;&quot;;            &#125;            img_xy_pix-&gt;setText(str);            img_xy_pix-&gt;setStyleSheet(&quot;color:red;&quot;);            break;        &#125;        // 鼠标点击事件        case QEvent::MouseButtonPress:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            // 左键点击确定起点            if(m_event-&gt;button() == Qt::LeftButton )&#123;             //   QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                startPoint = itempoint;                break;            &#125;            break;        &#125;        // 送开鼠标，确定终点        case QEvent::MouseButtonRelease:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            if(m_event-&gt;button() == Qt::LeftButton )&#123;//                QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                QPointF endPoint = itempoint;                if(startPoint.x() != 0 &amp;&amp; startPoint.y() != 0)&#123;                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());                    painter.drawRect(rectangle);                    painter.setPen(QPen(Qt::red,1));                    rects = scene-&gt;addRect(rectangle,rectPen);//                    float rectInfo[8];//                    rectcounts++;//                    rectInfo[0] = rectcounts;//                    float x = (endPoint.x()-startPoint.x()) / 2 + startPoint.x();//                    float y = (endPoint.y()-startPoint.y()) / 2 + startPoint.y();//                    float height;//                    float width;//                    if(endPoint.x()-startPoint.x() &gt; endPoint.y()-startPoint.y())&#123;//                       height = endPoint.x()-startPoint.x();//                       width = endPoint.y()-startPoint.y();//                    &#125;else&#123;//                        width = endPoint.x()-startPoint.x();//                        height = endPoint.y()-startPoint.y();//                    &#125;                 //   rectInfo[1] = x;                 //   rectInfo[2] = y;                 //   rectInfo[3] = height;                 //      rectInfo[4] = width;                  //  float angle = -90;                 //   rectInfo[5] = angle;//                    CassUdpHelper* udpClient = new CassUdpHelper(localPort, this);                    //                     bool flag = false;  //                    int rectCountsAddr = 353345520;//                    flag = udpClient-&gt;writeBytesByModbus(rectCountsAddr, (char*)&amp;rectcounts, sizeof(short), hostIpAddr, hostPort);//                    if(!flag) &#123;//                        delete udpClient;//                         break;//                    &#125;//                    int startAddr = 427778712;//                    flag = udpClient-&gt;writeBytesByModbus(startAddr + sizeof(float)*8 *(rectcounts - 1), (char*)rectInfo, sizeof(float)*8, hostIpAddr, hostPort);//                    if(!flag) &#123;//                        delete udpClient;//                         break;//                    &#125;//                    delete udpClient;                                    &#125;                break;            &#125;            break;        &#125;        default:            break;        &#125;    &#125;    return false;&#125;</code></pre><h3 id="功能2：Qt拖动鼠标画一个矩形"><a href="#功能2：Qt拖动鼠标画一个矩形" class="headerlink" title="功能2：Qt拖动鼠标画一个矩形"></a>功能2：Qt拖动鼠标画一个矩形</h3><p>想要画一个矩形就需要过滤鼠标点击事件，鼠标按下时确定矩形的起点，然后拖动一段距离，松开确定终点。</p><!-- more --><pre><code class="c++">// 鼠标点击事件        case QEvent::MouseButtonPress:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            // 左键点击确定起点            if(m_event-&gt;button() == Qt::LeftButton )&#123;             //   QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                startPoint = itempoint;                break;            &#125;            break;        &#125;        // 送开鼠标，确定终点        case QEvent::MouseButtonRelease:        &#123;            if(pixmapItem == NULL)&#123;                break;            &#125;            QMouseEvent *m_event = (QMouseEvent*)event;            if(m_event-&gt;button() == Qt::LeftButton )&#123;//                QPixmap pix= pixmapItem-&gt;pixmap();                QPainter painter(view-&gt;viewport());                painter.setPen(QPen(Qt::blue,1));              //  QImage img = pix.toImage();              //  QSize size = pixmapItem-&gt;pixmap().size();               // qDebug()&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;endl;                QPoint point = m_event-&gt;pos();               // qDebug()&lt;&lt;&quot;point:&quot;&lt;&lt;point&lt;&lt;endl;                QPointF scenePoint = view-&gt;mapToScene(point);                //qDebug()&lt;&lt;&quot;scenePoint:&quot;&lt;&lt;scenePoint&lt;&lt;endl;                QPointF itempoint = pixmapItem-&gt;mapFromScene(scenePoint);                QPointF endPoint = itempoint;                if(startPoint.x() != 0 &amp;&amp; startPoint.y() != 0)&#123;                    QRectF rectangle(startPoint.x(),startPoint.y(),endPoint.x()-startPoint.x(),endPoint.y()-startPoint.y());                    painter.drawRect(rectangle);                    painter.setPen(QPen(Qt::red,1));                    rects = scene-&gt;addRect(rectangle,rectPen);</code></pre><p>这是在网上看到其他人重写的一个<code>QGraphicsRectItem</code>类，画出来的矩形可以拖动，变形，旋转，使用时只需要导入这个类</p><ul><li><p>mygraphicrectitem.h</p><!-- more --><pre><code class="c++">#ifndef MYGRAPHICRECTITEM_H#define MYGRAPHICRECTITEM_H#include &lt;QObject&gt;#include &lt;QWidget&gt;#include &lt;QMouseEvent&gt;#include &lt;QGraphicsScene&gt;#include &lt;QGraphicsRectItem&gt;#include &lt;QGraphicsSceneMouseEvent&gt;#include &lt;QRect&gt;#include &lt;QPainter&gt;#include &lt;QPolygon&gt;#include &lt;QList&gt;enum STATE_FLAG&#123;    DEFAULT_FLAG=0,    MOV_LEFT_LINE,//标记当前为用户按下矩形的左边界区域    MOV_TOP_LINE,//标记当前为用户按下矩形的上边界区域    MOV_RIGHT_LINE,//标记当前为用户按下矩形的右边界区域    MOV_BOTTOM_LINE,//标记当前为用户按下矩形的下边界区域    MOV_RIGHTBOTTOM_RECT,//标记当前为用户按下矩形的右下角    MOV_RECT,//标记当前为鼠标拖动图片移动状态    ROTATE//标记当前为旋转状态&#125;;class myGraphicRectItem:public QObject,public QGraphicsItem&#123;    Q_OBJECTpublic:    myGraphicRectItem(QGraphicsItem *parent = nullptr);    //myGraphicRectItem(QRectF m_OriginRect = QRectF(0,0,100,100));    QRectF  boundingRect() const;    ~myGraphicRectItem();    void setRectSize(QRectF mrect,bool bResetRotateCenter = true);    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);    void mousePressEvent(QGraphicsSceneMouseEvent *event);    void mouseMoveEvent(QGraphicsSceneMouseEvent *event);    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);    void SetRotate(qreal RotateAngle,QPointF ptCenter=QPointF(-999,-999));    QPointF getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle);//获取旋转后的点    QList&lt;QPointF&gt; getRotatePoints(QPointF ptCenter,QList&lt;QPointF&gt; ptIns,qreal angle);//获取多个旋转后的点    QPolygonF getRotatePolygonFromRect(QPointF ptCenter,QRectF rectIn,qreal angle);//将矩形旋转之后返回多边形    QRectF getCrtPosRectToSceen();    QRectF m_SmallRotateRect;//矩形顶部用来表示旋转的标记的矩形    QPolygonF m_SmallRotatePolygon;//矩形顶部用来表示旋转的标记的矩形旋转后形成的多边形    QPointF getSmallRotateRectCenter(QPointF ptA,QPointF ptB);//获取旋转时候矩形正上方的旋转标记矩形    QRectF  getSmallRotateRect(QPointF ptA,QPointF ptB);    bool    m_bRotate;    qreal   m_RotateAngle;    QPointF m_RotateCenter;private:    QRectF  m_oldRect;    QPolygonF m_oldRectPolygon;    QRectF  m_RotateAreaRect;    bool    m_bResize;    QPolygonF m_insicedPolygon;    QRectF  m_insicedRectf;    QPolygonF m_leftPolygon;    QRectF  m_leftRectf;    QPolygonF m_topPolygon;    QRectF  m_topRectf;    QPolygonF m_rightPolygon;    QRectF  m_rightRectf;    QPolygonF m_bottomPolygon;    QRectF  m_bottomRectf;//    QPolygonF m_rbPolygon;//    QRectF  m_rbRectf;    QPointF m_startPos;    STATE_FLAG m_StateFlag;    QPointF *pPointFofSmallRotateRect;protected:&#125;;#endif // MYGRAPHICRECTITEM_H</code></pre></li><li><p>mygraphicrectitem.cpp</p><!-- more --><pre><code class="c++">#include &quot;mygraphicrectitem.h&quot;#include &lt;QtMath&gt;#include &lt;QDebug&gt;myGraphicRectItem::myGraphicRectItem(QGraphicsItem *parent):    m_bResize(false),    m_oldRect(0,0,100,100),    m_bRotate(false),    m_RotateAngle(0),    m_StateFlag(DEFAULT_FLAG)&#123;    //setParent(parent);    setRectSize(m_oldRect);    setToolTip(&quot;Click and drag me!&quot;);  //提示    setCursor(Qt::ArrowCursor);   //改变光标形状,手的形状    setFlag(QGraphicsItem::ItemIsMovable);    //    setAcceptDrops(true);    pPointFofSmallRotateRect = new QPointF[4];    SetRotate(0);    setFlag(QGraphicsItem::ItemIsSelectable);//&#125;QRectF myGraphicRectItem::boundingRect() const&#123;    //return m_oldRectPolygon.boundingRect();    QRectF boundingRectF = m_oldRectPolygon.boundingRect();    return QRectF(boundingRectF.x()-40,boundingRectF.y()-40,boundingRectF.width()+80,boundingRectF.height()+80);&#125;myGraphicRectItem::~myGraphicRectItem()&#123;    delete []pPointFofSmallRotateRect;    pPointFofSmallRotateRect = nullptr;&#125;void myGraphicRectItem::setRectSize(QRectF mrect, bool bResetRotateCenter)&#123;    m_oldRect = mrect;    if(bResetRotateCenter)    &#123;        m_RotateCenter.setX(m_oldRect.x()+m_oldRect.width()/2);        m_RotateCenter.setY(m_oldRect.y()+m_oldRect.height()/2);    &#125;    m_oldRectPolygon = getRotatePolygonFromRect(m_RotateCenter,m_oldRect,m_RotateAngle);    m_insicedRectf = QRectF(m_oldRect.x()+8,m_oldRect.y()+8,m_oldRect.width()-16,m_oldRect.height()-16);    m_insicedPolygon =getRotatePolygonFromRect(m_RotateCenter,m_insicedRectf,m_RotateAngle);    m_leftRectf = QRectF(m_oldRect.x(),m_oldRect.y(),8,m_oldRect.height()-8);    m_leftPolygon = getRotatePolygonFromRect(m_RotateCenter,m_leftRectf,m_RotateAngle);    m_topRectf = QRectF(m_oldRect.x()+8,m_oldRect.y(),m_oldRect.width()-8,8);    m_topPolygon = getRotatePolygonFromRect(m_RotateCenter,m_topRectf,m_RotateAngle);    m_rightRectf = QRectF(m_oldRect.right()-8,m_oldRect.y()+8,8,m_oldRect.height()-16);    m_rightPolygon = getRotatePolygonFromRect(m_RotateCenter,m_rightRectf,m_RotateAngle);    m_bottomRectf = QRectF(m_oldRect.x(),m_oldRect.bottom()-8,m_oldRect.width()-8,8);    m_bottomPolygon = getRotatePolygonFromRect(m_RotateCenter,m_bottomRectf,m_RotateAngle);//    m_rbRectf = QRectF(m_oldRect.right()-8,m_oldRect.bottom()-8,8,8);//    m_rbPolygon = getRotatePolygonFromRect(m_RotateCenter,m_rbRectf,m_RotateAngle);    m_SmallRotateRect = getSmallRotateRect(mrect.topLeft(),mrect.topRight());//矩形正上方的旋转标记矩形    m_SmallRotatePolygon = getRotatePolygonFromRect(m_RotateCenter,m_SmallRotateRect,m_RotateAngle);&#125;void myGraphicRectItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123;    QPen mPen = QPen(Qt::yellow);    painter-&gt;setPen(mPen);    //绘制旋转后的矩形    painter-&gt;drawPolygon(m_oldRectPolygon);    //绘制旋转圆形    mPen.setWidth(2);    mPen.setColor(Qt::green);    painter-&gt;setPen(mPen);    QPointF pf = getSmallRotateRectCenter(m_oldRectPolygon[0],m_oldRectPolygon[1]);    QRectF rect = QRectF(pf.x()-10,pf.y()-10,20,20);    painter-&gt;drawEllipse(rect);//绘制圆形    painter-&gt;drawPoint(pf);//绘制点&#125;void myGraphicRectItem::mousePressEvent(QGraphicsSceneMouseEvent *event)&#123;    if(event-&gt;button()== Qt::LeftButton)    &#123;        m_startPos = event-&gt;pos();//鼠标左击时，获取当前鼠标在图片中的坐标，        if(m_SmallRotatePolygon.containsPoint(m_startPos,Qt::WindingFill))//旋转矩形        &#123;            setCursor(Qt::PointingHandCursor);            m_StateFlag = ROTATE;        &#125;        else if(m_insicedPolygon.containsPoint(m_startPos,Qt::WindingFill))//在矩形内框区域时按下鼠标，则可拖动图片        &#123;            setCursor(Qt::ClosedHandCursor);   //改变光标形状,手的形状            m_StateFlag = MOV_RECT;//标记当前为鼠标拖动图片移动状态        &#125;        else if(m_leftPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeHorCursor);            m_StateFlag = MOV_LEFT_LINE;//标记当前为用户按下矩形的左边界区域        &#125;        else if(m_rightPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeHorCursor);            m_StateFlag = MOV_RIGHT_LINE;//标记当前为用户按下矩形的右边界区域        &#125;        else if(m_topPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeVerCursor);            m_StateFlag = MOV_TOP_LINE;//标记当前为用户按下矩形的上边界区域        &#125;        else if(m_bottomPolygon.containsPoint(m_startPos,Qt::WindingFill))        &#123;            setCursor(Qt::SizeVerCursor);            m_StateFlag = MOV_BOTTOM_LINE;//标记当前为用户按下矩形的下边界区域        &#125;//        else if(m_rbPolygon.containsPoint(m_startPos,Qt::WindingFill))//        &#123;//            setCursor(Qt::SizeFDiagCursor);//            m_StateFlag = MOV_RIGHTBOTTOM_RECT;//标记当前为用户按下矩形的右下角//        &#125;        else        &#123;            m_StateFlag = DEFAULT_FLAG;        &#125;    &#125;    else    &#123;        QGraphicsItem::mousePressEvent(event);    &#125;&#125;void myGraphicRectItem::mouseMoveEvent(QGraphicsSceneMouseEvent *event)&#123;    if(m_StateFlag == ROTATE)    &#123;       int nRotateAngle = atan2((event-&gt;pos().x()-m_RotateCenter.x()),(event-&gt;pos().y()-m_RotateCenter.y()))*180/M_PI;       SetRotate(180-nRotateAngle);       setRectSize(m_oldRect);       //qDebug()&lt;&lt;nRotateAngle;    &#125;    else if(m_StateFlag == MOV_RECT)    &#123;        QPointF point = (event-&gt;pos() - m_startPos);        moveBy(point.x(), point.y());        setRectSize(m_oldRect);        scene()-&gt;update();    &#125;    else if(m_StateFlag == MOV_LEFT_LINE)    &#123;        QPointF pf = QPointF((m_oldRectPolygon.at(1).x()+m_oldRectPolygon.at(2).x())/2,((m_oldRectPolygon.at(1).y()+m_oldRectPolygon.at(2).y())/2));        //计算到右侧边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2RT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));        if(dis&lt;16||dis2LT&gt;dis2RT)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setLeft(m_oldRect.right()-dis);            newRect.setRight(m_oldRect.right());            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;    else if(m_StateFlag == MOV_TOP_LINE)    &#123;        //底边中点        QPointF pf = QPointF((m_oldRectPolygon.at(2).x()+m_oldRectPolygon.at(3).x())/2,((m_oldRectPolygon.at(2).y()+m_oldRectPolygon.at(3).y())/2));        //计算到底边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2LB = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));        if(dis&lt;16||dis2LT&gt;dis2LB)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setTop(m_oldRect.bottom()-dis);            newRect.setBottom(m_oldRect.bottom());            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;    else if(m_StateFlag == MOV_RIGHT_LINE)    &#123;        QPointF pf = QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(3).x())/2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(3).y())/2));        //计算到左侧边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2RT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(1).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(1).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(1).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(1).y()));        if(dis&lt;16||dis2LT&lt;dis2RT)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setLeft(m_oldRect.left());            newRect.setRight(m_oldRect.left()+dis);            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;    else if(m_StateFlag == MOV_BOTTOM_LINE)    &#123;        //顶边中点        QPointF pf = QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(1).x())/2,((m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(1).y())/2));        //计算到底边中点的距离        qreal dis = sqrt((event-&gt;pos().x()-pf.x())*(event-&gt;pos().x()-pf.x()) +(event-&gt;pos().y()-pf.y())*(event-&gt;pos().y()-pf.y()));        qreal dis2LT = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(0).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(0).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(0).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(0).y()));        qreal dis2LB = sqrt((event-&gt;pos().x()-m_oldRectPolygon.at(3).x())*(event-&gt;pos().x()-m_oldRectPolygon.at(3).x()) +(event-&gt;pos().y()-m_oldRectPolygon.at(3).y())*(event-&gt;pos().y()-m_oldRectPolygon.at(3).y()));        if(dis&lt;16||dis2LT&lt;dis2LB)        &#123;            return;        &#125;        else        &#123;            QRectF newRect(m_oldRect);            newRect.setTop(m_oldRect.top());            newRect.setBottom(m_oldRect.top()+dis);            setRectSize(newRect,false);            m_RotateCenter=QPointF((m_oldRectPolygon.at(0).x()+m_oldRectPolygon.at(2).x())/2,(m_oldRectPolygon.at(0).y()+m_oldRectPolygon.at(2).y())/2);            m_oldRect.moveCenter(m_RotateCenter);            setRectSize(m_oldRect);            scene()-&gt;update();//必须要用scene()-&gt;update()，不能用update();否则会出现重影        &#125;    &#125;&#125;void myGraphicRectItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)&#123;    setCursor(Qt::ArrowCursor);    if(m_StateFlag == MOV_RECT)    &#123;        m_StateFlag = DEFAULT_FLAG;    &#125;    else &#123;        QGraphicsItem::mouseReleaseEvent(event);    &#125;&#125;void myGraphicRectItem::SetRotate(qreal RotateAngle, QPointF ptCenter)&#123;    m_bRotate = true;    if(ptCenter.x()==-999 &amp;&amp; ptCenter.y()==-999)    &#123;        m_RotateCenter = QPointF(m_oldRect.x()+m_oldRect.width()/2,m_oldRect.y()+m_oldRect.height()/2);    &#125;    else    &#123;        m_RotateCenter = ptCenter;    &#125;    m_RotateAngle = RotateAngle;    this-&gt;update();&#125;QPointF myGraphicRectItem::getRotatePoint(QPointF ptCenter, QPointF ptIn, qreal angle)&#123;    double dx = ptCenter.x();    double dy = ptCenter.y();    double x = ptIn.x();    double y = ptIn.y();    double xx,yy;    xx = (x-dx)*cos(angle*M_PI/180)-(y-dy)*sin(angle*M_PI/180)+dx;    yy = (x-dx)*sin(angle*M_PI/180)+(y-dy)*cos(angle*M_PI/180)+dy;    return QPointF(xx,yy);&#125;QList&lt;QPointF&gt; myGraphicRectItem::getRotatePoints(QPointF ptCenter, QList&lt;QPointF&gt; ptIns, qreal angle)&#123;    QList&lt;QPointF&gt; lstPt;    for(int i = 0;i&lt;ptIns.count();i++)    &#123;        lstPt.append(getRotatePoint(ptCenter,ptIns.at(i),angle));    &#125;    return lstPt;&#125;QPolygonF myGraphicRectItem::getRotatePolygonFromRect(QPointF ptCenter, QRectF rectIn, qreal angle)&#123;    QVector&lt;QPointF&gt; vpt;    QPointF pf = getRotatePoint(ptCenter,rectIn.topLeft(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.topRight(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.bottomRight(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.bottomLeft(),angle);    vpt.append(pf);    pf = getRotatePoint(ptCenter,rectIn.topLeft(),angle);    vpt.append(pf);    return QPolygonF(vpt);&#125;QRectF myGraphicRectItem::getCrtPosRectToSceen()&#123;    QRectF retRect = QRectF(m_oldRect.x()+pos().x(),m_oldRect.y()+pos().y(),m_oldRect.width(),m_oldRect.height());    return retRect;&#125;QRectF myGraphicRectItem::getSmallRotateRect(QPointF ptA,QPointF ptB)&#123;    QPointF pt = getSmallRotateRectCenter(ptA,ptB);    return QRectF(pt.x()-10,pt.y()-10,20,20);&#125;QPointF myGraphicRectItem::getSmallRotateRectCenter(QPointF ptA,QPointF ptB)&#123;    QPointF ptCenter = QPointF((ptA.x()+ptB.x())/2,(ptA.y()+ptB.y())/2);//A,B点的中点C    //中垂线方程式为 y=x*k + b;    qreal x,y;//旋转图标矩形的中心    if(abs(ptB.y()-ptA.y())&lt;0.1)    &#123;        if(ptA.x()&lt;ptB.x())//矩形左上角在上方        &#123;            x = ptCenter.x();            y = ptCenter.y()-20;        &#125;        else//矩形左上角在下方        &#123;            x = ptCenter.x();            y = ptCenter.y()+20;        &#125;    &#125;    else if(ptB.y()&gt;ptA.y())//顺时针旋转0-180    &#123;        qreal k = (ptA.x()-ptB.x())/(ptB.y()-ptA.y());//中垂线斜率        qreal b = (ptA.y()+ptB.y())/2-k*(ptA.x()+ptB.x())/2;        //求AB线中垂线上离AB中点20个像素的点C的坐标        x = 20*cos(atan(k))+ptCenter.x();        y = k*x+b;    &#125;    else if(ptB.y()&lt;ptA.y())//顺时针旋转180-360    &#123;        qreal k = (ptA.x()-ptB.x())/(ptB.y()-ptA.y());//中垂线斜率        qreal b = (ptA.y()+ptB.y())/2-k*(ptA.x()+ptB.x())/2;        //求AB线中垂线上离AB中点20个像素的点C的坐标        x = -20*cos(atan(k))+ptCenter.x();        y = k*x+b;    &#125;    return QPointF(x,y);&#125;</code></pre></li></ul><h3 id="功能3：Qt中设置QGraphicsView的背景色为透明且无边框"><a href="#功能3：Qt中设置QGraphicsView的背景色为透明且无边框" class="headerlink" title="功能3：Qt中设置QGraphicsView的背景色为透明且无边框"></a>功能3：Qt中设置<code>QGraphicsView</code>的背景色为透明且无边框</h3><ol><li>设置背景色为透明：在<code>QGraphicsView</code>上调用<code>setStyleSheet()</code>方法，并将背景色样式设置为透明。示例代码如下：</li></ol><pre><code class="c++">QGraphicsView* view = new QGraphicsView;view-&gt;setStyleSheet(&quot;background-color: transparent;&quot;);</code></pre><ol start="2"><li>设置边框：在<code>QGraphicsView</code>上调用<code>setFrameStyle()</code>方法，并将边框样式设置为无边框。示例代码如下：</li></ol><pre><code class="c++">QGraphicsView* view = new QGraphicsView;view-&gt;setFrameStyle(QFrame::NoFrame);</code></pre><p>在Qt中使用一个按钮清除<code>QGraphicsView</code>上监控的图片<code>QGraphicsPixmapItem</code>上画出来不需要的矩形<code>QGraphicsRectItem</code></p><ol><li><p>首先，在<code>QGraphicsView</code>上绑定一个按钮<code>QPushButton</code></p><pre><code class="c++">QPushButton* clearBtn = new QPushButton(view);# 将按钮放置在view的左下角btn.setGeometry(0,view.geometry().height()-40,40,20);btn.setText(&quot;clear&quot;);</code></pre></li><li><p>给按钮绑定槽函数，用于清除矩形</p><pre><code class="c++">#在.h文件中定义槽函数private slots:    void on_btn_clicked();</code></pre><pre><code class="c++"># 在构造函数中绑定槽函数connect(clearBtn,SIGNAL(clicked()),this,SLOT(on_btn_clicked()));</code></pre><pre><code class="c++"># 槽函数的具体实现void ImgHelper::on_btn_clicked()&#123;    rectcounts = 0;#设矩形个数为0    scene-&gt;clear();# 清空scene    imgUpdated(cloneImage);# 将直接保存的监控图片重新添加进scene&#125;</code></pre></li></ol><h3 id="功能4：保存错误图片"><a href="#功能4：保存错误图片" class="headerlink" title="功能4：保存错误图片"></a>功能4：保存错误图片</h3><p>当发现监控的图片有问题时，就可以一键保存监控的图片，按日期创建文件夹，方便查看问题</p><pre><code class="c++">void ImgHelper::onSaveErrorImage()&#123;    //20230908    QString currentPath = QDir::currentPath();    QString filedir = currentPath + QDir::separator() + &quot;errorImg&quot;;    QDir dir(filedir);    if(!dir.exists())&#123;       if(dir.mkdir(filedir))&#123;       &#125;else&#123;           qDebug()&lt;&lt;&quot;创建目录失败&quot;;       &#125;    &#125;    QString nowDate = QDateTime::QDateTime::currentDateTime().toString(&quot;yyyy-MM-dd&quot;) ;    QString filedirdate = filedir + QDir::separator() + nowDate;    QDir dirdate(filedirdate);    if(!dirdate.exists())&#123;       if(dirdate.mkdir(filedirdate))&#123;       &#125;else&#123;           qDebug()&lt;&lt;&quot;创建目录失败&quot;;       &#125;    &#125;    for(int i = 1; i &lt;= 8; i++)&#123;        QString imgpath = filedirdate + QDir::separator() + &quot;tt&quot; + QString::number(i) +&quot;.bmp&quot;;        QFile file(imgpath);        //判断文件是否存在        if(file.exists())&#123;           continue;        &#125;        if(pixmapItem != NULL)&#123;            pixmapItem-&gt;pixmap().save(imgpath);        &#125;        break;    &#125;&#125;</code></pre><h3 id="功能5：修复图片通道异常"><a href="#功能5：修复图片通道异常" class="headerlink" title="功能5：修复图片通道异常"></a>功能5：修复图片通道异常</h3><pre><code class="c++">//2023926加  修复PLC查看图片出现的通道异常        for(int x = 0 ; x &lt; image.height(); x++)&#123;                    for(int y = 0 ; y &lt; image.width(); y++)&#123;                        QRgb pixel = image.pixel(x,y);                        int red = qBlue(pixel);                        int green =qRed(pixel);                        int blue = qGreen(pixel);                        QRgb newpixel = qRgb(red,green,blue);                        image.setPixel(x,y,newpixel);                    &#125;                &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析Http协议</title>
      <link href="/2023/10/20/%E8%A7%A3%E6%9E%90Http%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/10/20/%E8%A7%A3%E6%9E%90Http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>在写webSever时了解了一点关于http协议的内容，更方便后面的学习</p><span id="more"></span><p><strong>HTTP</strong>(hypertext transport protocol 超文本传输协议）：一种无状态的，以请求&#x2F;应答方式运行的协议，它使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。</p><h2 id="1-http请求"><a href="#1-http请求" class="headerlink" title="1. http请求"></a>1. http请求</h2><pre><code class="txt">http请求消息分为四部分1. 请求行    不管是get请求还是post请求，请求行分为三部分2. 请求头3. 空行4. 客户端想服务器提交的数据</code></pre><pre><code class="txt">GET /doing HTTP/1.1Host: 10.1.18.4User-Agent: Mozilla/5.0 (Windows NT 6.2; rv:40.0) Gecko/20100101 Firefox/40.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://10.1.18.4/Connection: keep-alive</code></pre><pre><code class="txt">1. 请求行GET /doing HTTP/1.1三部分：请求方式请求的资源（/不代表服务器根目录，是服务器给客户端提供的资源目录）        HTTP协议版本还有看不见的\r\n2. 请求头若干个键值对Host: 10.1.18.4User-Agent: Mozilla/5.0 (Windows NT 6.2; rv:40.0) Gecko/20100101 Firefox/40.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://10.1.18.4/Connection: keep-alive</code></pre><ul><li><p>get</p><ul><li>提交的数据,不安全,提交的数据会显示到地址栏中，被别人看到之后，数据就泄露了</li><li>图中的<code> userid</code>和<code>roomid </code>就是浏览器向服务器提交的数据地址栏中的数据会放到某块缓冲中，地址栏对应的缓存是有上限的,在几k左右</li></ul></li><li><p>post</p><ul><li>提交的数据并不会显示到地址栏中,完全不可见的，因此更安全</li></ul></li></ul><ol><li><p>请求行，用来说明请求类型，要访问的资源以及所使用的<code>http</code>版本。get说明请求类型为get，该行的最后一部分说明使用的是<code>http 1.1</code>版本</p></li><li><p>请求头，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。从第二行起为请求头部，<code>host</code>将指出请求的目的地。<code>User-Agent</code>，服务器端和客户端脚本都能访问它，它是客户端类型检测逻辑的重要基础。该信息由你的客户端来定义，并且在每个请求中自动发送等。</p></li><li><p>空行，请求头部后面的空行是必须的。即使第四部分的请求数据为空，也必须有空行。</p></li><li><p>请求数据也叫主体，可以添加任意的其他数据，上面的请求数据为空。</p></li></ol><h2 id="1-2-http响应"><a href="#1-2-http响应" class="headerlink" title="1.2 http响应"></a>1.2 http响应</h2><ol><li>状态行，由<code>http</code>协议版本号， 状态码， 状态消息三部分组成。上面<code>http</code>版本号为<code>http/1.1</code>，状态码为200，状态消息为”OK”。</li><li>消息报头，用来说明客户端要使用的一些附加信息。<code>Date</code>：生成响应的日期和时间；<code>Content-Type</code>：指定了MIME类型的<code>html(text/html)</code>，编码类型是<code>UTF-8</code>。</li><li>空行，消息报头后面的空行是必须的。</li><li>响应正文，服务器返回给客户端的文本信息，空行后面的<code>html</code>部分为响应正文。</li></ol><h2 id="1-3-http状态码"><a href="#1-3-http状态码" class="headerlink" title="1.3 http状态码"></a>1.3 http状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><pre><code class="txt">1xx:指示信息--表示请求已接收，继续处理2xx:成功--表示请求已被成功接收、理解、接受3xx:重定向--要完成请求必须进行更进—步的操作(网络地址的重新访问)4xx:客户端错误--请求有语法错误或请求无法实现5xx:服务器端错误--服务器未能实现合法的请求</code></pre><p>常见状态码</p><pre><code class="txt">200 OK客户端请求成功400 Bad Request客户端请求有语法错误，不能被服务器所理解401 Unauthorized请求未经授权，这个状态代码必须和Www-Authenticate报头域一起使用403 Forbidden 服务器收到请求，但是拒绝提供服务404 Not Found 请求资源不存在，eg:输入了错误的URL500 Internal Server Error服务器发生不可预期的错误503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下git使用</title>
      <link href="/2023/10/09/Linux%E4%B8%8Bgit%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/09/Linux%E4%B8%8Bgit%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>简单介绍git的基本命令</p><span id="more"></span><h1 id="Linux下Git使用"><a href="#Linux下Git使用" class="headerlink" title="Linux下Git使用"></a>Linux下Git使用</h1><h3 id="1-git的安装"><a href="#1-git的安装" class="headerlink" title="1. git的安装"></a>1. git的安装</h3><pre><code class="shell">sudo apt install git</code></pre><p>安装完，使用<code>git --version</code>查看git版本</p><h3 id="2-配置git"><a href="#2-配置git" class="headerlink" title="2. 配置git"></a>2. 配置git</h3><pre><code class="shell">git config --global user.name &quot;Your Name“##配置用户 git config --global user.email email@example.com##配置邮箱git config --global --list##查看配置信息## --global 全局配置，所有仓库生效，不加就只对当前用户有效## --system 系统配置，对所有用户生效</code></pre><h3 id="3-新建版本库"><a href="#3-新建版本库" class="headerlink" title="3. 新建版本库"></a>3. 新建版本库</h3><pre><code class="shell"> git init</code></pre><h3 id="4-工作区域与文件状态"><a href="#4-工作区域与文件状态" class="headerlink" title="4. 工作区域与文件状态"></a>4. 工作区域与文件状态</h3><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920204530239.png" alt="image-20230920204530239"></p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920204638439.png" alt="image-20230920204638439"></p><h3 id="5-添加和提交文件"><a href="#5-添加和提交文件" class="headerlink" title="5. 添加和提交文件"></a>5. 添加和提交文件</h3><pre><code class="shell">git init##创建仓库git status##查看仓库的状态git add##添加到暂存库git commit ##提交git rm --cached &lt;file&gt;...##将文件从暂存区中去除git log##查看提交记录git ls-files##查看暂存区的文件git commit -a -m &quot; &quot; #实现添加和提交两个步骤</code></pre><h3 id="3-回退版本"><a href="#3-回退版本" class="headerlink" title="3. 回退版本"></a>3. 回退版本</h3><pre><code class="shell">git reset --softgit reset --hardgit reset --mixed</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921085607903.png" alt="image-20230921085607903"></p><pre><code class="shell">git reset HEAD^##默认为mixed,回退一个版本</code></pre><pre><code class="txt">HEAD 表示当前版本HEAD^ 上一个版本HEAD^^ 上上一个版本HEAD^^^ 上上上一个版本HEAD~0 表示当前版本HEAD~1 上一个版本HEAD^2 上上一个版本HEAD^3 上上上一个版本执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</code></pre><p>误操作之后</p><pre><code class="shell">git reflog##回溯日志git reset --hard 版本号##回退</code></pre><h3 id="6-查看差异"><a href="#6-查看差异" class="headerlink" title="6. 查看差异"></a>6. 查看差异</h3><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921091532989.png" alt="image-20230921091532989"></p><pre><code class="shell">git diff#默认比较工作区和暂存区之间的差异git diff HEAD#比较工作区和版本库之间的差异git diff --cached#比较暂存区和版本库之间的区别git diff 版本号版本号#比较两个版本之间的差异git diff HEAD~ HEAD#如回退版本</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921092511736.png" alt="image-20230921092511736"></p><h3 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7. 删除文件"></a>7. 删除文件</h3><p>方法1：先删除本地文件，再提交</p><pre><code class="shell">rm -rf 3.txt##删除本地中的文件git add .##删除暂存区中的文件git commit -m &#39;deleted 3.txt&#39;##删除工作区文件</code></pre><p>方法2</p><pre><code class="shell">git rm 2.txt##删除本地和暂存区中文件git commit -m &#39;deleted 2.txt&#39;##删除工作区文件</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921093523261.png" alt="image-20230921093523261"></p><h3 id="8-忽略文件"><a href="#8-忽略文件" class="headerlink" title="8. 忽略文件"></a>8. 忽略文件</h3><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921093644360.png" alt="image-20230921093644360"></p><pre><code class="shell"> echo &quot;*.log&quot; &gt; .gitignore##表示忽略所有日志文件</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921094538072.png" alt="image-20230921094538072"></p><h3 id="9-远程仓库github"><a href="#9-远程仓库github" class="headerlink" title="9. 远程仓库github"></a>9. 远程仓库github</h3><p>注册github账号，创建仓库</p><h3 id="10-ssh配置和克隆仓库"><a href="#10-ssh配置和克隆仓库" class="headerlink" title="10. ssh配置和克隆仓库"></a>10. ssh配置和克隆仓库</h3><p>创建ssh密钥</p><pre><code class="shell">cd ~cd .ssh#如果显示文件不存在，就之间执行以下命令ssh-keygen -t rsa -b 4096 -C &quot;xxx@email.com&quot;#直接enter,如果是第二次执行，记得更改文件名，不然会覆盖之前的id_rsa文件，且不可逆</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921101312117.png" alt="image-20230921101312117"></p><p>执行之前的命令会生成以下两个文件，有.pub的是公钥文件，没有的是私钥文件，复制公钥文件到github的Settings里的ssh配置</p><p>如果是第一次配置就配置完了，如果是第二次，更改了文件名的，就需要新建一个config文件，内容为</p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921101639858.png" alt="image-20230921101639858"></p><p>意思是：当我们在访问github.com这个网站的时候。使用的是test这个文件里的密钥</p><pre><code class="shell"> git clone git@github.com:xxx.git##克隆新建的远程仓库</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921102254407.png" alt="image-20230921102254407"></p><pre><code class="shell">git push##将本地文件推送到远程仓库</code></pre><h3 id="11-关联本地仓库和远程仓库"><a href="#11-关联本地仓库和远程仓库" class="headerlink" title="11. 关联本地仓库和远程仓库"></a>11. 关联本地仓库和远程仓库</h3><ol><li>本地无仓库</li></ol><pre><code class="shell">echo &quot;# fist-repo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin git@github.com:xxx.gitgit push -u origin main</code></pre><ol start="2"><li>本地已经有仓库</li></ol><pre><code class="shell">git remote add origin git@github.com:xxx.git##添加一个远程仓库git branch -M main##指定分支的名称为maingit push -u origin main##把本地的main分支与远程的orgin main分支关联</code></pre><pre><code class="shell">git remote -v##查看本地仓库对应的远程仓库别名</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921103436235.png" alt="image-20230921103436235"></p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921103522078.png" alt="image-20230921103522078"></p><h3 id="12-分支"><a href="#12-分支" class="headerlink" title="12. 分支"></a>12. 分支</h3><pre><code class="shell">git branch#查看分支git branchdev#新建分支devgit checkout dev#切换到分支dev(有风险，有时会用来恢复文件)git switch main#切换到分支maingit merge dev#将要被合并的分支(dev)合并到当前分支(main)git log --graph --oneline --decorate --all##查看分支情况git branch -d dev#删除分支(已经合并)git branch -D dev#删除分支(未合并，强行删除)</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921140159925.png" alt="image-20230921140159925"></p><h3 id="13-回退和rebase"><a href="#13-回退和rebase" class="headerlink" title="13. 回退和rebase"></a>13. 回退和rebase</h3><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921140826350.png" alt="image-20230921140826350"></p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921141221770.png" alt="image-20230921141221770"></p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921141308973.png" alt="image-20230921141308973"></p><h3 id="14-分支管理和工作流模型"><a href="#14-分支管理和工作流模型" class="headerlink" title="14. 分支管理和工作流模型"></a>14. 分支管理和工作流模型</h3><ol><li><strong>git flow模型</strong></li></ol><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/v2-04b62035a49e04e997d3cb05e22970a9_r.jpg" alt="img"></p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/v2-f20d5d1eab3704639fe64531776b4bac_720w.webp" alt="img"></p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/v2-c7b37d13cfb22d77c840bac3cceee6a7_r.jpg" alt="img"></p><ol start="2"><li><strong>github flow模型</strong></li></ol><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921141728150.png" alt="image-20230921141728150"></p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230921141750346.png" alt="image-20230921141750346"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux高性能服务器编程I</title>
      <link href="/2023/09/25/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8BI/"/>
      <url>/2023/09/25/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8BI/</url>
      
        <content type="html"><![CDATA[<p>今天的内容包括一些linux网络编程基本api和实现了TCP协议的服务端以及客户端。</p><span id="more"></span><h1 id="Linux高性能服务器编程笔记"><a href="#Linux高性能服务器编程笔记" class="headerlink" title="Linux高性能服务器编程笔记"></a>Linux高性能服务器编程笔记</h1><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><p>大端字节序（网络字节序，数据传输，JAVA虚拟机）：高位字节存储在内存的低地址处</p><p>小端字节序（主机字节序，现代PC机）：低位字节存储在内存的低地址处</p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230925111901112.png" alt="image-20230925111901112"></p><p>地址族类型通常与协议族类型相对应</p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230925112244293.png" alt="image-20230925112244293"></p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230925141532173.png" alt="image-20230925141532173"></p><pre><code class="c">#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;int main(int argc ,char *argv[])&#123;    char buf[4] = &#123;192,168,1,2&#125;;    int num = *(int *)buf;    int sum = htonl(num);    unsigned char *p = &amp;sum;    printf(&quot;%d %d %d %d\n&quot;,*p,*(p+1),*(p+2),*(p+3));    return 0;&#125;</code></pre><pre><code class="c++">#include &lt;iostream&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char *argv[]) &#123;       //unsigned char buf[4] = &#123;192, 168, 1, 2&#125;;    char buf[4] = &#123;static_cast&lt;char&gt;(192), static_cast&lt;char&gt;(168), static_cast&lt;char&gt;(1), static_cast&lt;char&gt;(2)&#125;;        int num = *(int *)buf;    int sum = htonl(num);    unsigned char *p = reinterpret_cast&lt;unsigned char *&gt;(&amp;sum);    std::cout &lt;&lt; static_cast&lt;int&gt;(*p) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(*(p + 1)) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(*(p + 2)) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(*(p + 3)) &lt;&lt; std::endl;    return 0;&#125;</code></pre><pre><code>2 1 168 192</code></pre><p>c语言代码转c++时，在初始化<code>buf</code>数组时，对于大于一个字节的整数，需要将其强制转换为<code>char</code>类型，使用<code>static_cast&lt;char&gt;(value)</code>进行转换即可。这样做可以避免<code>narrowing conversion</code>错误。</p><p><strong>网络里面的数据类型定义都应该用无符号，更加保险</strong></p><h3 id="点分十进制转换"><a href="#点分十进制转换" class="headerlink" title="点分十进制转换"></a>点分十进制转换</h3><pre><code class="txt">// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1int inet_pton(int af, const char * src, void* dst);// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)const char* inet_ntop(int af, const void*  src, char* dst, socklen_t cnt);</code></pre><pre><code class="txt">// 创建 命名 监听 socket# include &lt;sys/types.h&gt;# include &lt;sys/socket.h&gt;// domain指定使用那个协议族 PF_INET PF_INET6// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)// protocol设置为默认的0// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1int socket(int domain, int type, int protocol);// socket为socket文件描述符// my_addr 为地址信息// addrlen为socket地址长度// 成功返回0 失败返回 -1int bind(int socket, const struct sockaddr* my_addr, socklen_t addrlen);// backlog表示队列最大的长度int listen(int socket, int backlog);// 接受连接 失败返回-1 成功时返回socketint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)</code></pre><p>在Linux内核2.2之后，<code>socket backlog</code>参数的形为改变了，<strong>现在它指等待<code>accept</code>的<code>完全建立</code>的套接字的队列长度</strong>，而不是不完全连接请求的数量。 <strong>不完全连接</strong>的长度可以使用<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>设置。这意味着当前Linux版本使用上面第二种说法，有两个队列：具有由系统范围设置指定的大小的<code>SYN队列</code> 和 应用程序（也就是backlog参数）指定的<code>accept</code>队列。</p><pre><code class="shell">cat /proc/sys/net/ipv4/tcp_max_syn_backlog512</code></pre><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a><strong>TCP协议</strong></h3><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230926154633974.png" alt="image-20230926154633974"></p><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230927104224676.png" alt="TCP协议流程"></p><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/20170305084830550" alt="这里写图片描述"></p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><pre><code class="c++">#include &lt;iostream&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123;    // 1. 创建套接字    int socket_fd;    socket_fd = socket(AF_INET,SOCK_STREAM,0);    // 2. 连接服务器    struct  sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(8080);    inet_pton(AF_INET,&quot;172.18.192.1&quot;,&amp;addr.sin_addr.s_addr);        connect(socket_fd,(struct sockaddr*)&amp;addr,sizeof(addr));    // 3. 读写数据    char buf[1024] = &quot;&quot;;    while(1)&#123;        int n = read(STDIN_FILENO,buf,sizeof(buf));        write(socket_fd,buf,n);     //发送数据给服务器        n = read(socket_fd,buf,sizeof(buf));        write(STDOUT_FILENO,buf,sizeof(buf));    &#125;    // 4. 关闭链接    close(socket_fd);    return 0;&#125;</code></pre><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><pre><code class="c++">#include&lt;iostream&gt;#include&lt;sys/socket.h&gt;#include&lt;unistd.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123;    // 1. 创建套接字    int socket_fd;    socket_fd = socket(AF_INET,SOCK_STREAM,0);    cout&lt;&lt;socket_fd&lt;&lt;endl;    // 2. 绑定 bind    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(8010);    addr.sin_addr.s_addr = 0;   //如果是0，绑定的是通配地址   // inet_pton(AF_INET,&quot;192.168.0.102&quot;,&amp;addr.sin_addr.s_addr);    int ret = bind(socket_fd,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ret &lt; 0)&#123;        perror(&quot;&quot;);        exit(0);    &#125;    // 3. 监听 listen    listen(socket_fd,128);  //参数128是等待监听队列和已连接监听队列之和的最大值（linux2.2后，只表示已连接队列）    // 4. 提取 accept    struct sockaddr_in cliaddr; //已建立连接    socklen_t len = sizeof(cliaddr);    int Con_fd = accept(socket_fd,(struct sockaddr *)&amp;cliaddr,&amp;len);  //已连接套接字    char ip[16]=&quot;&quot;;    printf(&quot;new client ip=%s port=%d\n&quot;,inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));    // 5. 读写    char buf[1024] = &quot;&quot;;    while(1)&#123;        bzero(buf,sizeof(buf));     //清空buff        int n = read(STDIN_FILENO,buf,sizeof(buf));        write(Con_fd,buf,n);        n = read(Con_fd,buf,sizeof(buf));        printf(&quot;%s\n&quot;,buf);            &#125;    // 6. 关闭    close(socket_fd);    close(Con_fd);    return 0;&#125;</code></pre><p>可以使用命令<code> nc 127.0.0.1 8008</code>连接服务器</p><pre><code class="txt">new client ip=127.0.0.1 port=56918</code></pre><h4 id="出错处理封装函数"><a href="#出错处理封装函数" class="headerlink" title="出错处理封装函数"></a>出错处理封装函数</h4><h5 id="warp-c"><a href="#warp-c" class="headerlink" title="warp.c"></a>warp.c</h5><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;void perr_exit(const char *s)&#123;    perror(s);    exit(1);&#125;int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)&#123;    int n;    again:    if ( (n = accept(fd, sa, salenptr)) &lt; 0) &#123;        if ((errno == ECONNABORTED) || (errno == EINTR))            goto again;        else            perr_exit(&quot;accept error&quot;);    &#125;    return n;&#125;int Bind(int fd, const struct sockaddr *sa, socklen_t salen)&#123;    int n;    if ((n = bind(fd, sa, salen)) &lt; 0)        perr_exit(&quot;bind error&quot;);    return n;&#125;int Connect(int fd, const struct sockaddr *sa, socklen_t salen)&#123;    int n;    if ((n = connect(fd, sa, salen)) &lt; 0)        perr_exit(&quot;connect error&quot;);    return n;&#125;int Listen(int fd, int backlog)&#123;    int n;    if ((n = listen(fd, backlog)) &lt; 0)        perr_exit(&quot;listen error&quot;);    return n;&#125;int Socket(int family, int type, int protocol)&#123;    int n;    if ( (n = socket(family, type, protocol)) &lt; 0)        perr_exit(&quot;socket error&quot;);    return n;&#125;ssize_t Read(int fd, void *ptr, size_t nbytes)&#123;    ssize_t n;again:    if ( (n = read(fd, ptr, nbytes)) == -1) &#123;        if (errno == EINTR)            goto again;        else            return -1;    &#125;    return n;&#125;ssize_t Write(int fd, const void *ptr, size_t nbytes)&#123;    ssize_t n;again:    if ( (n = write(fd, ptr, nbytes)) == -1) &#123;        if (errno == EINTR)            goto again;        else            return -1;    &#125;    return n;&#125;int Close(int fd)&#123;    int n;    if ((n = close(fd)) == -1)        perr_exit(&quot;close error&quot;);    return n;&#125;ssize_t Readn(int fd, void *vptr, size_t n)&#123;    size_t nleft;    ssize_t nread;    char *ptr;    ptr = vptr;    nleft = n;    while (nleft &gt; 0) &#123;        if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123;            if (errno == EINTR)                nread = 0;            else                return -1;        &#125; else if (nread == 0)            break;        nleft -= nread;        ptr += nread;    &#125;    return n - nleft;&#125;ssize_t Writen(int fd, const void *vptr, size_t n)&#123;    size_t nleft;    ssize_t nwritten;    const char *ptr;    ptr = vptr;    nleft = n;    while (nleft &gt; 0) &#123;        if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123;            if (nwritten &lt; 0 &amp;&amp; errno == EINTR)                nwritten = 0;            else                return -1;        &#125;        nleft -= nwritten;        ptr += nwritten;    &#125;    return n;&#125;static ssize_t my_read(int fd, char *ptr)&#123;    static int read_cnt;    static char *read_ptr;    static char read_buf[100];    if (read_cnt &lt;= 0) &#123;again:        if ((read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) &#123;            if (errno == EINTR)                goto again;            return -1;        &#125; else if (read_cnt == 0)            return 0;        read_ptr = read_buf;    &#125;    read_cnt--;    *ptr = *read_ptr++;    return 1;&#125;ssize_t Readline(int fd, void *vptr, size_t maxlen)&#123;    ssize_t n, rc;    char c, *ptr;    ptr = vptr;    for (n = 1; n &lt; maxlen; n++) &#123;        if ( (rc = my_read(fd, &amp;c)) == 1) &#123;            *ptr++ = c;            if (c == &#39;\n&#39;)                break;        &#125; else if (rc == 0) &#123;            *ptr = 0;            return n - 1;        &#125; else            return -1;    &#125;    *ptr = 0;    return n;&#125;</code></pre><h5 id="warp-h"><a href="#warp-h" class="headerlink" title="warp.h"></a>warp.h</h5><pre><code>#ifndef __WRAP_H_#define __WRAP_H_void perr_exit(const char *s);int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr);int Bind(int fd, const struct sockaddr *sa, socklen_t salen);int Connect(int fd, const struct sockaddr *sa, socklen_t salen);int Listen(int fd, int backlog);int Socket(int family, int type, int protocol);ssize_t Read(int fd, void *ptr, size_t nbytes);ssize_t Write(int fd, const void *ptr, size_t nbytes);int Close(int fd);ssize_t Readn(int fd, void *vptr, size_t n);ssize_t Writen(int fd, const void *vptr, size_t n);ssize_t my_read(int fd, char *ptr);ssize_t Readline(int fd, void *vptr, size_t maxlen);#endif</code></pre><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230927104030417.png" alt="image-20230927104030417"></p><h3 id="多进程服务端"><a href="#多进程服务端" class="headerlink" title="多进程服务端"></a>多进程服务端</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt; #define BUF_SIZE 256 void do_sigchld(int signo, siginfo_t *siginfo, void *p)&#123;    int status;    pid_t pid;    while((pid = waitpid(0, &amp;status, WNOHANG)) &gt; 0) //0:回收跟调用进程同组的子进程的资源，WNOHANG:不阻塞    &#123;        if (WIFEXITED(status))            printf(&quot;pid = %d, parent pid = %d, child pid = %d, exit status %d\n&quot;, pid, getpid(), siginfo-&gt;si_pid, WEXITSTATUS(status));        else if (WEXITSTATUS(status))            printf(&quot;pid = %d, parent pid = %d, child pid = %d, exit by signal %d\n &quot;, pid, getpid(), siginfo-&gt;si_pid, WIFSIGNALED(status));    &#125;&#125; void sys_err(const char *str, int err)&#123;    perror(str);    exit(err);&#125; int main(int argc, char *argv[])&#123;    if (argc &lt; 2)    &#123;        printf(&quot;%s port\n&quot;, argv[0]);        exit(1);    &#125;    //创建流式套接字    int lfd = socket(AF_INET, SOCK_STREAM, 0);    if (lfd &lt; 0)        sys_err(&quot;socket&quot;, 1);     //绑定ip端口        struct sockaddr_in server_addr;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons((unsigned short)atoi(argv[1]));    server_addr.sin_addr.s_addr = 0; //0表示将本机所有ip都绑定上    int ret = bind(lfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));    if (ret &lt; 0)        sys_err(&quot;bind&quot;, 1);        //监听    ret = listen(lfd, 128);    if (ret &lt; 0)        sys_err(&quot;listen&quot;, 1);        //阻塞SIGCHLD信号    sigset_t set;    sigemptyset(&amp;set);    sigaddset(&amp;set, SIGCHLD);    sigprocmask(SIG_BLOCK, &amp;set, NULL);    int block = 1;    //循环提取    int cfd;    pid_t pid;    struct sockaddr_in client_addr;     socklen_t len = sizeof(client_addr);    char buf[BUF_SIZE];    ssize_t size;    char ip[INET_ADDRSTRLEN] = &quot;&quot;;    while(1)    &#123;        cfd = accept(lfd, (struct sockaddr *)&amp;client_addr, &amp;len);        if (cfd &lt; 0)        &#123;            if (errno == EINTR)                continue;             sys_err(&quot;accept&quot;, 1);        &#125;         printf(&quot;client ip = %s, port = %d connect success\n&quot;, inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, ip, sizeof(ip)), ntohs(client_addr.sin_port));        pid = fork();        if (pid == 0)        &#123;            //in child            close(lfd); //关闭不用了的监听套接字            //解除阻塞SIGCHLD信号            sigprocmask(SIG_UNBLOCK, &amp;set, NULL);            block = 0;             while(1)            &#123;                memset(buf, 0, sizeof(buf));                size = read(cfd, buf, sizeof(buf));                if (size == 0) //客户端断开连接                &#123;                    printf(&quot;client close\n&quot;);                    break;                &#125;                 printf(&quot;%s\n&quot;, buf);                write(cfd, buf, size);            &#125;             break;        &#125;        else if (pid &gt; 0)        &#123;            //in parent            close(cfd); //关闭不用了的跟客户端通讯的套接字            if (1 == block)            &#123;                //先捕捉                struct sigaction sa;                sa.sa_sigaction = do_sigchld;                sigemptyset(&amp;sa.sa_mask);                sa.sa_flags = SA_SIGINFO;                sigaction(SIGCHLD, &amp;sa, NULL);                //后解除阻塞                sigprocmask(SIG_UNBLOCK, &amp;set, NULL);                block = 0;            &#125;        &#125;        else            sys_err(&quot;fork&quot;, 1);    &#125;        //关闭套接字    if (pid == 0)        close(cfd);    else if (pid &gt; 0)        close(lfd);     return 0;&#125;</code></pre><pre><code class="h">new client ip=127.0.0.1 port=53766wnew client ip=127.0.0.1 port=53768q</code></pre><p><code>free_process</code> 函数是用于处理子进程的结束的信号处理函数。当子进程结束时，父进程会收到 <code>SIGCHLD</code> 信号，该信号会触发 <code>free_process</code> 函数。这个函数使用 <code>waitpid</code> 函数来回收子进程，避免它们成为僵尸进程。</p><h4 id="多线程服务端"><a href="#多线程服务端" class="headerlink" title="多线程服务端"></a>多线程服务端</h4><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &quot;wrap.h&quot;typedef struct c_info&#123;    int cfd;    struct sockaddr_in cliaddr;&#125;CINFO;void* client_fun(void *arg);int main(int argc, char *argv[])&#123;    if(argc &lt; 2)&#123;        printf(&quot;argc &lt; 2  \n ./test 8000\n&quot;);        return 0;    &#125;    pthread_attr_t attr;    pthread_attr_init(&amp;attr);    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED); //设置线程的分离状态为分离态,线程在退出后会自动释放其资源，而不需要其他线程等待它结束。    short port = atoi(argv[1]);    int lfd = tcp4bind(port,NULL);  //创建套接字，绑定    Listen(lfd,5);    struct sockaddr_in cliaddr;    socklen_t len = sizeof(cliaddr);    CINFO *info;    while(1)&#123;        int cfd = Accept(lfd,(struct sockaddr *)&amp;cliaddr,&amp;len);        char ip[16]=&quot;&quot;;       // printf(&quot;new client ip=%s port=%d\n&quot;,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));        pthread_t pthid;        info = malloc(sizeof(CINFO));        info-&gt;cfd = cfd;        info-&gt;cliaddr = cliaddr;       // pthread_create(&amp;pthid,NULL,client_fun,info);         pthread_create(&amp;pthid,&amp;attr,client_fun,info);    &#125;    return 0;&#125;void* client_fun(void *arg)&#123;    CINFO *info = (CINFO *)arg;    char ip[16];    printf(&quot;new client ip=%s port=%d\n&quot;,inet_ntop(AF_INET,&amp;info-&gt;cliaddr.sin_addr.s_addr,ip,16),ntohs(info-&gt;cliaddr.sin_port));    while(1)&#123;        char buf[1024]=&quot;&quot;;        int n = read(info-&gt;cfd,buf,sizeof(buf));        if(n &lt; 0)&#123;            perror(&quot;&quot;);            break;        &#125;else if(n == 0)&#123;            printf(&quot;client close\n&quot;);            break;        &#125;else&#123;            printf(&quot;%s\n&quot;,buf);            write(info-&gt;cfd,buf,n);        &#125;    &#125;    close(info-&gt;cfd);    free(info);&#125;</code></pre><h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h4><pre><code class="c">int opt = 1;setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> linux </tag>
            
            <tag> c </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++核心编程I</title>
      <link href="/2023/09/18/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8BI/"/>
      <url>/2023/09/18/C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8BI/</url>
      
        <content type="html"><![CDATA[<p>今天的内容包括内存分区模型、内联函数和拷贝构造函数。</p><span id="more"></span><h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><h3 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1. 内存分区模型"></a>1. 内存分区模型</h3><ul><li>代码区：存放函数的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束由操作系统释放</li></ul><h3 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2. 内联函数"></a>2. 内联函数</h3><p>在C++中，使用关键字 <code>inline</code> 可以将函数定义为内联函数。内联函数的特点是它们的定义必须在每个调用它们的源文件中可见，通常这意味着函数的定义通常会写在头文件（.h）中。</p><p>目的：在编译时将函数的代码嵌入到调用它们的地方，而不是像普通函数一样在链接时进行函数调用。因此，如果函数定义不在可见范围内，编译器无法将其内联到调用点。</p><p><strong>在头文件中声明内联函数的原型（函数声明），并在同一头文件中定义函数的具体实现。</strong></p><pre><code class="c++">#构造函数可以直接赋初值，构造函数特性complex (double r = 0, double i = 0) : re(r),im(i)&#123;&#125;</code></pre><p><em><strong>1. 不带指针的构造函数多半不需要写析构函数</strong></em>     <strong>如果class里面带指针，就必须有拷贝构造和拷贝复制</strong></p><p><strong>2. 写在class里面的方法是内联函数（建议编译器内联，最后还是看编译器）</strong></p><p><em><strong>3. 数据一定要放在private里面，构造函数可以放在private里面，详情见后</strong></em></p><p>以下的常成员函数在常量对象调用时起作用，若没加 <code>const</code>常量对象调用时会报错 ,所以该加<code>const</code>的地方一定要加</p><pre><code class="c++">double real() const &#123; return re; &#125;  #常成员函数</code></pre><ul><li><p><em><strong>参数传递尽量用引用，返回也是</strong></em></p></li><li><p><em><strong>同一个class的不同object之间互为友元（firend)</strong></em></p></li><li><p><em><strong>临时对象  typename ()</strong></em></p></li><li><p><strong>如果class里面带指针，就必须有拷贝构造和拷贝复制</strong></p></li></ul><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920163619993.png" alt="image-20230920163619993" style="zoom:50%;" /><p>​浅拷贝：只拷贝指针</p><p>b &#x3D; a,如果使用编译器默认的函数，是浅拷贝，有可能导致内存泄漏</p><h3 id="3-拷贝构造函数"><a href="#3-拷贝构造函数" class="headerlink" title="3. 拷贝构造函数"></a>3. <strong>拷贝构造函数</strong></h3><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920163938278.png" alt="image-20230920163938278"></p><pre><code>                                                深拷贝:复制内存</code></pre><p><strong>拷贝赋值函数</strong>：把左边拷贝的右边分三步：1. 先把右边清空，2. 重新分配右边跟左边一样大的内存，3. 拷贝</p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920164727873.png" alt="image-20230920164727873" style="zoom:50%;" /><p><img src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20230920200351109.png" alt="12"></p><p>变量可以声明多次，但只能定义一次</p><pre><code class="c++">extern int a;#声明extern int a = 0;   #定义</code></pre><p><strong>静态函数属于类，而不属于对象</strong></p><p><strong>模板类在编译时要把.h文件和.cpp文件都要添加</strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
